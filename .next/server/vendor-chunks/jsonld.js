/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsonld";
exports.ids = ["vendor-chunks/jsonld"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsonld/lib/ContextResolver.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/ContextResolver.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n} = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\nconst {\n  asArray: _asArray\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\nconst {prependBase} = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\nconst ResolvedContext = __webpack_require__(/*! ./ResolvedContext */ \"(ssr)/./node_modules/jsonld/lib/ResolvedContext.js\");\n\nconst MAX_CONTEXT_URLS = 10;\n\nmodule.exports = class ContextResolver {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  constructor({sharedCache}) {\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n\n  async resolve({\n    activeCtx, context, documentLoader, base, cycles = new Set()\n  }) {\n    // process `@context`\n    if(context && _isObject(context) && context['@context']) {\n      context = context['@context'];\n    }\n\n    // context is one or more contexts\n    context = _asArray(context);\n\n    // resolve each context in the array\n    const allResolved = [];\n    for(const ctx of context) {\n      if(_isString(ctx)) {\n        // see if `ctx` has been resolved before...\n        let resolved = this._get(ctx);\n        if(!resolved) {\n          // not resolved yet, resolve\n          resolved = await this._resolveRemoteContext(\n            {activeCtx, url: ctx, documentLoader, base, cycles});\n        }\n\n        // add to output and continue\n        if(_isArray(resolved)) {\n          allResolved.push(...resolved);\n        } else {\n          allResolved.push(resolved);\n        }\n        continue;\n      }\n      if(ctx === null) {\n        // handle `null` context, nothing to cache\n        allResolved.push(new ResolvedContext({document: null}));\n        continue;\n      }\n      if(!_isObject(ctx)) {\n        _throwInvalidLocalContext(context);\n      }\n      // context is an object, get/create `ResolvedContext` for it\n      const key = JSON.stringify(ctx);\n      let resolved = this._get(key);\n      if(!resolved) {\n        // create a new static `ResolvedContext` and cache it\n        resolved = new ResolvedContext({document: ctx});\n        this._cacheResolvedContext({key, resolved, tag: 'static'});\n      }\n      allResolved.push(resolved);\n    }\n\n    return allResolved;\n  }\n\n  _get(key) {\n    // get key from per operation cache; no `tag` is used with this cache so\n    // any retrieved context will always be the same during a single operation\n    let resolved = this.perOpCache.get(key);\n    if(!resolved) {\n      // see if the shared cache has a `static` entry for this URL\n      const tagMap = this.sharedCache.get(key);\n      if(tagMap) {\n        resolved = tagMap.get('static');\n        if(resolved) {\n          this.perOpCache.set(key, resolved);\n        }\n      }\n    }\n    return resolved;\n  }\n\n  _cacheResolvedContext({key, resolved, tag}) {\n    this.perOpCache.set(key, resolved);\n    if(tag !== undefined) {\n      let tagMap = this.sharedCache.get(key);\n      if(!tagMap) {\n        tagMap = new Map();\n        this.sharedCache.set(key, tagMap);\n      }\n      tagMap.set(tag, resolved);\n    }\n    return resolved;\n  }\n\n  async _resolveRemoteContext({activeCtx, url, documentLoader, base, cycles}) {\n    // resolve relative URL and fetch context\n    url = prependBase(base, url);\n    const {context, remoteDoc} = await this._fetchContext(\n      {activeCtx, url, documentLoader, cycles});\n\n    // update base according to remote document and resolve any relative URLs\n    base = remoteDoc.documentUrl || url;\n    _resolveContextUrls({context, base});\n\n    // resolve, cache, and return context\n    const resolved = await this.resolve(\n      {activeCtx, context, documentLoader, base, cycles});\n    this._cacheResolvedContext({key: url, resolved, tag: remoteDoc.tag});\n    return resolved;\n  }\n\n  async _fetchContext({activeCtx, url, documentLoader, cycles}) {\n    // check for max context URLs fetched during a resolve operation\n    if(cycles.size > MAX_CONTEXT_URLS) {\n      throw new JsonLdError(\n        'Maximum number of @context URLs exceeded.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'loading remote context failed' :\n            'context overflow',\n          max: MAX_CONTEXT_URLS\n        });\n    }\n\n    // check for context URL cycle\n    // shortcut to avoid extra work that would eventually hit the max above\n    if(cycles.has(url)) {\n      throw new JsonLdError(\n        'Cyclical @context URLs detected.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'recursive context inclusion' :\n            'context overflow',\n          url\n        });\n    }\n\n    // track cycles\n    cycles.add(url);\n\n    let context;\n    let remoteDoc;\n\n    try {\n      remoteDoc = await documentLoader(url);\n      context = remoteDoc.document || null;\n      // parse string context as JSON\n      if(_isString(context)) {\n        context = JSON.parse(context);\n      }\n    } catch(e) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a valid JSON-LD object. ' +\n        'Possible causes are an inaccessible URL perhaps due to ' +\n        'a same-origin policy (ensure the server uses CORS if you are ' +\n        'using client-side JavaScript), too many redirects, a ' +\n        'non-JSON response, or more than one HTTP Link Header was ' +\n        'provided for a remote context. ' +\n        `URL: \"${url}\".`,\n        'jsonld.InvalidUrl',\n        {code: 'loading remote context failed', url, cause: e});\n    }\n\n    // ensure ctx is an object\n    if(!_isObject(context)) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a JSON object. The ' +\n        'response was valid JSON, but it was not a JSON object. ' +\n        `URL: \"${url}\".`,\n        'jsonld.InvalidUrl', {code: 'invalid remote context', url});\n    }\n\n    // use empty context if no @context key is present\n    if(!('@context' in context)) {\n      context = {'@context': {}};\n    } else {\n      context = {'@context': context['@context']};\n    }\n\n    // append @context URL to context if given\n    if(remoteDoc.contextUrl) {\n      if(!_isArray(context['@context'])) {\n        context['@context'] = [context['@context']];\n      }\n      context['@context'].push(remoteDoc.contextUrl);\n    }\n\n    return {context, remoteDoc};\n  }\n};\n\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; @context must be an object.',\n    'jsonld.SyntaxError', {\n      code: 'invalid local context', context: ctx\n    });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls({context, base}) {\n  if(!context) {\n    return;\n  }\n\n  const ctx = context['@context'];\n\n  if(_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n\n  if(_isArray(ctx)) {\n    for(let i = 0; i < ctx.length; ++i) {\n      const element = ctx[i];\n      if(_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if(_isObject(element)) {\n        _resolveContextUrls({context: {'@context': element}, base});\n      }\n    }\n    return;\n  }\n\n  if(!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for(const term in ctx) {\n    _resolveContextUrls({context: ctx[term], base});\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9Db250ZXh0UmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5REFBUztBQUNyQjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdURBQVE7QUFDcEIsT0FBTyxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxxREFBTztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBZTtBQUMzQyx3QkFBd0IsbUJBQU8sQ0FBQyw2RUFBbUI7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0RBQWtEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELG9DQUFvQyw2QkFBNkI7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsT0FBTyx1Q0FBdUM7O0FBRTlDO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYzs7QUFFdkM7QUFDQTtBQUNBLE9BQU8saURBQWlEO0FBQ3hELGdDQUFnQyx1Q0FBdUM7QUFDdkU7QUFDQTs7QUFFQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQSxTQUFTLHFEQUFxRDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsOEJBQThCLG9DQUFvQztBQUNsRTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVSxvQkFBb0IsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC9saWIvQ29udGV4dFJlc29sdmVyLmpzPzJiYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG59ID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3Qge1xuICBhc0FycmF5OiBfYXNBcnJheVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3Qge3ByZXBlbmRCYXNlfSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IFJlc29sdmVkQ29udGV4dCA9IHJlcXVpcmUoJy4vUmVzb2x2ZWRDb250ZXh0Jyk7XG5cbmNvbnN0IE1BWF9DT05URVhUX1VSTFMgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb250ZXh0UmVzb2x2ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIENvbnRleHRSZXNvbHZlci5cbiAgICpcbiAgICogQHBhcmFtIHNoYXJlZENhY2hlIGEgc2hhcmVkIExSVSBjYWNoZSB3aXRoIGBnZXRgIGFuZCBgc2V0YCBBUElzLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3NoYXJlZENhY2hlfSkge1xuICAgIHRoaXMucGVyT3BDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnNoYXJlZENhY2hlID0gc2hhcmVkQ2FjaGU7XG4gIH1cblxuICBhc3luYyByZXNvbHZlKHtcbiAgICBhY3RpdmVDdHgsIGNvbnRleHQsIGRvY3VtZW50TG9hZGVyLCBiYXNlLCBjeWNsZXMgPSBuZXcgU2V0KClcbiAgfSkge1xuICAgIC8vIHByb2Nlc3MgYEBjb250ZXh0YFxuICAgIGlmKGNvbnRleHQgJiYgX2lzT2JqZWN0KGNvbnRleHQpICYmIGNvbnRleHRbJ0Bjb250ZXh0J10pIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0WydAY29udGV4dCddO1xuICAgIH1cblxuICAgIC8vIGNvbnRleHQgaXMgb25lIG9yIG1vcmUgY29udGV4dHNcbiAgICBjb250ZXh0ID0gX2FzQXJyYXkoY29udGV4dCk7XG5cbiAgICAvLyByZXNvbHZlIGVhY2ggY29udGV4dCBpbiB0aGUgYXJyYXlcbiAgICBjb25zdCBhbGxSZXNvbHZlZCA9IFtdO1xuICAgIGZvcihjb25zdCBjdHggb2YgY29udGV4dCkge1xuICAgICAgaWYoX2lzU3RyaW5nKGN0eCkpIHtcbiAgICAgICAgLy8gc2VlIGlmIGBjdHhgIGhhcyBiZWVuIHJlc29sdmVkIGJlZm9yZS4uLlxuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLl9nZXQoY3R4KTtcbiAgICAgICAgaWYoIXJlc29sdmVkKSB7XG4gICAgICAgICAgLy8gbm90IHJlc29sdmVkIHlldCwgcmVzb2x2ZVxuICAgICAgICAgIHJlc29sdmVkID0gYXdhaXQgdGhpcy5fcmVzb2x2ZVJlbW90ZUNvbnRleHQoXG4gICAgICAgICAgICB7YWN0aXZlQ3R4LCB1cmw6IGN0eCwgZG9jdW1lbnRMb2FkZXIsIGJhc2UsIGN5Y2xlc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIG91dHB1dCBhbmQgY29udGludWVcbiAgICAgICAgaWYoX2lzQXJyYXkocmVzb2x2ZWQpKSB7XG4gICAgICAgICAgYWxsUmVzb2x2ZWQucHVzaCguLi5yZXNvbHZlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsUmVzb2x2ZWQucHVzaChyZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZihjdHggPT09IG51bGwpIHtcbiAgICAgICAgLy8gaGFuZGxlIGBudWxsYCBjb250ZXh0LCBub3RoaW5nIHRvIGNhY2hlXG4gICAgICAgIGFsbFJlc29sdmVkLnB1c2gobmV3IFJlc29sdmVkQ29udGV4dCh7ZG9jdW1lbnQ6IG51bGx9KSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoIV9pc09iamVjdChjdHgpKSB7XG4gICAgICAgIF90aHJvd0ludmFsaWRMb2NhbENvbnRleHQoY29udGV4dCk7XG4gICAgICB9XG4gICAgICAvLyBjb250ZXh0IGlzIGFuIG9iamVjdCwgZ2V0L2NyZWF0ZSBgUmVzb2x2ZWRDb250ZXh0YCBmb3IgaXRcbiAgICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGN0eCk7XG4gICAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLl9nZXQoa2V5KTtcbiAgICAgIGlmKCFyZXNvbHZlZCkge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgc3RhdGljIGBSZXNvbHZlZENvbnRleHRgIGFuZCBjYWNoZSBpdFxuICAgICAgICByZXNvbHZlZCA9IG5ldyBSZXNvbHZlZENvbnRleHQoe2RvY3VtZW50OiBjdHh9KTtcbiAgICAgICAgdGhpcy5fY2FjaGVSZXNvbHZlZENvbnRleHQoe2tleSwgcmVzb2x2ZWQsIHRhZzogJ3N0YXRpYyd9KTtcbiAgICAgIH1cbiAgICAgIGFsbFJlc29sdmVkLnB1c2gocmVzb2x2ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGxSZXNvbHZlZDtcbiAgfVxuXG4gIF9nZXQoa2V5KSB7XG4gICAgLy8gZ2V0IGtleSBmcm9tIHBlciBvcGVyYXRpb24gY2FjaGU7IG5vIGB0YWdgIGlzIHVzZWQgd2l0aCB0aGlzIGNhY2hlIHNvXG4gICAgLy8gYW55IHJldHJpZXZlZCBjb250ZXh0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGR1cmluZyBhIHNpbmdsZSBvcGVyYXRpb25cbiAgICBsZXQgcmVzb2x2ZWQgPSB0aGlzLnBlck9wQ2FjaGUuZ2V0KGtleSk7XG4gICAgaWYoIXJlc29sdmVkKSB7XG4gICAgICAvLyBzZWUgaWYgdGhlIHNoYXJlZCBjYWNoZSBoYXMgYSBgc3RhdGljYCBlbnRyeSBmb3IgdGhpcyBVUkxcbiAgICAgIGNvbnN0IHRhZ01hcCA9IHRoaXMuc2hhcmVkQ2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZih0YWdNYXApIHtcbiAgICAgICAgcmVzb2x2ZWQgPSB0YWdNYXAuZ2V0KCdzdGF0aWMnKTtcbiAgICAgICAgaWYocmVzb2x2ZWQpIHtcbiAgICAgICAgICB0aGlzLnBlck9wQ2FjaGUuc2V0KGtleSwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIF9jYWNoZVJlc29sdmVkQ29udGV4dCh7a2V5LCByZXNvbHZlZCwgdGFnfSkge1xuICAgIHRoaXMucGVyT3BDYWNoZS5zZXQoa2V5LCByZXNvbHZlZCk7XG4gICAgaWYodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB0YWdNYXAgPSB0aGlzLnNoYXJlZENhY2hlLmdldChrZXkpO1xuICAgICAgaWYoIXRhZ01hcCkge1xuICAgICAgICB0YWdNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkQ2FjaGUuc2V0KGtleSwgdGFnTWFwKTtcbiAgICAgIH1cbiAgICAgIHRhZ01hcC5zZXQodGFnLCByZXNvbHZlZCk7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIGFzeW5jIF9yZXNvbHZlUmVtb3RlQ29udGV4dCh7YWN0aXZlQ3R4LCB1cmwsIGRvY3VtZW50TG9hZGVyLCBiYXNlLCBjeWNsZXN9KSB7XG4gICAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBVUkwgYW5kIGZldGNoIGNvbnRleHRcbiAgICB1cmwgPSBwcmVwZW5kQmFzZShiYXNlLCB1cmwpO1xuICAgIGNvbnN0IHtjb250ZXh0LCByZW1vdGVEb2N9ID0gYXdhaXQgdGhpcy5fZmV0Y2hDb250ZXh0KFxuICAgICAge2FjdGl2ZUN0eCwgdXJsLCBkb2N1bWVudExvYWRlciwgY3ljbGVzfSk7XG5cbiAgICAvLyB1cGRhdGUgYmFzZSBhY2NvcmRpbmcgdG8gcmVtb3RlIGRvY3VtZW50IGFuZCByZXNvbHZlIGFueSByZWxhdGl2ZSBVUkxzXG4gICAgYmFzZSA9IHJlbW90ZURvYy5kb2N1bWVudFVybCB8fCB1cmw7XG4gICAgX3Jlc29sdmVDb250ZXh0VXJscyh7Y29udGV4dCwgYmFzZX0pO1xuXG4gICAgLy8gcmVzb2x2ZSwgY2FjaGUsIGFuZCByZXR1cm4gY29udGV4dFxuICAgIGNvbnN0IHJlc29sdmVkID0gYXdhaXQgdGhpcy5yZXNvbHZlKFxuICAgICAge2FjdGl2ZUN0eCwgY29udGV4dCwgZG9jdW1lbnRMb2FkZXIsIGJhc2UsIGN5Y2xlc30pO1xuICAgIHRoaXMuX2NhY2hlUmVzb2x2ZWRDb250ZXh0KHtrZXk6IHVybCwgcmVzb2x2ZWQsIHRhZzogcmVtb3RlRG9jLnRhZ30pO1xuICAgIHJldHVybiByZXNvbHZlZDtcbiAgfVxuXG4gIGFzeW5jIF9mZXRjaENvbnRleHQoe2FjdGl2ZUN0eCwgdXJsLCBkb2N1bWVudExvYWRlciwgY3ljbGVzfSkge1xuICAgIC8vIGNoZWNrIGZvciBtYXggY29udGV4dCBVUkxzIGZldGNoZWQgZHVyaW5nIGEgcmVzb2x2ZSBvcGVyYXRpb25cbiAgICBpZihjeWNsZXMuc2l6ZSA+IE1BWF9DT05URVhUX1VSTFMpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ01heGltdW0gbnVtYmVyIG9mIEBjb250ZXh0IFVSTHMgZXhjZWVkZWQuJyxcbiAgICAgICAgJ2pzb25sZC5Db250ZXh0VXJsRXJyb3InLFxuICAgICAgICB7XG4gICAgICAgICAgY29kZTogYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnID9cbiAgICAgICAgICAgICdsb2FkaW5nIHJlbW90ZSBjb250ZXh0IGZhaWxlZCcgOlxuICAgICAgICAgICAgJ2NvbnRleHQgb3ZlcmZsb3cnLFxuICAgICAgICAgIG1heDogTUFYX0NPTlRFWFRfVVJMU1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgY29udGV4dCBVUkwgY3ljbGVcbiAgICAvLyBzaG9ydGN1dCB0byBhdm9pZCBleHRyYSB3b3JrIHRoYXQgd291bGQgZXZlbnR1YWxseSBoaXQgdGhlIG1heCBhYm92ZVxuICAgIGlmKGN5Y2xlcy5oYXModXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnQ3ljbGljYWwgQGNvbnRleHQgVVJMcyBkZXRlY3RlZC4nLFxuICAgICAgICAnanNvbmxkLkNvbnRleHRVcmxFcnJvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBjb2RlOiBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCcgP1xuICAgICAgICAgICAgJ3JlY3Vyc2l2ZSBjb250ZXh0IGluY2x1c2lvbicgOlxuICAgICAgICAgICAgJ2NvbnRleHQgb3ZlcmZsb3cnLFxuICAgICAgICAgIHVybFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB0cmFjayBjeWNsZXNcbiAgICBjeWNsZXMuYWRkKHVybCk7XG5cbiAgICBsZXQgY29udGV4dDtcbiAgICBsZXQgcmVtb3RlRG9jO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbW90ZURvYyA9IGF3YWl0IGRvY3VtZW50TG9hZGVyKHVybCk7XG4gICAgICBjb250ZXh0ID0gcmVtb3RlRG9jLmRvY3VtZW50IHx8IG51bGw7XG4gICAgICAvLyBwYXJzZSBzdHJpbmcgY29udGV4dCBhcyBKU09OXG4gICAgICBpZihfaXNTdHJpbmcoY29udGV4dCkpIHtcbiAgICAgICAgY29udGV4dCA9IEpTT04ucGFyc2UoY29udGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdEZXJlZmVyZW5jaW5nIGEgVVJMIGRpZCBub3QgcmVzdWx0IGluIGEgdmFsaWQgSlNPTi1MRCBvYmplY3QuICcgK1xuICAgICAgICAnUG9zc2libGUgY2F1c2VzIGFyZSBhbiBpbmFjY2Vzc2libGUgVVJMIHBlcmhhcHMgZHVlIHRvICcgK1xuICAgICAgICAnYSBzYW1lLW9yaWdpbiBwb2xpY3kgKGVuc3VyZSB0aGUgc2VydmVyIHVzZXMgQ09SUyBpZiB5b3UgYXJlICcgK1xuICAgICAgICAndXNpbmcgY2xpZW50LXNpZGUgSmF2YVNjcmlwdCksIHRvbyBtYW55IHJlZGlyZWN0cywgYSAnICtcbiAgICAgICAgJ25vbi1KU09OIHJlc3BvbnNlLCBvciBtb3JlIHRoYW4gb25lIEhUVFAgTGluayBIZWFkZXIgd2FzICcgK1xuICAgICAgICAncHJvdmlkZWQgZm9yIGEgcmVtb3RlIGNvbnRleHQuICcgK1xuICAgICAgICBgVVJMOiBcIiR7dXJsfVwiLmAsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsXG4gICAgICAgIHtjb2RlOiAnbG9hZGluZyByZW1vdGUgY29udGV4dCBmYWlsZWQnLCB1cmwsIGNhdXNlOiBlfSk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGN0eCBpcyBhbiBvYmplY3RcbiAgICBpZighX2lzT2JqZWN0KGNvbnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdEZXJlZmVyZW5jaW5nIGEgVVJMIGRpZCBub3QgcmVzdWx0IGluIGEgSlNPTiBvYmplY3QuIFRoZSAnICtcbiAgICAgICAgJ3Jlc3BvbnNlIHdhcyB2YWxpZCBKU09OLCBidXQgaXQgd2FzIG5vdCBhIEpTT04gb2JqZWN0LiAnICtcbiAgICAgICAgYFVSTDogXCIke3VybH1cIi5gLFxuICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLCB7Y29kZTogJ2ludmFsaWQgcmVtb3RlIGNvbnRleHQnLCB1cmx9KTtcbiAgICB9XG5cbiAgICAvLyB1c2UgZW1wdHkgY29udGV4dCBpZiBubyBAY29udGV4dCBrZXkgaXMgcHJlc2VudFxuICAgIGlmKCEoJ0Bjb250ZXh0JyBpbiBjb250ZXh0KSkge1xuICAgICAgY29udGV4dCA9IHsnQGNvbnRleHQnOiB7fX07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB7J0Bjb250ZXh0JzogY29udGV4dFsnQGNvbnRleHQnXX07XG4gICAgfVxuXG4gICAgLy8gYXBwZW5kIEBjb250ZXh0IFVSTCB0byBjb250ZXh0IGlmIGdpdmVuXG4gICAgaWYocmVtb3RlRG9jLmNvbnRleHRVcmwpIHtcbiAgICAgIGlmKCFfaXNBcnJheShjb250ZXh0WydAY29udGV4dCddKSkge1xuICAgICAgICBjb250ZXh0WydAY29udGV4dCddID0gW2NvbnRleHRbJ0Bjb250ZXh0J11dO1xuICAgICAgfVxuICAgICAgY29udGV4dFsnQGNvbnRleHQnXS5wdXNoKHJlbW90ZURvYy5jb250ZXh0VXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2NvbnRleHQsIHJlbW90ZURvY307XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF90aHJvd0ludmFsaWRMb2NhbENvbnRleHQoY3R4KSB7XG4gIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICAnanNvbmxkLlN5bnRheEVycm9yJywge1xuICAgICAgY29kZTogJ2ludmFsaWQgbG9jYWwgY29udGV4dCcsIGNvbnRleHQ6IGN0eFxuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYWxsIHJlbGF0aXZlIGBAY29udGV4dGAgVVJMcyBpbiB0aGUgZ2l2ZW4gY29udGV4dCBieSBpbmxpbmVcbiAqIHJlcGxhY2luZyB0aGVtIHdpdGggYWJzb2x1dGUgVVJMcy5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCB0aGUgY29udGV4dC5cbiAqIEBwYXJhbSBiYXNlIHRoZSBiYXNlIElSSSB0byB1c2UgdG8gcmVzb2x2ZSByZWxhdGl2ZSBJUklzLlxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZUNvbnRleHRVcmxzKHtjb250ZXh0LCBiYXNlfSkge1xuICBpZighY29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGN0eCA9IGNvbnRleHRbJ0Bjb250ZXh0J107XG5cbiAgaWYoX2lzU3RyaW5nKGN0eCkpIHtcbiAgICBjb250ZXh0WydAY29udGV4dCddID0gcHJlcGVuZEJhc2UoYmFzZSwgY3R4KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZihfaXNBcnJheShjdHgpKSB7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGN0eC5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGN0eFtpXTtcbiAgICAgIGlmKF9pc1N0cmluZyhlbGVtZW50KSkge1xuICAgICAgICBjdHhbaV0gPSBwcmVwZW5kQmFzZShiYXNlLCBlbGVtZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZihfaXNPYmplY3QoZWxlbWVudCkpIHtcbiAgICAgICAgX3Jlc29sdmVDb250ZXh0VXJscyh7Y29udGV4dDogeydAY29udGV4dCc6IGVsZW1lbnR9LCBiYXNlfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKCFfaXNPYmplY3QoY3R4KSkge1xuICAgIC8vIG5vIEBjb250ZXh0IFVSTHMgY2FuIGJlIGZvdW5kIGluIG5vbi1vYmplY3RcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBjdHggaXMgYW4gb2JqZWN0LCByZXNvbHZlIGFueSBjb250ZXh0IFVSTHMgaW4gdGVybXNcbiAgZm9yKGNvbnN0IHRlcm0gaW4gY3R4KSB7XG4gICAgX3Jlc29sdmVDb250ZXh0VXJscyh7Y29udGV4dDogY3R4W3Rlcm1dLCBiYXNlfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/ContextResolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/JsonLdError.js":
/*!************************************************!*\
  !*** ./node_modules/jsonld/lib/JsonLdError.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class JsonLdError extends Error {\n  /**\n   * Creates a JSON-LD Error.\n   *\n   * @param msg the error message.\n   * @param type the error type.\n   * @param details the error details.\n   */\n  constructor(\n    message = 'An unspecified JSON-LD error occurred.',\n    name = 'jsonld.Error',\n    details = {}) {\n    super(message);\n    this.name = name;\n    this.message = message;\n    this.details = details;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9Kc29uTGRFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbGliL0pzb25MZEVycm9yLmpzP2FmOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSnNvbkxkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgSlNPTi1MRCBFcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG1zZyB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHR5cGUgdGhlIGVycm9yIHR5cGUuXG4gICAqIEBwYXJhbSBkZXRhaWxzIHRoZSBlcnJvciBkZXRhaWxzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZSA9ICdBbiB1bnNwZWNpZmllZCBKU09OLUxEIGVycm9yIG9jY3VycmVkLicsXG4gICAgbmFtZSA9ICdqc29ubGQuRXJyb3InLFxuICAgIGRldGFpbHMgPSB7fSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/JsonLdError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/JsonLdProcessor.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/JsonLdProcessor.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = jsonld => {\n  class JsonLdProcessor {\n    toString() {\n      return '[object JsonLdProcessor]';\n    }\n  }\n  Object.defineProperty(JsonLdProcessor, 'prototype', {\n    writable: false,\n    enumerable: false\n  });\n  Object.defineProperty(JsonLdProcessor.prototype, 'constructor', {\n    writable: true,\n    enumerable: false,\n    configurable: true,\n    value: JsonLdProcessor\n  });\n\n  // The Web IDL test harness will check the number of parameters defined in\n  // the functions below. The number of parameters must exactly match the\n  // required (non-optional) parameters of the JsonLdProcessor interface as\n  // defined here:\n  // https://www.w3.org/TR/json-ld-api/#the-jsonldprocessor-interface\n\n  JsonLdProcessor.compact = function(input, ctx) {\n    if(arguments.length < 2) {\n      return Promise.reject(\n        new TypeError('Could not compact, too few arguments.'));\n    }\n    return jsonld.compact(input, ctx);\n  };\n  JsonLdProcessor.expand = function(input) {\n    if(arguments.length < 1) {\n      return Promise.reject(\n        new TypeError('Could not expand, too few arguments.'));\n    }\n    return jsonld.expand(input);\n  };\n  JsonLdProcessor.flatten = function(input) {\n    if(arguments.length < 1) {\n      return Promise.reject(\n        new TypeError('Could not flatten, too few arguments.'));\n    }\n    return jsonld.flatten(input);\n  };\n\n  return JsonLdProcessor;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9Kc29uTGRQcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9Kc29uTGRQcm9jZXNzb3IuanM/MzIyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBqc29ubGQgPT4ge1xuICBjbGFzcyBKc29uTGRQcm9jZXNzb3Ige1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdbb2JqZWN0IEpzb25MZFByb2Nlc3Nvcl0nO1xuICAgIH1cbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnNvbkxkUHJvY2Vzc29yLCAncHJvdG90eXBlJywge1xuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEpzb25MZFByb2Nlc3Nvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IEpzb25MZFByb2Nlc3NvclxuICB9KTtcblxuICAvLyBUaGUgV2ViIElETCB0ZXN0IGhhcm5lc3Mgd2lsbCBjaGVjayB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgZGVmaW5lZCBpblxuICAvLyB0aGUgZnVuY3Rpb25zIGJlbG93LiBUaGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgbXVzdCBleGFjdGx5IG1hdGNoIHRoZVxuICAvLyByZXF1aXJlZCAobm9uLW9wdGlvbmFsKSBwYXJhbWV0ZXJzIG9mIHRoZSBKc29uTGRQcm9jZXNzb3IgaW50ZXJmYWNlIGFzXG4gIC8vIGRlZmluZWQgaGVyZTpcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2pzb24tbGQtYXBpLyN0aGUtanNvbmxkcHJvY2Vzc29yLWludGVyZmFjZVxuXG4gIEpzb25MZFByb2Nlc3Nvci5jb21wYWN0ID0gZnVuY3Rpb24oaW5wdXQsIGN0eCkge1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb21wYWN0LCB0b28gZmV3IGFyZ3VtZW50cy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBqc29ubGQuY29tcGFjdChpbnB1dCwgY3R4KTtcbiAgfTtcbiAgSnNvbkxkUHJvY2Vzc29yLmV4cGFuZCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGV4cGFuZCwgdG9vIGZldyBhcmd1bWVudHMuJykpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbmxkLmV4cGFuZChpbnB1dCk7XG4gIH07XG4gIEpzb25MZFByb2Nlc3Nvci5mbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgZmxhdHRlbiwgdG9vIGZldyBhcmd1bWVudHMuJykpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbmxkLmZsYXR0ZW4oaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBKc29uTGRQcm9jZXNzb3I7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/JsonLdProcessor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/NQuads.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/NQuads.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// TODO: move `NQuads` to its own package\nmodule.exports = __webpack_require__(/*! rdf-canonize */ \"(ssr)/./node_modules/rdf-canonize/index.js\").NQuads;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9OUXVhZHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSw2R0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9OUXVhZHMuanM/ZjRjYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogbW92ZSBgTlF1YWRzYCB0byBpdHMgb3duIHBhY2thZ2Vcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmRmLWNhbm9uaXplJykuTlF1YWRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/NQuads.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/RequestQueue.js":
/*!*************************************************!*\
  !*** ./node_modules/jsonld/lib/RequestQueue.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class RequestQueue {\n  /**\n   * Creates a simple queue for requesting documents.\n   */\n  constructor() {\n    this._requests = {};\n  }\n\n  wrapLoader(loader) {\n    const self = this;\n    self._loader = loader;\n    return function(/* url */) {\n      return self.add.apply(self, arguments);\n    };\n  }\n\n  async add(url) {\n    let promise = this._requests[url];\n    if(promise) {\n      // URL already queued, wait for it to load\n      return Promise.resolve(promise);\n    }\n\n    // queue URL and load it\n    promise = this._requests[url] = this._loader(url);\n\n    try {\n      return await promise;\n    } finally {\n      delete this._requests[url];\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9SZXF1ZXN0UXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbGliL1JlcXVlc3RRdWV1ZS5qcz84NjFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOSBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVxdWVzdFF1ZXVlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaW1wbGUgcXVldWUgZm9yIHJlcXVlc3RpbmcgZG9jdW1lbnRzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSB7fTtcbiAgfVxuXG4gIHdyYXBMb2FkZXIobG9hZGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5fbG9hZGVyID0gbG9hZGVyO1xuICAgIHJldHVybiBmdW5jdGlvbigvKiB1cmwgKi8pIHtcbiAgICAgIHJldHVybiBzZWxmLmFkZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBhc3luYyBhZGQodXJsKSB7XG4gICAgbGV0IHByb21pc2UgPSB0aGlzLl9yZXF1ZXN0c1t1cmxdO1xuICAgIGlmKHByb21pc2UpIHtcbiAgICAgIC8vIFVSTCBhbHJlYWR5IHF1ZXVlZCwgd2FpdCBmb3IgaXQgdG8gbG9hZFxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9taXNlKTtcbiAgICB9XG5cbiAgICAvLyBxdWV1ZSBVUkwgYW5kIGxvYWQgaXRcbiAgICBwcm9taXNlID0gdGhpcy5fcmVxdWVzdHNbdXJsXSA9IHRoaXMuX2xvYWRlcih1cmwpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgdGhpcy5fcmVxdWVzdHNbdXJsXTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/RequestQueue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/ResolvedContext.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld/lib/ResolvedContext.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst LRU = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/jsonld/node_modules/lru-cache/index.js\");\n\nconst MAX_ACTIVE_CONTEXTS = 10;\n\nmodule.exports = class ResolvedContext {\n  /**\n   * Creates a ResolvedContext.\n   *\n   * @param document the context document.\n   */\n  constructor({document}) {\n    this.document = document;\n    // TODO: enable customization of processed context cache\n    // TODO: limit based on size of processed contexts vs. number of them\n    this.cache = new LRU({max: MAX_ACTIVE_CONTEXTS});\n  }\n\n  getProcessed(activeCtx) {\n    return this.cache.get(activeCtx);\n  }\n\n  setProcessed(activeCtx, processedCtx) {\n    this.cache.set(activeCtx, processedCtx);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9SZXNvbHZlZENvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDhFQUFXOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9SZXNvbHZlZENvbnRleHQuanM/NGMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG5cbmNvbnN0IE1BWF9BQ1RJVkVfQ09OVEVYVFMgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZXNvbHZlZENvbnRleHQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlc29sdmVkQ29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe2RvY3VtZW50fSkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAvLyBUT0RPOiBlbmFibGUgY3VzdG9taXphdGlvbiBvZiBwcm9jZXNzZWQgY29udGV4dCBjYWNoZVxuICAgIC8vIFRPRE86IGxpbWl0IGJhc2VkIG9uIHNpemUgb2YgcHJvY2Vzc2VkIGNvbnRleHRzIHZzLiBudW1iZXIgb2YgdGhlbVxuICAgIHRoaXMuY2FjaGUgPSBuZXcgTFJVKHttYXg6IE1BWF9BQ1RJVkVfQ09OVEVYVFN9KTtcbiAgfVxuXG4gIGdldFByb2Nlc3NlZChhY3RpdmVDdHgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoYWN0aXZlQ3R4KTtcbiAgfVxuXG4gIHNldFByb2Nlc3NlZChhY3RpdmVDdHgsIHByb2Nlc3NlZEN0eCkge1xuICAgIHRoaXMuY2FjaGUuc2V0KGFjdGl2ZUN0eCwgcHJvY2Vzc2VkQ3R4KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/ResolvedContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/compact.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/compact.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\");\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\n\nconst {\n  REGEX_KEYWORD,\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {}\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      const compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options\n      });\n      if(compacted === null) {\n        // FIXME: need event?\n        continue;\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n            // if container is a language map, simplify compacted value to\n            // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        const _iri = _removeBase(_prependBase(base, activeCtx['@base']), iri);\n        return REGEX_KEYWORD.test(_iri) ? `./${_iri}` : _iri;\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9jb21wYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHFFQUFlOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseURBQVM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLG1FQUFjOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBVzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscURBQU87O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx1REFBUTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBbUQ7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtQ0FBbUM7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMkNBQTJDLGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbGliL2NvbXBhY3QuanM/NzMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkOiBfaXNVbmRlZmluZWRcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNMaXN0OiBfaXNMaXN0LFxuICBpc1ZhbHVlOiBfaXNWYWx1ZSxcbiAgaXNHcmFwaDogX2lzR3JhcGgsXG4gIGlzU2ltcGxlR3JhcGg6IF9pc1NpbXBsZUdyYXBoLFxuICBpc1N1YmplY3RSZWZlcmVuY2U6IF9pc1N1YmplY3RSZWZlcmVuY2Vcbn0gPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcblxuY29uc3Qge1xuICBleHBhbmRJcmk6IF9leHBhbmRJcmksXG4gIGdldENvbnRleHRWYWx1ZTogX2dldENvbnRleHRWYWx1ZSxcbiAgaXNLZXl3b3JkOiBfaXNLZXl3b3JkLFxuICBwcm9jZXNzOiBfcHJvY2Vzc0NvbnRleHQsXG4gIHByb2Nlc3NpbmdNb2RlOiBfcHJvY2Vzc2luZ01vZGVcbn0gPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcblxuY29uc3Qge1xuICByZW1vdmVCYXNlOiBfcmVtb3ZlQmFzZSxcbiAgcHJlcGVuZEJhc2U6IF9wcmVwZW5kQmFzZVxufSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbmNvbnN0IHtcbiAgUkVHRVhfS0VZV09SRCxcbiAgYWRkVmFsdWU6IF9hZGRWYWx1ZSxcbiAgYXNBcnJheTogX2FzQXJyYXksXG4gIGNvbXBhcmVTaG9ydGVzdExlYXN0OiBfY29tcGFyZVNob3J0ZXN0TGVhc3Rcbn0gPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBjb21wYWN0cyBhbiBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBhY3RpdmUgY29udGV4dC4gQWxsIHZhbHVlc1xuICogbXVzdCBiZSBpbiBleHBhbmRlZCBmb3JtIGJlZm9yZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBjb21wYWN0ZWQgcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiAgICAgICAgICB0byBjb21wYWN0LCBudWxsIGZvciBub25lLlxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gY29tcGFjdC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBjb21wYWN0aW9uIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29tcGFjdGVkIHZhbHVlLlxuICovXG5hcGkuY29tcGFjdCA9IGFzeW5jICh7XG4gIGFjdGl2ZUN0eCxcbiAgYWN0aXZlUHJvcGVydHkgPSBudWxsLFxuICBlbGVtZW50LFxuICBvcHRpb25zID0ge31cbn0pID0+IHtcbiAgLy8gcmVjdXJzaXZlbHkgY29tcGFjdCBhcnJheVxuICBpZihfaXNBcnJheShlbGVtZW50KSkge1xuICAgIGxldCBydmFsID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGNvbXBhY3RlZCA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudFtpXSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZihjb21wYWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRklYTUU6IG5lZWQgZXZlbnQ/XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnZhbC5wdXNoKGNvbXBhY3RlZCk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMuY29tcGFjdEFycmF5cyAmJiBydmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gdXNlIHNpbmdsZSBlbGVtZW50IGlmIG5vIGNvbnRhaW5lciBpcyBzcGVjaWZpZWRcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICAgIGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGFpbmVyJykgfHwgW107XG4gICAgICBpZihjb250YWluZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJ2YWwgPSBydmFsWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuXG4gIC8vIHVzZSBhbnkgc2NvcGVkIGNvbnRleHQgb24gYWN0aXZlUHJvcGVydHlcbiAgY29uc3QgY3R4ID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRleHQnKTtcbiAgaWYoIV9pc1VuZGVmaW5lZChjdHgpKSB7XG4gICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHtcbiAgICAgIGFjdGl2ZUN0eCxcbiAgICAgIGxvY2FsQ3R4OiBjdHgsXG4gICAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgICBvdmVycmlkZVByb3RlY3RlZDogdHJ1ZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhY3Qgb2JqZWN0XG4gIGlmKF9pc09iamVjdChlbGVtZW50KSkge1xuICAgIGlmKG9wdGlvbnMubGluayAmJiAnQGlkJyBpbiBlbGVtZW50ICYmXG4gICAgICBvcHRpb25zLmxpbmsuaGFzT3duUHJvcGVydHkoZWxlbWVudFsnQGlkJ10pKSB7XG4gICAgICAvLyBjaGVjayBmb3IgYSBsaW5rZWQgZWxlbWVudCB0byByZXVzZVxuICAgICAgY29uc3QgbGlua2VkID0gb3B0aW9ucy5saW5rW2VsZW1lbnRbJ0BpZCddXTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5rZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYobGlua2VkW2ldLmV4cGFuZGVkID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmtlZFtpXS5jb21wYWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkbyB2YWx1ZSBjb21wYWN0aW9uIG9uIEB2YWx1ZXMgYW5kIHN1YmplY3QgcmVmZXJlbmNlc1xuICAgIGlmKF9pc1ZhbHVlKGVsZW1lbnQpIHx8IF9pc1N1YmplY3RSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IHJ2YWwgPVxuICAgICAgICBhcGkuY29tcGFjdFZhbHVlKHthY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB2YWx1ZTogZWxlbWVudCwgb3B0aW9uc30pO1xuICAgICAgaWYob3B0aW9ucy5saW5rICYmIF9pc1N1YmplY3RSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgICAgLy8gc3RvcmUgbGlua2VkIGVsZW1lbnRcbiAgICAgICAgaWYoIShvcHRpb25zLmxpbmsuaGFzT3duUHJvcGVydHkoZWxlbWVudFsnQGlkJ10pKSkge1xuICAgICAgICAgIG9wdGlvbnMubGlua1tlbGVtZW50WydAaWQnXV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dLnB1c2goe2V4cGFuZGVkOiBlbGVtZW50LCBjb21wYWN0ZWQ6IHJ2YWx9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydmFsO1xuICAgIH1cblxuICAgIC8vIGlmIGV4cGFuZGVkIHByb3BlcnR5IGlzIEBsaXN0IGFuZCB3ZSdyZSBjb250YWluZWQgd2l0aGluIGEgbGlzdFxuICAgIC8vIGNvbnRhaW5lciwgcmVjdXJzaXZlbHkgY29tcGFjdCB0aGlzIGl0ZW0gdG8gYW4gYXJyYXlcbiAgICBpZihfaXNMaXN0KGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICBhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuICAgICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpKSB7XG4gICAgICAgIHJldHVybiBhcGkuY29tcGFjdCh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRbJ0BsaXN0J10sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGSVhNRTogYXZvaWQgbWlzdXNlIG9mIGFjdGl2ZSBwcm9wZXJ0eSBhcyBhbiBleHBhbmRlZCBwcm9wZXJ0eT9cbiAgICBjb25zdCBpbnNpZGVSZXZlcnNlID0gKGFjdGl2ZVByb3BlcnR5ID09PSAnQHJldmVyc2UnKTtcblxuICAgIGNvbnN0IHJ2YWwgPSB7fTtcblxuICAgIC8vIG9yaWdpbmFsIGNvbnRleHQgYmVmb3JlIGFwcGx5aW5nIHByb3BlcnR5LXNjb3BlZCBhbmQgbG9jYWwgY29udGV4dHNcbiAgICBjb25zdCBpbnB1dEN0eCA9IGFjdGl2ZUN0eDtcblxuICAgIC8vIHJldmVydCB0byBwcmV2aW91cyBjb250ZXh0LCBpZiB0aGVyZSBpcyBvbmUsXG4gICAgLy8gYW5kIGVsZW1lbnQgaXMgbm90IGEgdmFsdWUgb2JqZWN0IG9yIGEgbm9kZSByZWZlcmVuY2VcbiAgICBpZighX2lzVmFsdWUoZWxlbWVudCkgJiYgIV9pc1N1YmplY3RSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgIGFjdGl2ZUN0eCA9IGFjdGl2ZUN0eC5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCgpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHByb3BlcnR5LXNjb3BlZCBjb250ZXh0IGFmdGVyIHJldmVydGluZyB0ZXJtLXNjb3BlZCBjb250ZXh0XG4gICAgY29uc3QgcHJvcGVydHlTY29wZWRDdHggPVxuICAgICAgX2dldENvbnRleHRWYWx1ZShpbnB1dEN0eCwgYWN0aXZlUHJvcGVydHksICdAY29udGV4dCcpO1xuICAgIGlmKCFfaXNVbmRlZmluZWQocHJvcGVydHlTY29wZWRDdHgpKSB7XG4gICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGxvY2FsQ3R4OiBwcm9wZXJ0eVNjb3BlZEN0eCxcbiAgICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgICBvdmVycmlkZVByb3RlY3RlZDogdHJ1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYob3B0aW9ucy5saW5rICYmICdAaWQnIGluIGVsZW1lbnQpIHtcbiAgICAgIC8vIHN0b3JlIGxpbmtlZCBlbGVtZW50XG4gICAgICBpZighb3B0aW9ucy5saW5rLmhhc093blByb3BlcnR5KGVsZW1lbnRbJ0BpZCddKSkge1xuICAgICAgICBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dID0gW107XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxpbmtbZWxlbWVudFsnQGlkJ11dLnB1c2goe2V4cGFuZGVkOiBlbGVtZW50LCBjb21wYWN0ZWQ6IHJ2YWx9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgY29udGV4dCBkZWZpbmVkIG9uIGFuIGFsaWFzIG9mIEB0eXBlXG4gICAgLy8gaWYga2V5IGlzIEB0eXBlIGFuZCBhbnkgY29tcGFjdGVkIHZhbHVlIGlzIGEgdGVybSBoYXZpbmcgYSBsb2NhbFxuICAgIC8vIGNvbnRleHQsIG92ZXJsYXkgdGhhdCBjb250ZXh0XG4gICAgbGV0IHR5cGVzID0gZWxlbWVudFsnQHR5cGUnXSB8fCBbXTtcbiAgICBpZih0eXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0eXBlcyA9IEFycmF5LmZyb20odHlwZXMpLnNvcnQoKTtcbiAgICB9XG4gICAgLy8gZmluZCBhbGwgdHlwZS1zY29wZWQgY29udGV4dHMgYmFzZWQgb24gY3VycmVudCBjb250ZXh0LCBwcmlvciB0b1xuICAgIC8vIHVwZGF0aW5nIGl0XG4gICAgY29uc3QgdHlwZUNvbnRleHQgPSBhY3RpdmVDdHg7XG4gICAgZm9yKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGNvbnN0IGNvbXBhY3RlZFR5cGUgPSBhcGkuY29tcGFjdElyaShcbiAgICAgICAge2FjdGl2ZUN0eDogdHlwZUNvbnRleHQsIGlyaTogdHlwZSwgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuXG4gICAgICAvLyBVc2UgYW55IHR5cGUtc2NvcGVkIGNvbnRleHQgZGVmaW5lZCBvbiB0aGlzIHZhbHVlXG4gICAgICBjb25zdCBjdHggPSBfZ2V0Q29udGV4dFZhbHVlKGlucHV0Q3R4LCBjb21wYWN0ZWRUeXBlLCAnQGNvbnRleHQnKTtcbiAgICAgIGlmKCFfaXNVbmRlZmluZWQoY3R4KSkge1xuICAgICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgcHJvcGFnYXRlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcm9jZXNzIGVsZW1lbnQga2V5cyBpbiBvcmRlclxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50KS5zb3J0KCk7XG4gICAgZm9yKGNvbnN0IGV4cGFuZGVkUHJvcGVydHkgb2Yga2V5cykge1xuICAgICAgY29uc3QgZXhwYW5kZWRWYWx1ZSA9IGVsZW1lbnRbZXhwYW5kZWRQcm9wZXJ0eV07XG5cbiAgICAgIC8vIGNvbXBhY3QgQGlkXG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGlkJykge1xuICAgICAgICBsZXQgY29tcGFjdGVkVmFsdWUgPSBfYXNBcnJheShleHBhbmRlZFZhbHVlKS5tYXAoXG4gICAgICAgICAgZXhwYW5kZWRJcmkgPT4gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgaXJpOiBleHBhbmRlZElyaSxcbiAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogZmFsc2V9LFxuICAgICAgICAgICAgYmFzZTogb3B0aW9ucy5iYXNlXG4gICAgICAgICAgfSkpO1xuICAgICAgICBpZihjb21wYWN0ZWRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb21wYWN0ZWRWYWx1ZSA9IGNvbXBhY3RlZFZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICBjb25zdCBhbGlhcyA9IGFwaS5jb21wYWN0SXJpKFxuICAgICAgICAgIHthY3RpdmVDdHgsIGlyaTogJ0BpZCcsIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcblxuICAgICAgICBydmFsW2FsaWFzXSA9IGNvbXBhY3RlZFZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcGFjdCBAdHlwZShzKVxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0B0eXBlJykge1xuICAgICAgICAvLyByZXNvbHZlIHR5cGUgdmFsdWVzIGFnYWluc3QgcHJldmlvdXMgY29udGV4dFxuICAgICAgICBsZXQgY29tcGFjdGVkVmFsdWUgPSBfYXNBcnJheShleHBhbmRlZFZhbHVlKS5tYXAoXG4gICAgICAgICAgZXhwYW5kZWRJcmkgPT4gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4OiBpbnB1dEN0eCxcbiAgICAgICAgICAgIGlyaTogZXhwYW5kZWRJcmksXG4gICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgfSkpO1xuICAgICAgICBpZihjb21wYWN0ZWRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb21wYWN0ZWRWYWx1ZSA9IGNvbXBhY3RlZFZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICBjb25zdCBhbGlhcyA9IGFwaS5jb21wYWN0SXJpKFxuICAgICAgICAgIHthY3RpdmVDdHgsIGlyaTogJ0B0eXBlJywgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgIGFjdGl2ZUN0eCwgYWxpYXMsICdAY29udGFpbmVyJykgfHwgW107XG5cbiAgICAgICAgLy8gdHJlYXQgYXMgYXJyYXkgZm9yIEB0eXBlIGlmIEBjb250YWluZXIgaW5jbHVkZXMgQHNldFxuICAgICAgICBjb25zdCB0eXBlQXNTZXQgPVxuICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpICYmXG4gICAgICAgICAgX3Byb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKTtcbiAgICAgICAgY29uc3QgaXNBcnJheSA9XG4gICAgICAgICAgdHlwZUFzU2V0IHx8IChfaXNBcnJheShjb21wYWN0ZWRWYWx1ZSkgJiYgZXhwYW5kZWRWYWx1ZS5sZW5ndGggPT09IDApO1xuICAgICAgICBfYWRkVmFsdWUocnZhbCwgYWxpYXMsIGNvbXBhY3RlZFZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiBpc0FycmF5fSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgQHJldmVyc2VcbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFjdCBleHBhbmRlZCB2YWx1ZVxuICAgICAgICBjb25zdCBjb21wYWN0ZWRWYWx1ZSA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHk6ICdAcmV2ZXJzZScsXG4gICAgICAgICAgZWxlbWVudDogZXhwYW5kZWRWYWx1ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBkb3VibGUtcmV2ZXJzZWQgcHJvcGVydGllc1xuICAgICAgICBmb3IoY29uc3QgY29tcGFjdGVkUHJvcGVydHkgaW4gY29tcGFjdGVkVmFsdWUpIHtcbiAgICAgICAgICBpZihhY3RpdmVDdHgubWFwcGluZ3MuaGFzKGNvbXBhY3RlZFByb3BlcnR5KSAmJlxuICAgICAgICAgICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChjb21wYWN0ZWRQcm9wZXJ0eSkucmV2ZXJzZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb21wYWN0ZWRWYWx1ZVtjb21wYWN0ZWRQcm9wZXJ0eV07XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgICAgICBhY3RpdmVDdHgsIGNvbXBhY3RlZFByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgdXNlQXJyYXkgPSAoXG4gICAgICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpIHx8ICFvcHRpb25zLmNvbXBhY3RBcnJheXMpO1xuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBydmFsLCBjb21wYWN0ZWRQcm9wZXJ0eSwgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHVzZUFycmF5fSk7XG4gICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkVmFsdWVbY29tcGFjdGVkUHJvcGVydHldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKE9iamVjdC5rZXlzKGNvbXBhY3RlZFZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gdXNlIGtleXdvcmQgYWxpYXMgYW5kIGFkZCB2YWx1ZVxuICAgICAgICAgIGNvbnN0IGFsaWFzID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgaXJpOiBleHBhbmRlZFByb3BlcnR5LFxuICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9hZGRWYWx1ZShydmFsLCBhbGlhcywgY29tcGFjdGVkVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAcHJlc2VydmUnKSB7XG4gICAgICAgIC8vIGNvbXBhY3QgdXNpbmcgYWN0aXZlUHJvcGVydHlcbiAgICAgICAgY29uc3QgY29tcGFjdGVkVmFsdWUgPSBhd2FpdCBhcGkuY29tcGFjdCh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIGVsZW1lbnQ6IGV4cGFuZGVkVmFsdWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZighKF9pc0FycmF5KGNvbXBhY3RlZFZhbHVlKSAmJiBjb21wYWN0ZWRWYWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgX2FkZFZhbHVlKHJ2YWwsIGV4cGFuZGVkUHJvcGVydHksIGNvbXBhY3RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIEBpbmRleCBwcm9wZXJ0eVxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BpbmRleCcpIHtcbiAgICAgICAgLy8gZHJvcCBAaW5kZXggaWYgaW5zaWRlIGFuIEBpbmRleCBjb250YWluZXJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2dldENvbnRleHRWYWx1ZShcbiAgICAgICAgICBhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuICAgICAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BpbmRleCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1c2Uga2V5d29yZCBhbGlhcyBhbmQgYWRkIHZhbHVlXG4gICAgICAgIGNvbnN0IGFsaWFzID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBpcmk6IGV4cGFuZGVkUHJvcGVydHksXG4gICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICB9KTtcbiAgICAgICAgX2FkZFZhbHVlKHJ2YWwsIGFsaWFzLCBleHBhbmRlZFZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgYXJyYXkgcHJvY2Vzc2luZyBmb3Iga2V5d29yZHMgdGhhdCBhcmVuJ3RcbiAgICAgIC8vIEBncmFwaCwgQGxpc3QsIG9yIEBpbmNsdWRlZFxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0BncmFwaCcgJiYgZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0BsaXN0JyAmJlxuICAgICAgICBleHBhbmRlZFByb3BlcnR5ICE9PSAnQGluY2x1ZGVkJyAmJlxuICAgICAgICBfaXNLZXl3b3JkKGV4cGFuZGVkUHJvcGVydHkpKSB7XG4gICAgICAgIC8vIHVzZSBrZXl3b3JkIGFsaWFzIGFuZCBhZGQgdmFsdWUgYXMgaXNcbiAgICAgICAgY29uc3QgYWxpYXMgPSBhcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGlyaTogZXhwYW5kZWRQcm9wZXJ0eSxcbiAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgIH0pO1xuICAgICAgICBfYWRkVmFsdWUocnZhbCwgYWxpYXMsIGV4cGFuZGVkVmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZTogZXhwYW5kZWQgdmFsdWUgbXVzdCBiZSBhbiBhcnJheSBkdWUgdG8gZXhwYW5zaW9uIGFsZ29yaXRobS5cbiAgICAgIGlmKCFfaXNBcnJheShleHBhbmRlZFZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0pTT04tTEQgZXhwYW5zaW9uIGVycm9yOyBleHBhbmRlZCB2YWx1ZSBtdXN0IGJlIGFuIGFycmF5LicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVzZXJ2ZSBlbXB0eSBhcnJheXNcbiAgICAgIGlmKGV4cGFuZGVkVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1BY3RpdmVQcm9wZXJ0eSA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgaXJpOiBleHBhbmRlZFByb3BlcnR5LFxuICAgICAgICAgIHZhbHVlOiBleHBhbmRlZFZhbHVlLFxuICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX0sXG4gICAgICAgICAgcmV2ZXJzZTogaW5zaWRlUmV2ZXJzZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmVzdFByb3BlcnR5ID0gYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhpdGVtQWN0aXZlUHJvcGVydHkpID9cbiAgICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KGl0ZW1BY3RpdmVQcm9wZXJ0eSlbJ0BuZXN0J10gOiBudWxsO1xuICAgICAgICBsZXQgbmVzdFJlc3VsdCA9IHJ2YWw7XG4gICAgICAgIGlmKG5lc3RQcm9wZXJ0eSkge1xuICAgICAgICAgIF9jaGVja05lc3RQcm9wZXJ0eShhY3RpdmVDdHgsIG5lc3RQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYoIV9pc09iamVjdChydmFsW25lc3RQcm9wZXJ0eV0pKSB7XG4gICAgICAgICAgICBydmFsW25lc3RQcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVzdFJlc3VsdCA9IHJ2YWxbbmVzdFByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgbmVzdFJlc3VsdCwgaXRlbUFjdGl2ZVByb3BlcnR5LCBleHBhbmRlZFZhbHVlLCB7XG4gICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVjdXNpdmVseSBwcm9jZXNzIGFycmF5IHZhbHVlc1xuICAgICAgZm9yKGNvbnN0IGV4cGFuZGVkSXRlbSBvZiBleHBhbmRlZFZhbHVlKSB7XG4gICAgICAgIC8vIGNvbXBhY3QgcHJvcGVydHkgYW5kIGdldCBjb250YWluZXIgdHlwZVxuICAgICAgICBjb25zdCBpdGVtQWN0aXZlUHJvcGVydHkgPSBhcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgIGlyaTogZXhwYW5kZWRQcm9wZXJ0eSxcbiAgICAgICAgICB2YWx1ZTogZXhwYW5kZWRJdGVtLFxuICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX0sXG4gICAgICAgICAgcmV2ZXJzZTogaW5zaWRlUmV2ZXJzZVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiBpdGVtQWN0aXZlUHJvcGVydHkgaXMgYSBAbmVzdCBwcm9wZXJ0eSwgYWRkIHZhbHVlcyB0byBuZXN0UmVzdWx0LFxuICAgICAgICAvLyBvdGhlcndpc2UgcnZhbFxuICAgICAgICBjb25zdCBuZXN0UHJvcGVydHkgPSBhY3RpdmVDdHgubWFwcGluZ3MuaGFzKGl0ZW1BY3RpdmVQcm9wZXJ0eSkgP1xuICAgICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQoaXRlbUFjdGl2ZVByb3BlcnR5KVsnQG5lc3QnXSA6IG51bGw7XG4gICAgICAgIGxldCBuZXN0UmVzdWx0ID0gcnZhbDtcbiAgICAgICAgaWYobmVzdFByb3BlcnR5KSB7XG4gICAgICAgICAgX2NoZWNrTmVzdFByb3BlcnR5KGFjdGl2ZUN0eCwgbmVzdFByb3BlcnR5LCBvcHRpb25zKTtcbiAgICAgICAgICBpZighX2lzT2JqZWN0KHJ2YWxbbmVzdFByb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIHJ2YWxbbmVzdFByb3BlcnR5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXN0UmVzdWx0ID0gcnZhbFtuZXN0UHJvcGVydHldO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2dldENvbnRleHRWYWx1ZShcbiAgICAgICAgICBhY3RpdmVDdHgsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgJ0Bjb250YWluZXInKSB8fCBbXTtcblxuICAgICAgICAvLyBnZXQgc2ltcGxlIEBncmFwaCBvciBAbGlzdCB2YWx1ZSBpZiBhcHByb3ByaWF0ZVxuICAgICAgICBjb25zdCBpc0dyYXBoID0gX2lzR3JhcGgoZXhwYW5kZWRJdGVtKTtcbiAgICAgICAgY29uc3QgaXNMaXN0ID0gX2lzTGlzdChleHBhbmRlZEl0ZW0pO1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmKGlzTGlzdCkge1xuICAgICAgICAgIGlubmVyID0gZXhwYW5kZWRJdGVtWydAbGlzdCddO1xuICAgICAgICB9IGVsc2UgaWYoaXNHcmFwaCkge1xuICAgICAgICAgIGlubmVyID0gZXhwYW5kZWRJdGVtWydAZ3JhcGgnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBhY3QgZXhwYW5kZWQgaXRlbVxuICAgICAgICBsZXQgY29tcGFjdGVkSXRlbSA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgYWN0aXZlUHJvcGVydHk6IGl0ZW1BY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgICBlbGVtZW50OiAoaXNMaXN0IHx8IGlzR3JhcGgpID8gaW5uZXIgOiBleHBhbmRlZEl0ZW0sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBoYW5kbGUgQGxpc3RcbiAgICAgICAgaWYoaXNMaXN0KSB7XG4gICAgICAgICAgLy8gZW5zdXJlIEBsaXN0IHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgICAgaWYoIV9pc0FycmF5KGNvbXBhY3RlZEl0ZW0pKSB7XG4gICAgICAgICAgICBjb21wYWN0ZWRJdGVtID0gW2NvbXBhY3RlZEl0ZW1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykpIHtcbiAgICAgICAgICAgIC8vIHdyYXAgdXNpbmcgQGxpc3QgYWxpYXNcbiAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSB7XG4gICAgICAgICAgICAgIFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BsaXN0JyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgICAgIH0pXTogY29tcGFjdGVkSXRlbVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBAaW5kZXggZnJvbSBleHBhbmRlZCBAbGlzdCwgaWYgYW55XG4gICAgICAgICAgICBpZignQGluZGV4JyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbVthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BpbmRleCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV0gPSBleHBhbmRlZEl0ZW1bJ0BpbmRleCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfYWRkVmFsdWUobmVzdFJlc3VsdCwgaXRlbUFjdGl2ZVByb3BlcnR5LCBjb21wYWN0ZWRJdGVtLCB7XG4gICAgICAgICAgICAgIHZhbHVlSXNBcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgYWxsb3dEdXBsaWNhdGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR3JhcGggb2JqZWN0IGNvbXBhY3Rpb24gY2FzZXNcbiAgICAgICAgaWYoaXNHcmFwaCkge1xuICAgICAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJykgJiYgKGNvbnRhaW5lci5pbmNsdWRlcygnQGlkJykgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbmNsdWRlcygnQGluZGV4JykgJiYgX2lzU2ltcGxlR3JhcGgoZXhwYW5kZWRJdGVtKSkpIHtcbiAgICAgICAgICAgIC8vIGdldCBvciBjcmVhdGUgdGhlIG1hcCBvYmplY3RcbiAgICAgICAgICAgIGxldCBtYXBPYmplY3Q7XG4gICAgICAgICAgICBpZihuZXN0UmVzdWx0Lmhhc093blByb3BlcnR5KGl0ZW1BY3RpdmVQcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgbWFwT2JqZWN0ID0gbmVzdFJlc3VsdFtpdGVtQWN0aXZlUHJvcGVydHldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVzdFJlc3VsdFtpdGVtQWN0aXZlUHJvcGVydHldID0gbWFwT2JqZWN0ID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluZGV4IG9uIEBpZCBvciBAaW5kZXggb3IgYWxpYXMgb2YgQG5vbmVcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IChjb250YWluZXIuaW5jbHVkZXMoJ0BpZCcpID9cbiAgICAgICAgICAgICAgZXhwYW5kZWRJdGVtWydAaWQnXSA6IGV4cGFuZGVkSXRlbVsnQGluZGV4J10pIHx8XG4gICAgICAgICAgICAgIGFwaS5jb21wYWN0SXJpKHthY3RpdmVDdHgsIGlyaTogJ0Bub25lJyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG4gICAgICAgICAgICAvLyBhZGQgY29tcGFjdGVkSXRlbSB0byBtYXAsIHVzaW5nIHZhbHVlIG9mIGBAaWRgIG9yIGEgbmV3IGJsYW5rXG4gICAgICAgICAgICAvLyBub2RlIGlkZW50aWZpZXJcblxuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBtYXBPYmplY3QsIGtleSwgY29tcGFjdGVkSXRlbSwge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTpcbiAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5jb21wYWN0QXJyYXlzIHx8IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAZ3JhcGgnKSAmJlxuICAgICAgICAgICAgX2lzU2ltcGxlR3JhcGgoZXhwYW5kZWRJdGVtKSkge1xuICAgICAgICAgICAgLy8gY29udGFpbmVyIGluY2x1ZGVzIEBncmFwaCBidXQgbm90IEBpZCBvciBAaW5kZXggYW5kIHZhbHVlIGlzIGFcbiAgICAgICAgICAgIC8vIHNpbXBsZSBncmFwaCBvYmplY3QgYWRkIGNvbXBhY3QgdmFsdWVcbiAgICAgICAgICAgIC8vIGlmIGNvbXBhY3RlZEl0ZW0gY29udGFpbnMgbXVsdGlwbGUgdmFsdWVzLCBpdCBpcyB3cmFwcGVkIGluXG4gICAgICAgICAgICAvLyBgQGluY2x1ZGVkYFxuICAgICAgICAgICAgaWYoX2lzQXJyYXkoY29tcGFjdGVkSXRlbSkgJiYgY29tcGFjdGVkSXRlbS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSB7J0BpbmNsdWRlZCc6IGNvbXBhY3RlZEl0ZW19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgICBuZXN0UmVzdWx0LCBpdGVtQWN0aXZlUHJvcGVydHksIGNvbXBhY3RlZEl0ZW0sIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6XG4gICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuY29tcGFjdEFycmF5cyB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdyYXAgdXNpbmcgQGdyYXBoIGFsaWFzLCByZW1vdmUgYXJyYXkgaWYgb25seSBvbmUgaXRlbSBhbmRcbiAgICAgICAgICAgIC8vIGNvbXBhY3RBcnJheXMgbm90IHNldFxuICAgICAgICAgICAgaWYoX2lzQXJyYXkoY29tcGFjdGVkSXRlbSkgJiYgY29tcGFjdGVkSXRlbS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21wYWN0QXJyYXlzKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW0gPSBjb21wYWN0ZWRJdGVtWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IHtcbiAgICAgICAgICAgICAgW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgICAgaXJpOiAnQGdyYXBoJyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgICAgIH0pXTogY29tcGFjdGVkSXRlbVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaW5jbHVkZSBAaWQgZnJvbSBleHBhbmRlZCBncmFwaCwgaWYgYW55XG4gICAgICAgICAgICBpZignQGlkJyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbVthcGkuY29tcGFjdElyaSh7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICAgIGlyaTogJ0BpZCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgICAgICAgICB9KV0gPSBleHBhbmRlZEl0ZW1bJ0BpZCddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbmNsdWRlIEBpbmRleCBmcm9tIGV4cGFuZGVkIGdyYXBoLCBpZiBhbnlcbiAgICAgICAgICAgIGlmKCdAaW5kZXgnIGluIGV4cGFuZGVkSXRlbSkge1xuICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgICAgaXJpOiAnQGluZGV4JyxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICAgICAgICAgIH0pXSA9IGV4cGFuZGVkSXRlbVsnQGluZGV4J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgICAgIG5lc3RSZXN1bHQsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgY29tcGFjdGVkSXRlbSwge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5SXNBcnJheTpcbiAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5jb21wYWN0QXJyYXlzIHx8IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BsYW5ndWFnZScpIHx8XG4gICAgICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKSB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BpZCcpIHx8XG4gICAgICAgICAgY29udGFpbmVyLmluY2x1ZGVzKCdAdHlwZScpKSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGxhbmd1YWdlIGFuZCBpbmRleCBtYXBzXG4gICAgICAgICAgLy8gZ2V0IG9yIGNyZWF0ZSB0aGUgbWFwIG9iamVjdFxuICAgICAgICAgIGxldCBtYXBPYmplY3Q7XG4gICAgICAgICAgaWYobmVzdFJlc3VsdC5oYXNPd25Qcm9wZXJ0eShpdGVtQWN0aXZlUHJvcGVydHkpKSB7XG4gICAgICAgICAgICBtYXBPYmplY3QgPSBuZXN0UmVzdWx0W2l0ZW1BY3RpdmVQcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lc3RSZXN1bHRbaXRlbUFjdGl2ZVByb3BlcnR5XSA9IG1hcE9iamVjdCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBrZXk7XG4gICAgICAgICAgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAbGFuZ3VhZ2UnKSkge1xuICAgICAgICAgICAgLy8gaWYgY29udGFpbmVyIGlzIGEgbGFuZ3VhZ2UgbWFwLCBzaW1wbGlmeSBjb21wYWN0ZWQgdmFsdWUgdG9cbiAgICAgICAgICAgIC8vIGEgc2ltcGxlIHN0cmluZ1xuICAgICAgICAgICAgaWYoX2lzVmFsdWUoY29tcGFjdGVkSXRlbSkpIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IGNvbXBhY3RlZEl0ZW1bJ0B2YWx1ZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gZXhwYW5kZWRJdGVtWydAbGFuZ3VhZ2UnXTtcbiAgICAgICAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAaW5kZXgnKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhLZXkgPSBfZ2V0Q29udGV4dFZhbHVlKFxuICAgICAgICAgICAgICBhY3RpdmVDdHgsIGl0ZW1BY3RpdmVQcm9wZXJ0eSwgJ0BpbmRleCcpIHx8ICdAaW5kZXgnO1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyS2V5ID0gYXBpLmNvbXBhY3RJcmkoXG4gICAgICAgICAgICAgIHthY3RpdmVDdHgsIGlyaTogaW5kZXhLZXksIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcbiAgICAgICAgICAgIGlmKGluZGV4S2V5ID09PSAnQGluZGV4Jykge1xuICAgICAgICAgICAgICBrZXkgPSBleHBhbmRlZEl0ZW1bJ0BpbmRleCddO1xuICAgICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVtjb250YWluZXJLZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV0IG90aGVycztcbiAgICAgICAgICAgICAgW2tleSwgLi4ub3RoZXJzXSA9IF9hc0FycmF5KGNvbXBhY3RlZEl0ZW1baW5kZXhLZXldIHx8IFtdKTtcbiAgICAgICAgICAgICAgaWYoIV9pc1N0cmluZyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2lsbCB1c2UgQG5vbmUgaWYgaXQgaXNuJ3QgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2gob3RoZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVtpbmRleEtleV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW2luZGV4S2V5XSA9IG90aGVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW2luZGV4S2V5XSA9IG90aGVycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGlkJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkS2V5ID0gYXBpLmNvbXBhY3RJcmkoe2FjdGl2ZUN0eCwgaXJpOiAnQGlkJyxcbiAgICAgICAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfX0pO1xuICAgICAgICAgICAga2V5ID0gY29tcGFjdGVkSXRlbVtpZEtleV07XG4gICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVtpZEtleV07XG4gICAgICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQHR5cGUnKSkge1xuICAgICAgICAgICAgY29uc3QgdHlwZUtleSA9IGFwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgICBpcmk6ICdAdHlwZScsXG4gICAgICAgICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHR5cGVzO1xuICAgICAgICAgICAgW2tleSwgLi4udHlwZXNdID0gX2FzQXJyYXkoY29tcGFjdGVkSXRlbVt0eXBlS2V5XSB8fCBbXSk7XG4gICAgICAgICAgICBzd2l0Y2godHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkZWxldGUgY29tcGFjdGVkSXRlbVt0eXBlS2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbXBhY3RlZEl0ZW1bdHlwZUtleV0gPSB0eXBlc1swXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb21wYWN0ZWRJdGVtW3R5cGVLZXldID0gdHlwZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGNvbXBhY3RlZEl0ZW0gY29udGFpbnMgYSBzaW5nbGUgZW50cnlcbiAgICAgICAgICAgIC8vIHdob3NlIGtleSBtYXBzIHRvIEBpZCwgcmVjb21wYWN0IHdpdGhvdXQgQHR5cGVcbiAgICAgICAgICAgIGlmKE9iamVjdC5rZXlzKGNvbXBhY3RlZEl0ZW0pLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAnQGlkJyBpbiBleHBhbmRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdGVkSXRlbSA9IGF3YWl0IGFwaS5jb21wYWN0KHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgICAgICAgICAgYWN0aXZlUHJvcGVydHk6IGl0ZW1BY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB7J0BpZCc6IGV4cGFuZGVkSXRlbVsnQGlkJ119LFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgY29tcGFjdGluZyB0aGlzIHZhbHVlIHdoaWNoIGhhcyBubyBrZXksIGluZGV4IG9uIEBub25lXG4gICAgICAgICAgaWYoIWtleSkge1xuICAgICAgICAgICAga2V5ID0gYXBpLmNvbXBhY3RJcmkoe2FjdGl2ZUN0eCwgaXJpOiAnQG5vbmUnLFxuICAgICAgICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFkZCBjb21wYWN0IHZhbHVlIHRvIG1hcCBvYmplY3QgdXNpbmcga2V5IGZyb20gZXhwYW5kZWQgdmFsdWVcbiAgICAgICAgICAvLyBiYXNlZCBvbiB0aGUgY29udGFpbmVyIHR5cGVcbiAgICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgICBtYXBPYmplY3QsIGtleSwgY29tcGFjdGVkSXRlbSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2UgYW4gYXJyYXkgaWY6IGNvbXBhY3RBcnJheXMgZmxhZyBpcyBmYWxzZSxcbiAgICAgICAgICAvLyBAY29udGFpbmVyIGlzIEBzZXQgb3IgQGxpc3QgLCB2YWx1ZSBpcyBhbiBlbXB0eVxuICAgICAgICAgIC8vIGFycmF5LCBvciBrZXkgaXMgQGdyYXBoXG4gICAgICAgICAgY29uc3QgaXNBcnJheSA9ICghb3B0aW9ucy5jb21wYWN0QXJyYXlzIHx8XG4gICAgICAgICAgICBjb250YWluZXIuaW5jbHVkZXMoJ0BzZXQnKSB8fCBjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykgfHxcbiAgICAgICAgICAgIChfaXNBcnJheShjb21wYWN0ZWRJdGVtKSAmJiBjb21wYWN0ZWRJdGVtLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgIGV4cGFuZGVkUHJvcGVydHkgPT09ICdAbGlzdCcgfHwgZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BncmFwaCcpO1xuXG4gICAgICAgICAgLy8gYWRkIGNvbXBhY3QgdmFsdWVcbiAgICAgICAgICBfYWRkVmFsdWUoXG4gICAgICAgICAgICBuZXN0UmVzdWx0LCBpdGVtQWN0aXZlUHJvcGVydHksIGNvbXBhY3RlZEl0ZW0sXG4gICAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiBpc0FycmF5fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuXG4gIC8vIG9ubHkgcHJpbWl0aXZlcyByZW1haW4gd2hpY2ggYXJlIGFscmVhZHkgY29tcGFjdFxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ29tcGFjdHMgYW4gSVJJIG9yIGtleXdvcmQgaW50byBhIHRlcm0gb3IgcHJlZml4IGlmIGl0IGNhbiBiZS4gSWYgdGhlXG4gKiBJUkkgaGFzIGFuIGFzc29jaWF0ZWQgdmFsdWUgaXQgbWF5IGJlIHBhc3NlZC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gaXJpIHRoZSBJUkkgdG8gY29tcGFjdC5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gY2hlY2sgb3IgbnVsbC5cbiAqIEBwYXJhbSByZWxhdGl2ZVRvIG9wdGlvbnMgZm9yIGhvdyB0byBjb21wYWN0IElSSXM6XG4gKiAgICAgICAgICB2b2NhYjogdHJ1ZSB0byBzcGxpdCBhZnRlciBAdm9jYWIsIGZhbHNlIG5vdCB0by5cbiAqIEBwYXJhbSByZXZlcnNlIHRydWUgaWYgYSByZXZlcnNlIHByb3BlcnR5IGlzIGJlaW5nIGNvbXBhY3RlZCwgZmFsc2UgaWYgbm90LlxuICogQHBhcmFtIGJhc2UgdGhlIGFic29sdXRlIFVSTCB0byB1c2UgZm9yIGNvbXBhY3RpbmcgZG9jdW1lbnQtcmVsYXRpdmUgSVJJcy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb21wYWN0ZWQgdGVybSwgcHJlZml4LCBrZXl3b3JkIGFsaWFzLCBvciB0aGUgb3JpZ2luYWwgSVJJLlxuICovXG5hcGkuY29tcGFjdElyaSA9ICh7XG4gIGFjdGl2ZUN0eCxcbiAgaXJpLFxuICB2YWx1ZSA9IG51bGwsXG4gIHJlbGF0aXZlVG8gPSB7dm9jYWI6IGZhbHNlfSxcbiAgcmV2ZXJzZSA9IGZhbHNlLFxuICBiYXNlID0gbnVsbFxufSkgPT4ge1xuICAvLyBjYW4ndCBjb21wYWN0IG51bGxcbiAgaWYoaXJpID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGlyaTtcbiAgfVxuXG4gIC8vIGlmIGNvbnRleHQgaXMgZnJvbSBhIHByb3BlcnR5IHRlcm0gc2NvcGVkIGNvbnRleHQgY29tcG9zZWQgd2l0aCBhXG4gIC8vIHR5cGUtc2NvcGVkIGNvbnRleHQsIHRoZW4gdXNlIHRoZSBwcmV2aW91cyBjb250ZXh0IGluc3RlYWRcbiAgaWYoYWN0aXZlQ3R4LmlzUHJvcGVydHlUZXJtU2NvcGVkICYmIGFjdGl2ZUN0eC5wcmV2aW91c0NvbnRleHQpIHtcbiAgICBhY3RpdmVDdHggPSBhY3RpdmVDdHgucHJldmlvdXNDb250ZXh0O1xuICB9XG5cbiAgY29uc3QgaW52ZXJzZUN0eCA9IGFjdGl2ZUN0eC5nZXRJbnZlcnNlKCk7XG5cbiAgLy8gaWYgdGVybSBpcyBhIGtleXdvcmQsIGl0IG1heSBiZSBjb21wYWN0ZWQgdG8gYSBzaW1wbGUgYWxpYXNcbiAgaWYoX2lzS2V5d29yZChpcmkpICYmXG4gICAgaXJpIGluIGludmVyc2VDdHggJiZcbiAgICAnQG5vbmUnIGluIGludmVyc2VDdHhbaXJpXSAmJlxuICAgICdAdHlwZScgaW4gaW52ZXJzZUN0eFtpcmldWydAbm9uZSddICYmXG4gICAgJ0Bub25lJyBpbiBpbnZlcnNlQ3R4W2lyaV1bJ0Bub25lJ11bJ0B0eXBlJ10pIHtcbiAgICByZXR1cm4gaW52ZXJzZUN0eFtpcmldWydAbm9uZSddWydAdHlwZSddWydAbm9uZSddO1xuICB9XG5cbiAgLy8gdXNlIGludmVyc2UgY29udGV4dCB0byBwaWNrIGEgdGVybSBpZiBpcmkgaXMgcmVsYXRpdmUgdG8gdm9jYWJcbiAgaWYocmVsYXRpdmVUby52b2NhYiAmJiBpcmkgaW4gaW52ZXJzZUN0eCkge1xuICAgIGNvbnN0IGRlZmF1bHRMYW5ndWFnZSA9IGFjdGl2ZUN0eFsnQGxhbmd1YWdlJ10gfHwgJ0Bub25lJztcblxuICAgIC8vIHByZWZlciBAaW5kZXggaWYgYXZhaWxhYmxlIGluIHZhbHVlXG4gICAgY29uc3QgY29udGFpbmVycyA9IFtdO1xuICAgIGlmKF9pc09iamVjdCh2YWx1ZSkgJiYgJ0BpbmRleCcgaW4gdmFsdWUgJiYgISgnQGdyYXBoJyBpbiB2YWx1ZSkpIHtcbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGluZGV4JywgJ0BpbmRleEBzZXQnKTtcbiAgICB9XG5cbiAgICAvLyBpZiB2YWx1ZSBpcyBhIHByZXNlcnZlIG9iamVjdCwgdXNlIGl0cyB2YWx1ZVxuICAgIGlmKF9pc09iamVjdCh2YWx1ZSkgJiYgJ0BwcmVzZXJ2ZScgaW4gdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbJ0BwcmVzZXJ2ZSddWzBdO1xuICAgIH1cblxuICAgIC8vIHByZWZlciBtb3N0IHNwZWNpZmljIGNvbnRhaW5lciBpbmNsdWRpbmcgQGdyYXBoLCBwcmVmZXJpbmcgQHNldFxuICAgIC8vIHZhcmlhdGlvbnNcbiAgICBpZihfaXNHcmFwaCh2YWx1ZSkpIHtcbiAgICAgIC8vIGZhdm9yIGluZGV4bWFwIGlmIHRoZSBncmFwaCBpcyBpbmRleGVkXG4gICAgICBpZignQGluZGV4JyBpbiB2YWx1ZSkge1xuICAgICAgICBjb250YWluZXJzLnB1c2goXG4gICAgICAgICAgJ0BncmFwaEBpbmRleCcsICdAZ3JhcGhAaW5kZXhAc2V0JywgJ0BpbmRleCcsICdAaW5kZXhAc2V0Jyk7XG4gICAgICB9XG4gICAgICAvLyBmYXZvciBpZG1hcCBpZiB0aGUgZ3JhcGggaXMgaGFzIGFuIEBpZFxuICAgICAgaWYoJ0BpZCcgaW4gdmFsdWUpIHtcbiAgICAgICAgY29udGFpbmVycy5wdXNoKFxuICAgICAgICAgICdAZ3JhcGhAaWQnLCAnQGdyYXBoQGlkQHNldCcpO1xuICAgICAgfVxuICAgICAgY29udGFpbmVycy5wdXNoKCdAZ3JhcGgnLCAnQGdyYXBoQHNldCcsICdAc2V0Jyk7XG4gICAgICAvLyBhbGxvdyBpbmRleG1hcCBpZiB0aGUgZ3JhcGggaXMgbm90IGluZGV4ZWRcbiAgICAgIGlmKCEoJ0BpbmRleCcgaW4gdmFsdWUpKSB7XG4gICAgICAgIGNvbnRhaW5lcnMucHVzaChcbiAgICAgICAgICAnQGdyYXBoQGluZGV4JywgJ0BncmFwaEBpbmRleEBzZXQnLCAnQGluZGV4JywgJ0BpbmRleEBzZXQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGFsbG93IGlkbWFwIGlmIHRoZSBncmFwaCBkb2VzIG5vdCBoYXZlIGFuIEBpZFxuICAgICAgaWYoISgnQGlkJyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgY29udGFpbmVycy5wdXNoKCdAZ3JhcGhAaWQnLCAnQGdyYXBoQGlkQHNldCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihfaXNPYmplY3QodmFsdWUpICYmICFfaXNWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGlkJywgJ0BpZEBzZXQnLCAnQHR5cGUnLCAnQHNldEB0eXBlJyk7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdHMgZm9yIHRlcm0gc2VsZWN0aW9uIGJhc2VkIG9uIHR5cGUvbGFuZ3VhZ2VcbiAgICBsZXQgdHlwZU9yTGFuZ3VhZ2UgPSAnQGxhbmd1YWdlJztcbiAgICBsZXQgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9ICdAbnVsbCc7XG5cbiAgICBpZihyZXZlcnNlKSB7XG4gICAgICB0eXBlT3JMYW5ndWFnZSA9ICdAdHlwZSc7XG4gICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gJ0ByZXZlcnNlJztcbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQHNldCcpO1xuICAgIH0gZWxzZSBpZihfaXNMaXN0KHZhbHVlKSkge1xuICAgICAgLy8gY2hvb3NlIHRoZSBtb3N0IHNwZWNpZmljIHRlcm0gdGhhdCB3b3JrcyBmb3IgYWxsIGVsZW1lbnRzIGluIEBsaXN0XG4gICAgICAvLyBvbmx5IHNlbGVjdCBAbGlzdCBjb250YWluZXJzIGlmIEBpbmRleCBpcyBOT1QgaW4gdmFsdWVcbiAgICAgIGlmKCEoJ0BpbmRleCcgaW4gdmFsdWUpKSB7XG4gICAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGxpc3QnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpc3QgPSB2YWx1ZVsnQGxpc3QnXTtcbiAgICAgIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGFueSBlbXB0eSBsaXN0IGNhbiBiZSBtYXRjaGVkIGFnYWluc3QgYW55IHRlcm0gdGhhdCB1c2VzIHRoZVxuICAgICAgICAvLyBAbGlzdCBjb250YWluZXIgcmVnYXJkbGVzcyBvZiBAdHlwZSBvciBAbGFuZ3VhZ2VcbiAgICAgICAgdHlwZU9yTGFuZ3VhZ2UgPSAnQGFueSc7XG4gICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSAnQG5vbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbW1vbkxhbmd1YWdlID0gKGxpc3QubGVuZ3RoID09PSAwKSA/IGRlZmF1bHRMYW5ndWFnZSA6IG51bGw7XG4gICAgICAgIGxldCBjb21tb25UeXBlID0gbnVsbDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICBsZXQgaXRlbUxhbmd1YWdlID0gJ0Bub25lJztcbiAgICAgICAgICBsZXQgaXRlbVR5cGUgPSAnQG5vbmUnO1xuICAgICAgICAgIGlmKF9pc1ZhbHVlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZignQGRpcmVjdGlvbicgaW4gaXRlbSkge1xuICAgICAgICAgICAgICBjb25zdCBsYW5nID0gKGl0ZW1bJ0BsYW5ndWFnZSddIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBjb25zdCBkaXIgPSBpdGVtWydAZGlyZWN0aW9uJ107XG4gICAgICAgICAgICAgIGl0ZW1MYW5ndWFnZSA9IGAke2xhbmd9XyR7ZGlyfWA7XG4gICAgICAgICAgICB9IGVsc2UgaWYoJ0BsYW5ndWFnZScgaW4gaXRlbSkge1xuICAgICAgICAgICAgICBpdGVtTGFuZ3VhZ2UgPSBpdGVtWydAbGFuZ3VhZ2UnXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCdAdHlwZScgaW4gaXRlbSkge1xuICAgICAgICAgICAgICBpdGVtVHlwZSA9IGl0ZW1bJ0B0eXBlJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBwbGFpbiBsaXRlcmFsXG4gICAgICAgICAgICAgIGl0ZW1MYW5ndWFnZSA9ICdAbnVsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW1UeXBlID0gJ0BpZCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGNvbW1vbkxhbmd1YWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb21tb25MYW5ndWFnZSA9IGl0ZW1MYW5ndWFnZTtcbiAgICAgICAgICB9IGVsc2UgaWYoaXRlbUxhbmd1YWdlICE9PSBjb21tb25MYW5ndWFnZSAmJiBfaXNWYWx1ZShpdGVtKSkge1xuICAgICAgICAgICAgY29tbW9uTGFuZ3VhZ2UgPSAnQG5vbmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihjb21tb25UeXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb21tb25UeXBlID0gaXRlbVR5cGU7XG4gICAgICAgICAgfSBlbHNlIGlmKGl0ZW1UeXBlICE9PSBjb21tb25UeXBlKSB7XG4gICAgICAgICAgICBjb21tb25UeXBlID0gJ0Bub25lJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdGhlcmUgYXJlIGRpZmZlcmVudCBsYW5ndWFnZXMgYW5kIHR5cGVzIGluIHRoZSBsaXN0LCBzbyBjaG9vc2VcbiAgICAgICAgICAvLyB0aGUgbW9zdCBnZW5lcmljIHRlcm0sIG5vIG5lZWQgdG8ga2VlcCBpdGVyYXRpbmcgdGhlIGxpc3RcbiAgICAgICAgICBpZihjb21tb25MYW5ndWFnZSA9PT0gJ0Bub25lJyAmJiBjb21tb25UeXBlID09PSAnQG5vbmUnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29tbW9uTGFuZ3VhZ2UgPSBjb21tb25MYW5ndWFnZSB8fCAnQG5vbmUnO1xuICAgICAgICBjb21tb25UeXBlID0gY29tbW9uVHlwZSB8fCAnQG5vbmUnO1xuICAgICAgICBpZihjb21tb25UeXBlICE9PSAnQG5vbmUnKSB7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2UgPSAnQHR5cGUnO1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSBjb21tb25UeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSBjb21tb25MYW5ndWFnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihfaXNWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYoJ0BsYW5ndWFnZScgaW4gdmFsdWUgJiYgISgnQGluZGV4JyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgICBjb250YWluZXJzLnB1c2goJ0BsYW5ndWFnZScsICdAbGFuZ3VhZ2VAc2V0Jyk7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9IHZhbHVlWydAbGFuZ3VhZ2UnXTtcbiAgICAgICAgICBjb25zdCBkaXIgPSB2YWx1ZVsnQGRpcmVjdGlvbiddO1xuICAgICAgICAgIGlmKGRpcikge1xuICAgICAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9IGAke3R5cGVPckxhbmd1YWdlVmFsdWV9XyR7ZGlyfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoJ0BkaXJlY3Rpb24nIGluIHZhbHVlICYmICEoJ0BpbmRleCcgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9IGBfJHt2YWx1ZVsnQGRpcmVjdGlvbiddfWA7XG4gICAgICAgIH0gZWxzZSBpZignQHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgICAgdHlwZU9yTGFuZ3VhZ2UgPSAnQHR5cGUnO1xuICAgICAgICAgIHR5cGVPckxhbmd1YWdlVmFsdWUgPSB2YWx1ZVsnQHR5cGUnXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZU9yTGFuZ3VhZ2UgPSAnQHR5cGUnO1xuICAgICAgICB0eXBlT3JMYW5ndWFnZVZhbHVlID0gJ0BpZCc7XG4gICAgICB9XG4gICAgICBjb250YWluZXJzLnB1c2goJ0BzZXQnKTtcbiAgICB9XG5cbiAgICAvLyBkbyB0ZXJtIHNlbGVjdGlvblxuICAgIGNvbnRhaW5lcnMucHVzaCgnQG5vbmUnKTtcblxuICAgIC8vIGFuIGluZGV4IG1hcCBjYW4gYmUgdXNlZCB0byBpbmRleCB2YWx1ZXMgdXNpbmcgQG5vbmUsIHNvIGFkZCBhcyBhIGxvd1xuICAgIC8vIHByaW9yaXR5XG4gICAgaWYoX2lzT2JqZWN0KHZhbHVlKSAmJiAhKCdAaW5kZXgnIGluIHZhbHVlKSkge1xuICAgICAgLy8gYWxsb3cgaW5kZXhpbmcgZXZlbiBpZiBubyBAaW5kZXggcHJlc2VudFxuICAgICAgY29udGFpbmVycy5wdXNoKCdAaW5kZXgnLCAnQGluZGV4QHNldCcpO1xuICAgIH1cblxuICAgIC8vIHZhbHVlcyB3aXRob3V0IHR5cGUgb3IgbGFuZ3VhZ2UgY2FuIHVzZSBAbGFuZ3VhZ2UgbWFwXG4gICAgaWYoX2lzVmFsdWUodmFsdWUpICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGFsbG93IGluZGV4aW5nIGV2ZW4gaWYgbm8gQGluZGV4IHByZXNlbnRcbiAgICAgIGNvbnRhaW5lcnMucHVzaCgnQGxhbmd1YWdlJywgJ0BsYW5ndWFnZUBzZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXJtID0gX3NlbGVjdFRlcm0oXG4gICAgICBhY3RpdmVDdHgsIGlyaSwgdmFsdWUsIGNvbnRhaW5lcnMsIHR5cGVPckxhbmd1YWdlLCB0eXBlT3JMYW5ndWFnZVZhbHVlKTtcbiAgICBpZih0ZXJtICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGVybTtcbiAgICB9XG4gIH1cblxuICAvLyBubyB0ZXJtIG1hdGNoLCB1c2UgQHZvY2FiIGlmIGF2YWlsYWJsZVxuICBpZihyZWxhdGl2ZVRvLnZvY2FiKSB7XG4gICAgaWYoJ0B2b2NhYicgaW4gYWN0aXZlQ3R4KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgaWYgdm9jYWIgaXMgYSBwcmVmaXggb2YgdGhlIGlyaVxuICAgICAgY29uc3Qgdm9jYWIgPSBhY3RpdmVDdHhbJ0B2b2NhYiddO1xuICAgICAgaWYoaXJpLmluZGV4T2Yodm9jYWIpID09PSAwICYmIGlyaSAhPT0gdm9jYWIpIHtcbiAgICAgICAgLy8gdXNlIHN1ZmZpeCBhcyByZWxhdGl2ZSBpcmkgaWYgaXQgaXMgbm90IGEgdGVybSBpbiB0aGUgYWN0aXZlIGNvbnRleHRcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gaXJpLnN1YnN0cih2b2NhYi5sZW5ndGgpO1xuICAgICAgICBpZighYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhzdWZmaXgpKSB7XG4gICAgICAgICAgcmV0dXJuIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vIHRlcm0gb3IgQHZvY2FiIG1hdGNoLCBjaGVjayBmb3IgcG9zc2libGUgQ1VSSUVzXG4gIGxldCBjaG9pY2UgPSBudWxsO1xuICAvLyBUT0RPOiBtYWtlIEZhc3RDdXJpZU1hcCBhIGNsYXNzIHdpdGggYSBtZXRob2QgdG8gZG8gdGhpcyBsb29rdXBcbiAgY29uc3QgcGFydGlhbE1hdGNoZXMgPSBbXTtcbiAgbGV0IGlyaU1hcCA9IGFjdGl2ZUN0eC5mYXN0Q3VyaWVNYXA7XG4gIC8vIGNoZWNrIGZvciBwYXJ0aWFsIG1hdGNoZXMgb2YgYWdhaW5zdCBgaXJpYCwgd2hpY2ggbWVhbnMgbG9vayB1bnRpbFxuICAvLyBpcmkubGVuZ3RoIC0gMSwgbm90IGZ1bGwgbGVuZ3RoXG4gIGNvbnN0IG1heFBhcnRpYWxMZW5ndGggPSBpcmkubGVuZ3RoIC0gMTtcbiAgZm9yKGxldCBpID0gMDsgaSA8IG1heFBhcnRpYWxMZW5ndGggJiYgaXJpW2ldIGluIGlyaU1hcDsgKytpKSB7XG4gICAgaXJpTWFwID0gaXJpTWFwW2lyaVtpXV07XG4gICAgaWYoJycgaW4gaXJpTWFwKSB7XG4gICAgICBwYXJ0aWFsTWF0Y2hlcy5wdXNoKGlyaU1hcFsnJ11bMF0pO1xuICAgIH1cbiAgfVxuICAvLyBjaGVjayBwYXJ0aWFsIG1hdGNoZXMgaW4gcmV2ZXJzZSBvcmRlciB0byBwcmVmZXIgbG9uZ2VzdCBvbmVzIGZpcnN0XG4gIGZvcihsZXQgaSA9IHBhcnRpYWxNYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgY29uc3QgZW50cnkgPSBwYXJ0aWFsTWF0Y2hlc1tpXTtcbiAgICBjb25zdCB0ZXJtcyA9IGVudHJ5LnRlcm1zO1xuICAgIGZvcihjb25zdCB0ZXJtIG9mIHRlcm1zKSB7XG4gICAgICAvLyBhIENVUklFIGlzIHVzYWJsZSBpZjpcbiAgICAgIC8vIDEuIGl0IGhhcyBubyBtYXBwaW5nLCBPUlxuICAgICAgLy8gMi4gdmFsdWUgaXMgbnVsbCwgd2hpY2ggbWVhbnMgd2UncmUgbm90IGNvbXBhY3RpbmcgYW4gQHZhbHVlLCBBTkRcbiAgICAgIC8vICAgdGhlIG1hcHBpbmcgbWF0Y2hlcyB0aGUgSVJJXG4gICAgICBjb25zdCBjdXJpZSA9IHRlcm0gKyAnOicgKyBpcmkuc3Vic3RyKGVudHJ5LmlyaS5sZW5ndGgpO1xuICAgICAgY29uc3QgaXNVc2FibGVDdXJpZSA9IChhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KHRlcm0pLl9wcmVmaXggJiZcbiAgICAgICAgKCFhY3RpdmVDdHgubWFwcGluZ3MuaGFzKGN1cmllKSB8fFxuICAgICAgICAodmFsdWUgPT09IG51bGwgJiYgYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChjdXJpZSlbJ0BpZCddID09PSBpcmkpKSk7XG5cbiAgICAgIC8vIHNlbGVjdCBjdXJpZSBpZiBpdCBpcyBzaG9ydGVyIG9yIHRoZSBzYW1lIGxlbmd0aCBidXQgbGV4aWNvZ3JhcGhpY2FsbHlcbiAgICAgIC8vIGxlc3MgdGhhbiB0aGUgY3VycmVudCBjaG9pY2VcbiAgICAgIGlmKGlzVXNhYmxlQ3VyaWUgJiYgKGNob2ljZSA9PT0gbnVsbCB8fFxuICAgICAgICBfY29tcGFyZVNob3J0ZXN0TGVhc3QoY3VyaWUsIGNob2ljZSkgPCAwKSkge1xuICAgICAgICBjaG9pY2UgPSBjdXJpZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gY2hvc2VuIGN1cmllXG4gIGlmKGNob2ljZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjaG9pY2U7XG4gIH1cblxuICAvLyBJZiBpcmkgY291bGQgYmUgY29uZnVzZWQgd2l0aCBhIGNvbXBhY3QgSVJJIHVzaW5nIGEgdGVybSBpbiB0aGlzIGNvbnRleHQsXG4gIC8vIHNpZ25hbCBhbiBlcnJvclxuICBmb3IoY29uc3QgW3Rlcm0sIHRkXSBvZiBhY3RpdmVDdHgubWFwcGluZ3MpIHtcbiAgICBpZih0ZCAmJiB0ZC5fcHJlZml4ICYmIGlyaS5zdGFydHNXaXRoKHRlcm0gKyAnOicpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgIGBBYnNvbHV0ZSBJUkkgXCIke2lyaX1cIiBjb25mdXNlZCB3aXRoIHByZWZpeCBcIiR7dGVybX1cIi5gLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdJUkkgY29uZnVzZWQgd2l0aCBwcmVmaXgnLCBjb250ZXh0OiBhY3RpdmVDdHh9KTtcbiAgICB9XG4gIH1cblxuICAvLyBjb21wYWN0IElSSSByZWxhdGl2ZSB0byBiYXNlXG4gIGlmKCFyZWxhdGl2ZVRvLnZvY2FiKSB7XG4gICAgaWYoJ0BiYXNlJyBpbiBhY3RpdmVDdHgpIHtcbiAgICAgIGlmKCFhY3RpdmVDdHhbJ0BiYXNlJ10pIHtcbiAgICAgICAgLy8gVGhlIE5vbmUgY2FzZSBwcmVzZXJ2ZXMgcnZhbCBhcyBwb3RlbnRpYWxseSByZWxhdGl2ZVxuICAgICAgICByZXR1cm4gaXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lyaSA9IF9yZW1vdmVCYXNlKF9wcmVwZW5kQmFzZShiYXNlLCBhY3RpdmVDdHhbJ0BiYXNlJ10pLCBpcmkpO1xuICAgICAgICByZXR1cm4gUkVHRVhfS0VZV09SRC50ZXN0KF9pcmkpID8gYC4vJHtfaXJpfWAgOiBfaXJpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3JlbW92ZUJhc2UoYmFzZSwgaXJpKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gSVJJIGFzIGlzXG4gIHJldHVybiBpcmk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIHZhbHVlIGNvbXBhY3Rpb24gb24gYW4gb2JqZWN0IHdpdGggJ0B2YWx1ZScgb3IgJ0BpZCcgYXMgdGhlIG9ubHlcbiAqIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBhY3RpdmUgcHJvcGVydHkgdGhhdCBwb2ludHMgdG8gdGhlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjb21wYWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBjb21wYWN0aW9uIHJlc3VsdC5cbiAqL1xuYXBpLmNvbXBhY3RWYWx1ZSA9ICh7YWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgdmFsdWUsIG9wdGlvbnN9KSA9PiB7XG4gIC8vIHZhbHVlIGlzIGEgQHZhbHVlXG4gIGlmKF9pc1ZhbHVlKHZhbHVlKSkge1xuICAgIC8vIGdldCBjb250ZXh0IHJ1bGVzXG4gICAgY29uc3QgdHlwZSA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0B0eXBlJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAbGFuZ3VhZ2UnKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAZGlyZWN0aW9uJyk7XG4gICAgY29uc3QgY29udGFpbmVyID1cbiAgICAgIF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwgJ0Bjb250YWluZXInKSB8fCBbXTtcblxuICAgIC8vIHdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBoYXMgYW4gQGluZGV4IHRoYXQgbXVzdCBiZSBwcmVzZXJ2ZWRcbiAgICBjb25zdCBwcmVzZXJ2ZUluZGV4ID0gJ0BpbmRleCcgaW4gdmFsdWUgJiYgIWNvbnRhaW5lci5pbmNsdWRlcygnQGluZGV4Jyk7XG5cbiAgICAvLyBpZiB0aGVyZSdzIG5vIEBpbmRleCB0byBwcmVzZXJ2ZSAuLi5cbiAgICBpZighcHJlc2VydmVJbmRleCAmJiB0eXBlICE9PSAnQG5vbmUnKSB7XG4gICAgICAvLyBtYXRjaGluZyBAdHlwZSBvciBAbGFuZ3VhZ2Ugc3BlY2lmaWVkIGluIGNvbnRleHQsIGNvbXBhY3QgdmFsdWVcbiAgICAgIGlmKHZhbHVlWydAdHlwZSddID09PSB0eXBlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVsnQHZhbHVlJ107XG4gICAgICB9XG4gICAgICBpZignQGxhbmd1YWdlJyBpbiB2YWx1ZSAmJiB2YWx1ZVsnQGxhbmd1YWdlJ10gPT09IGxhbmd1YWdlICYmXG4gICAgICAgICAnQGRpcmVjdGlvbicgaW4gdmFsdWUgJiYgdmFsdWVbJ0BkaXJlY3Rpb24nXSA9PT0gZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVsnQHZhbHVlJ107XG4gICAgICB9XG4gICAgICBpZignQGxhbmd1YWdlJyBpbiB2YWx1ZSAmJiB2YWx1ZVsnQGxhbmd1YWdlJ10gPT09IGxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVsnQHZhbHVlJ107XG4gICAgICB9XG4gICAgICBpZignQGRpcmVjdGlvbicgaW4gdmFsdWUgJiYgdmFsdWVbJ0BkaXJlY3Rpb24nXSA9PT0gZGlyZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVsnQHZhbHVlJ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGp1c3QgdGhlIHZhbHVlIG9mIEB2YWx1ZSBpZiBhbGwgYXJlIHRydWU6XG4gICAgLy8gMS4gQHZhbHVlIGlzIHRoZSBvbmx5IGtleSBvciBAaW5kZXggaXNuJ3QgYmVpbmcgcHJlc2VydmVkXG4gICAgLy8gMi4gdGhlcmUgaXMgbm8gZGVmYXVsdCBsYW5ndWFnZSBvciBAdmFsdWUgaXMgbm90IGEgc3RyaW5nIG9yXG4gICAgLy8gICB0aGUga2V5IGhhcyBhIG1hcHBpbmcgd2l0aCBhIG51bGwgQGxhbmd1YWdlXG4gICAgY29uc3Qga2V5Q291bnQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIGNvbnN0IGlzVmFsdWVPbmx5S2V5ID0gKGtleUNvdW50ID09PSAxIHx8XG4gICAgICAoa2V5Q291bnQgPT09IDIgJiYgJ0BpbmRleCcgaW4gdmFsdWUgJiYgIXByZXNlcnZlSW5kZXgpKTtcbiAgICBjb25zdCBoYXNEZWZhdWx0TGFuZ3VhZ2UgPSAoJ0BsYW5ndWFnZScgaW4gYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBpc1ZhbHVlU3RyaW5nID0gX2lzU3RyaW5nKHZhbHVlWydAdmFsdWUnXSk7XG4gICAgY29uc3QgaGFzTnVsbE1hcHBpbmcgPSAoYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhhY3RpdmVQcm9wZXJ0eSkgJiZcbiAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQoYWN0aXZlUHJvcGVydHkpWydAbGFuZ3VhZ2UnXSA9PT0gbnVsbCk7XG4gICAgaWYoaXNWYWx1ZU9ubHlLZXkgJiZcbiAgICAgIHR5cGUgIT09ICdAbm9uZScgJiZcbiAgICAgICghaGFzRGVmYXVsdExhbmd1YWdlIHx8ICFpc1ZhbHVlU3RyaW5nIHx8IGhhc051bGxNYXBwaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHVlWydAdmFsdWUnXTtcbiAgICB9XG5cbiAgICBjb25zdCBydmFsID0ge307XG5cbiAgICAvLyBwcmVzZXJ2ZSBAaW5kZXhcbiAgICBpZihwcmVzZXJ2ZUluZGV4KSB7XG4gICAgICBydmFsW2FwaS5jb21wYWN0SXJpKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBpcmk6ICdAaW5kZXgnLFxuICAgICAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHRydWV9XG4gICAgICB9KV0gPSB2YWx1ZVsnQGluZGV4J107XG4gICAgfVxuXG4gICAgaWYoJ0B0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgLy8gY29tcGFjdCBAdHlwZSBJUklcbiAgICAgIHJ2YWxbYXBpLmNvbXBhY3RJcmkoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGlyaTogJ0B0eXBlJyxcbiAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgfSldID0gYXBpLmNvbXBhY3RJcmkoXG4gICAgICAgIHthY3RpdmVDdHgsIGlyaTogdmFsdWVbJ0B0eXBlJ10sIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcbiAgICB9IGVsc2UgaWYoJ0BsYW5ndWFnZScgaW4gdmFsdWUpIHtcbiAgICAgIC8vIGFsaWFzIEBsYW5ndWFnZVxuICAgICAgcnZhbFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgaXJpOiAnQGxhbmd1YWdlJyxcbiAgICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgICAgfSldID0gdmFsdWVbJ0BsYW5ndWFnZSddO1xuICAgIH1cblxuICAgIGlmKCdAZGlyZWN0aW9uJyBpbiB2YWx1ZSkge1xuICAgICAgLy8gYWxpYXMgQGRpcmVjdGlvblxuICAgICAgcnZhbFthcGkuY29tcGFjdElyaSh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgaXJpOiAnQGRpcmVjdGlvbicsXG4gICAgICAgIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX1cbiAgICAgIH0pXSA9IHZhbHVlWydAZGlyZWN0aW9uJ107XG4gICAgfVxuXG4gICAgLy8gYWxpYXMgQHZhbHVlXG4gICAgcnZhbFthcGkuY29tcGFjdElyaSh7XG4gICAgICBhY3RpdmVDdHgsXG4gICAgICBpcmk6ICdAdmFsdWUnLFxuICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgIH0pXSA9IHZhbHVlWydAdmFsdWUnXTtcblxuICAgIHJldHVybiBydmFsO1xuICB9XG5cbiAgLy8gdmFsdWUgaXMgYSBzdWJqZWN0IHJlZmVyZW5jZVxuICBjb25zdCBleHBhbmRlZFByb3BlcnR5ID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB7dm9jYWI6IHRydWV9LFxuICAgIG9wdGlvbnMpO1xuICBjb25zdCB0eXBlID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQHR5cGUnKTtcbiAgY29uc3QgY29tcGFjdGVkID0gYXBpLmNvbXBhY3RJcmkoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBpcmk6IHZhbHVlWydAaWQnXSxcbiAgICByZWxhdGl2ZVRvOiB7dm9jYWI6IHR5cGUgPT09ICdAdm9jYWInfSxcbiAgICBiYXNlOiBvcHRpb25zLmJhc2V9KTtcblxuICAvLyBjb21wYWN0IHRvIHNjYWxhclxuICBpZih0eXBlID09PSAnQGlkJyB8fCB0eXBlID09PSAnQHZvY2FiJyB8fCBleHBhbmRlZFByb3BlcnR5ID09PSAnQGdyYXBoJykge1xuICAgIHJldHVybiBjb21wYWN0ZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFthcGkuY29tcGFjdElyaSh7XG4gICAgICBhY3RpdmVDdHgsXG4gICAgICBpcmk6ICdAaWQnLFxuICAgICAgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgIH0pXTogY29tcGFjdGVkXG4gIH07XG59O1xuXG4vKipcbiAqIFBpY2tzIHRoZSBwcmVmZXJyZWQgY29tcGFjdGlvbiB0ZXJtIGZyb20gdGhlIGdpdmVuIGludmVyc2UgY29udGV4dCBlbnRyeS5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBpcmkgdGhlIElSSSB0byBwaWNrIHRoZSB0ZXJtIGZvci5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcGljayB0aGUgdGVybSBmb3IuXG4gKiBAcGFyYW0gY29udGFpbmVycyB0aGUgcHJlZmVycmVkIGNvbnRhaW5lcnMuXG4gKiBAcGFyYW0gdHlwZU9yTGFuZ3VhZ2UgZWl0aGVyICdAdHlwZScgb3IgJ0BsYW5ndWFnZScuXG4gKiBAcGFyYW0gdHlwZU9yTGFuZ3VhZ2VWYWx1ZSB0aGUgcHJlZmVycmVkIHZhbHVlIGZvciAnQHR5cGUnIG9yICdAbGFuZ3VhZ2UnLlxuICpcbiAqIEByZXR1cm4gdGhlIHByZWZlcnJlZCB0ZXJtLlxuICovXG5mdW5jdGlvbiBfc2VsZWN0VGVybShcbiAgYWN0aXZlQ3R4LCBpcmksIHZhbHVlLCBjb250YWluZXJzLCB0eXBlT3JMYW5ndWFnZSwgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSkge1xuICBpZih0eXBlT3JMYW5ndWFnZVZhbHVlID09PSBudWxsKSB7XG4gICAgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9ICdAbnVsbCc7XG4gIH1cblxuICAvLyBwcmVmZXJlbmNlcyBmb3IgdGhlIHZhbHVlIG9mIEB0eXBlIG9yIEBsYW5ndWFnZVxuICBjb25zdCBwcmVmcyA9IFtdO1xuXG4gIC8vIGRldGVybWluZSBwcmVmcyBmb3IgQGlkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IHZhbHVlIGNvbXBhY3RzIHRvIGEgdGVybVxuICBpZigodHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9PT0gJ0BpZCcgfHwgdHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9PT0gJ0ByZXZlcnNlJykgJiZcbiAgICBfaXNPYmplY3QodmFsdWUpICYmICdAaWQnIGluIHZhbHVlKSB7XG4gICAgLy8gcHJlZmVyIEByZXZlcnNlIGZpcnN0XG4gICAgaWYodHlwZU9yTGFuZ3VhZ2VWYWx1ZSA9PT0gJ0ByZXZlcnNlJykge1xuICAgICAgcHJlZnMucHVzaCgnQHJldmVyc2UnKTtcbiAgICB9XG4gICAgLy8gdHJ5IHRvIGNvbXBhY3QgdmFsdWUgdG8gYSB0ZXJtXG4gICAgY29uc3QgdGVybSA9IGFwaS5jb21wYWN0SXJpKFxuICAgICAge2FjdGl2ZUN0eCwgaXJpOiB2YWx1ZVsnQGlkJ10sIHJlbGF0aXZlVG86IHt2b2NhYjogdHJ1ZX19KTtcbiAgICBpZihhY3RpdmVDdHgubWFwcGluZ3MuaGFzKHRlcm0pICYmXG4gICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KHRlcm0pICYmXG4gICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KHRlcm0pWydAaWQnXSA9PT0gdmFsdWVbJ0BpZCddKSB7XG4gICAgICAvLyBwcmVmZXIgQHZvY2FiXG4gICAgICBwcmVmcy5wdXNoLmFwcGx5KHByZWZzLCBbJ0B2b2NhYicsICdAaWQnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHByZWZlciBAaWRcbiAgICAgIHByZWZzLnB1c2guYXBwbHkocHJlZnMsIFsnQGlkJywgJ0B2b2NhYiddKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJlZnMucHVzaCh0eXBlT3JMYW5ndWFnZVZhbHVlKTtcblxuICAgIC8vIGNvbnNpZGVyIGRpcmVjdGlvbiBvbmx5XG4gICAgY29uc3QgbGFuZ0RpciA9IHByZWZzLmZpbmQoZWwgPT4gZWwuaW5jbHVkZXMoJ18nKSk7XG4gICAgaWYobGFuZ0Rpcikge1xuICAgICAgLy8gY29uc2lkZXIgX2RpciBwb3J0aW9uXG4gICAgICBwcmVmcy5wdXNoKGxhbmdEaXIucmVwbGFjZSgvXlteX10rXy8sICdfJykpO1xuICAgIH1cbiAgfVxuICBwcmVmcy5wdXNoKCdAbm9uZScpO1xuXG4gIGNvbnN0IGNvbnRhaW5lck1hcCA9IGFjdGl2ZUN0eC5pbnZlcnNlW2lyaV07XG4gIGZvcihjb25zdCBjb250YWluZXIgb2YgY29udGFpbmVycykge1xuICAgIC8vIGlmIGNvbnRhaW5lciBub3QgYXZhaWxhYmxlIGluIHRoZSBtYXAsIGNvbnRpbnVlXG4gICAgaWYoIShjb250YWluZXIgaW4gY29udGFpbmVyTWFwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZU9yTGFuZ3VhZ2VWYWx1ZU1hcCA9IGNvbnRhaW5lck1hcFtjb250YWluZXJdW3R5cGVPckxhbmd1YWdlXTtcbiAgICBmb3IoY29uc3QgcHJlZiBvZiBwcmVmcykge1xuICAgICAgLy8gaWYgdHlwZS9sYW5ndWFnZSBvcHRpb24gbm90IGF2YWlsYWJsZSBpbiB0aGUgbWFwLCBjb250aW51ZVxuICAgICAgaWYoIShwcmVmIGluIHR5cGVPckxhbmd1YWdlVmFsdWVNYXApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWxlY3QgdGVybVxuICAgICAgcmV0dXJuIHR5cGVPckxhbmd1YWdlVmFsdWVNYXBbcHJlZl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhlIHZhbHVlIG9mIGBAbmVzdGAgaW4gdGhlIHRlcm0gZGVmaW5pdGlvbiBtdXN0IGVpdGhlciBiZSBgQG5lc3RgLCBvciBhIHRlcm1cbiAqIHdoaWNoIHJlc29sdmVzIHRvIGBAbmVzdGAuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gbmVzdFByb3BlcnR5IGEgdGVybSBpbiB0aGUgYWN0aXZlIGNvbnRleHQgb3IgYEBuZXN0YC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBwcm9jZXNzaW5nIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIF9jaGVja05lc3RQcm9wZXJ0eShhY3RpdmVDdHgsIG5lc3RQcm9wZXJ0eSwgb3B0aW9ucykge1xuICBpZihfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgbmVzdFByb3BlcnR5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKSAhPT0gJ0BuZXN0Jykge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdKU09OLUxEIGNvbXBhY3QgZXJyb3I7IG5lc3RlZCBwcm9wZXJ0eSBtdXN0IGhhdmUgYW4gQG5lc3QgdmFsdWUgJyArXG4gICAgICAncmVzb2x2aW5nIHRvIEBuZXN0LicsXG4gICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBuZXN0IHZhbHVlJ30pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/compact.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/constants.js":
/*!**********************************************!*\
  !*** ./node_modules/jsonld/lib/constants.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst XSD = 'http://www.w3.org/2001/XMLSchema#';\n\nmodule.exports = {\n  // TODO: Deprecated and will be removed later. Use LINK_HEADER_CONTEXT.\n  LINK_HEADER_REL: 'http://www.w3.org/ns/json-ld#context',\n\n  LINK_HEADER_CONTEXT: 'http://www.w3.org/ns/json-ld#context',\n\n  RDF,\n  RDF_LIST: RDF + 'List',\n  RDF_FIRST: RDF + 'first',\n  RDF_REST: RDF + 'rest',\n  RDF_NIL: RDF + 'nil',\n  RDF_TYPE: RDF + 'type',\n  RDF_PLAIN_LITERAL: RDF + 'PlainLiteral',\n  RDF_XML_LITERAL: RDF + 'XMLLiteral',\n  RDF_JSON_LITERAL: RDF + 'JSON',\n  RDF_OBJECT: RDF + 'object',\n  RDF_LANGSTRING: RDF + 'langString',\n\n  XSD,\n  XSD_BOOLEAN: XSD + 'boolean',\n  XSD_DOUBLE: XSD + 'double',\n  XSD_INTEGER: XSD + 'integer',\n  XSD_STRING: XSD + 'string',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9jb25zdGFudHMuanM/YzBiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgUkRGID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnO1xuY29uc3QgWFNEID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hIyc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBUT0RPOiBEZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgbGF0ZXIuIFVzZSBMSU5LX0hFQURFUl9DT05URVhULlxuICBMSU5LX0hFQURFUl9SRUw6ICdodHRwOi8vd3d3LnczLm9yZy9ucy9qc29uLWxkI2NvbnRleHQnLFxuXG4gIExJTktfSEVBREVSX0NPTlRFWFQ6ICdodHRwOi8vd3d3LnczLm9yZy9ucy9qc29uLWxkI2NvbnRleHQnLFxuXG4gIFJERixcbiAgUkRGX0xJU1Q6IFJERiArICdMaXN0JyxcbiAgUkRGX0ZJUlNUOiBSREYgKyAnZmlyc3QnLFxuICBSREZfUkVTVDogUkRGICsgJ3Jlc3QnLFxuICBSREZfTklMOiBSREYgKyAnbmlsJyxcbiAgUkRGX1RZUEU6IFJERiArICd0eXBlJyxcbiAgUkRGX1BMQUlOX0xJVEVSQUw6IFJERiArICdQbGFpbkxpdGVyYWwnLFxuICBSREZfWE1MX0xJVEVSQUw6IFJERiArICdYTUxMaXRlcmFsJyxcbiAgUkRGX0pTT05fTElURVJBTDogUkRGICsgJ0pTT04nLFxuICBSREZfT0JKRUNUOiBSREYgKyAnb2JqZWN0JyxcbiAgUkRGX0xBTkdTVFJJTkc6IFJERiArICdsYW5nU3RyaW5nJyxcblxuICBYU0QsXG4gIFhTRF9CT09MRUFOOiBYU0QgKyAnYm9vbGVhbicsXG4gIFhTRF9ET1VCTEU6IFhTRCArICdkb3VibGUnLFxuICBYU0RfSU5URUdFUjogWFNEICsgJ2ludGVnZXInLFxuICBYU0RfU1RSSU5HOiBYU0QgKyAnc3RyaW5nJyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/context.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/context.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri,\n  isRelative: _isRelativeIri,\n  prependBase\n} = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/jsonld/lib/events.js\");\n\nconst {\n  REGEX_BCP47,\n  REGEX_KEYWORD,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\n\nconst INITIAL_CONTEXT_CACHE = new Map();\nconst INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\napi.process = async ({\n  activeCtx, localCtx, options,\n  propagate = true,\n  overrideProtected = false,\n  cycles = new Set()\n}) => {\n  // normalize local context to an array of @context objects\n  if(_isObject(localCtx) && '@context' in localCtx &&\n    _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n  const ctxs = _asArray(localCtx);\n\n  // no contexts in array, return current active context w/o changes\n  if(ctxs.length === 0) {\n    return activeCtx;\n  }\n\n  // event handler for capturing events to replay when using a cached context\n  const events = [];\n  const eventCaptureHandler = [\n    ({event, next}) => {\n      events.push(event);\n      next();\n    }\n  ];\n  // chain to original handler\n  if(options.eventHandler) {\n    eventCaptureHandler.push(options.eventHandler);\n  }\n  // store original options to use when replaying events\n  const originalOptions = options;\n  // shallow clone options with event capture handler\n  options = {...options, eventHandler: eventCaptureHandler};\n\n  // resolve contexts\n  const resolved = await options.contextResolver.resolve({\n    activeCtx,\n    context: localCtx,\n    documentLoader: options.documentLoader,\n    base: options.base\n  });\n\n  // override propagate if first resolved context has `@propagate`\n  if(_isObject(resolved[0].document) &&\n    typeof resolved[0].document['@propagate'] === 'boolean') {\n    // retrieve early, error checking done later\n    propagate = resolved[0].document['@propagate'];\n  }\n\n  // process each context in order, update active context\n  // on each iteration to ensure proper caching\n  let rval = activeCtx;\n\n  // track the previous context\n  // if not propagating, make sure rval has a previous context\n  if(!propagate && !rval.previousContext) {\n    // clone `rval` context before updating\n    rval = rval.clone();\n    rval.previousContext = activeCtx;\n  }\n\n  for(const resolvedContext of resolved) {\n    let {document: ctx} = resolvedContext;\n\n    // update active context to one computed from last iteration\n    activeCtx = rval;\n\n    // reset to initial context\n    if(ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not allowing overrides (e.g. processing a property term scoped context)\n      if(!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {\n        throw new JsonLdError(\n          'Tried to nullify a context with protected terms outside of ' +\n          'a term definition.',\n          'jsonld.SyntaxError',\n          {code: 'invalid context nullification'});\n      }\n      rval = activeCtx = api.getInitialContext(options).clone();\n      continue;\n    }\n\n    // get processed context from cache if available\n    const processed = resolvedContext.getProcessed(activeCtx);\n    if(processed) {\n      if(originalOptions.eventHandler) {\n        // replay events with original non-capturing options\n        for(const event of processed.events) {\n          _handleEvent({event, options: originalOptions});\n        }\n      }\n\n      rval = activeCtx = processed.context;\n      continue;\n    }\n\n    // dereference @context key if present\n    if(_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // context must be an object by now, all URLs retrieved before this call\n    if(!_isObject(ctx)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context must be an object.',\n        'jsonld.SyntaxError', {code: 'invalid local context', context: ctx});\n    }\n\n    // TODO: there is likely a `previousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n\n    // clone context before updating it\n    rval = rval.clone();\n\n    // define context mappings for keys in local context\n    const defined = new Map();\n\n    // handle @version\n    if('@version' in ctx) {\n      if(ctx['@version'] !== 1.1) {\n        throw new JsonLdError(\n          'Unsupported JSON-LD version: ' + ctx['@version'],\n          'jsonld.UnsupportedVersion',\n          {code: 'invalid @version value', context: ctx});\n      }\n      if(activeCtx.processingMode &&\n        activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          '@version: ' + ctx['@version'] + ' not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.ProcessingModeConflict',\n          {code: 'processing mode conflict', context: ctx});\n      }\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    }\n\n    // if not set explicitly, set processingMode to \"json-ld-1.1\"\n    rval.processingMode =\n      rval.processingMode || activeCtx.processingMode;\n\n    // handle @base\n    if('@base' in ctx) {\n      let base = ctx['@base'];\n\n      if(base === null || _isAbsoluteIri(base)) {\n        // no action\n      } else if(_isRelativeIri(base)) {\n        base = prependBase(rval['@base'], base);\n      } else {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@base\" in a ' +\n          '@context must be an absolute IRI, a relative IRI, or null.',\n          'jsonld.SyntaxError', {code: 'invalid base IRI', context: ctx});\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    }\n\n    // handle @vocab\n    if('@vocab' in ctx) {\n      const value = ctx['@vocab'];\n      if(value === null) {\n        delete rval['@vocab'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else if(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be an absolute IRI.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else {\n        const vocab = _expandIri(rval, value, {vocab: true, base: true},\n          undefined, undefined, options);\n        if(!_isAbsoluteIri(vocab)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative @vocab reference',\n                level: 'warning',\n                message: 'Relative @vocab reference found.',\n                details: {\n                  vocab\n                }\n              },\n              options\n            });\n          }\n        }\n        rval['@vocab'] = vocab;\n      }\n      defined.set('@vocab', true);\n    }\n\n    // handle @language\n    if('@language' in ctx) {\n      const value = ctx['@language'];\n      if(value === null) {\n        delete rval['@language'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@language\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError',\n          {code: 'invalid default language', context: ctx});\n      } else {\n        if(!value.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language: value\n                }\n              },\n              options\n            });\n          }\n        }\n        rval['@language'] = value.toLowerCase();\n      }\n      defined.set('@language', true);\n    }\n\n    // handle @direction\n    if('@direction' in ctx) {\n      const value = ctx['@direction'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @direction not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context member', context: ctx});\n      }\n      if(value === null) {\n        delete rval['@direction'];\n      } else if(value !== 'ltr' && value !== 'rtl') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@direction\" in a ' +\n          '@context must be null, \"ltr\", or \"rtl\".',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', context: ctx});\n      } else {\n        rval['@direction'] = value;\n      }\n      defined.set('@direction', true);\n    }\n\n    // handle @propagate\n    // note: we've already extracted it, here we just do error checking\n    if('@propagate' in ctx) {\n      const value = ctx['@propagate'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(typeof value !== 'boolean') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate value must be a boolean.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @propagate value', context: localCtx});\n      }\n      defined.set('@propagate', true);\n    }\n\n    // handle @import\n    if('@import' in ctx) {\n      const value = ctx['@import'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @import value', context: localCtx});\n      }\n\n      // resolve contexts\n      const resolvedImport = await options.contextResolver.resolve({\n        activeCtx,\n        context: value,\n        documentLoader: options.documentLoader,\n        base: options.base\n      });\n      if(resolvedImport.length !== 1) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must reference a single context.',\n          'jsonld.SyntaxError',\n          {code: 'invalid remote context', context: localCtx});\n      }\n      const processedImport = resolvedImport[0].getProcessed(activeCtx);\n      if(processedImport) {\n        // Note: if the same context were used in this active context\n        // as a reference context, then processed_input might not\n        // be a dict.\n        ctx = processedImport;\n      } else {\n        const importCtx = resolvedImport[0].document;\n        if('@import' in importCtx) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax: ' +\n            'imported context must not include @import.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context entry', context: localCtx});\n        }\n\n        // merge ctx into importCtx and replace rval with the result\n        for(const key in importCtx) {\n          if(!ctx.hasOwnProperty(key)) {\n            ctx[key] = importCtx[key];\n          }\n        }\n\n        // Note: this could potenially conflict if the import\n        // were used in the same active context as a referenced\n        // context and an import. In this case, we\n        // could override the cached result, but seems unlikely.\n        resolvedImport[0].setProcessed(activeCtx, ctx);\n      }\n\n      defined.set('@import', true);\n    }\n\n    // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n    defined.set('@protected', ctx['@protected'] || false);\n\n    // process all other keys\n    for(const key in ctx) {\n      api.createTermDefinition({\n        activeCtx: rval,\n        localCtx: ctx,\n        term: key,\n        defined,\n        options,\n        overrideProtected\n      });\n\n      if(_isObject(ctx[key]) && '@context' in ctx[key]) {\n        const keyCtx = ctx[key]['@context'];\n        let process = true;\n        if(_isString(keyCtx)) {\n          const url = prependBase(options.base, keyCtx);\n          // track processed contexts to avoid scoped context recursion\n          if(cycles.has(url)) {\n            process = false;\n          } else {\n            cycles.add(url);\n          }\n        }\n        // parse context to validate\n        if(process) {\n          try {\n            await api.process({\n              activeCtx: rval.clone(),\n              localCtx: ctx[key]['@context'],\n              overrideProtected: true,\n              options,\n              cycles\n            });\n          } catch(e) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; invalid scoped context.',\n              'jsonld.SyntaxError',\n              {\n                code: 'invalid scoped context',\n                context: ctx[key]['@context'],\n                term: key\n              });\n          }\n        }\n      }\n    }\n\n    // cache processed result\n    resolvedContext.setProcessed(activeCtx, {\n      context: rval,\n      events\n    });\n  }\n\n  return rval;\n};\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\napi.createTermDefinition = ({\n  activeCtx,\n  localCtx,\n  term,\n  defined,\n  options,\n  overrideProtected = false,\n}) => {\n  if(defined.has(term)) {\n    // term already defined\n    if(defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError(\n      'Cyclical context definition detected.',\n      'jsonld.CyclicalContext',\n      {code: 'cyclic IRI mapping', context: localCtx, term});\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  // get context term value\n  let value;\n  if(localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  if(term === '@type' &&\n     _isObject(value) &&\n     (value['@container'] || '@set') === '@set' &&\n     api.processingMode(activeCtx, 1.1)) {\n\n    const validKeys = ['@container', '@id', '@protected'];\n    const keys = Object.keys(value);\n    if(keys.length === 0 || keys.some(k => !validKeys.includes(k))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords cannot be overridden.',\n        'jsonld.SyntaxError',\n        {code: 'keyword redefinition', context: localCtx, term});\n    }\n  } else if(api.isKeyword(term)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; keywords cannot be overridden.',\n      'jsonld.SyntaxError',\n      {code: 'keyword redefinition', context: localCtx, term});\n  } else if(term.match(REGEX_KEYWORD)) {\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'reserved term',\n          level: 'warning',\n          message:\n            'Terms beginning with \"@\" are ' +\n            'reserved for future use and dropped.',\n          details: {\n            term\n          }\n        },\n        options\n      });\n    }\n    return;\n  } else if(term === '') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a term cannot be an empty string.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  const previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if(activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // convert short-hand value to object w/@id\n  let simpleTerm = false;\n  if(_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {'@id': value};\n  }\n\n  if(!_isObject(value)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context term values must be ' +\n      'strings or objects.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // create new mapping\n  const mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  const validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if(api.processingMode(activeCtx, 1.1)) {\n    validKeys.push(\n      '@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n\n  for(const kw in value) {\n    if(!validKeys.includes(kw)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a term definition must not contain ' + kw,\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  const colon = term.indexOf(':');\n  mapping._termHasColon = (colon > 0);\n\n  if('@reverse' in value) {\n    if('@id' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @id.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    if('@nest' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @nest.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    const reverse = value['@reverse'];\n    if(!_isString(reverse)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    if(reverse.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @reverse value',\n            level: 'warning',\n            message:\n              '@reverse values beginning with \"@\" are ' +\n              'reserved for future use and dropped.',\n            details: {\n              reverse\n            }\n          },\n          options\n        });\n      }\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    }\n\n    // expand and add @id mapping\n    const id = _expandIri(\n      activeCtx, reverse, {vocab: true, base: false}, localCtx, defined,\n      options);\n    if(!_isAbsoluteIri(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be an ' +\n        'absolute IRI or a blank node identifier.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    mapping['@id'] = id;\n    mapping.reverse = true;\n  } else if('@id' in value) {\n    let id = value['@id'];\n    if(id && !_isString(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @id value must be an array ' +\n        'of strings or a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    if(id === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if(!api.isKeyword(id) && id.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @id value',\n            level: 'warning',\n            message:\n              '@id values beginning with \"@\" are ' +\n              'reserved for future use and dropped.',\n            details: {\n              id\n            }\n          },\n          options\n        });\n      }\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    } else if(id !== term) {\n      // expand and add @id mapping\n      id = _expandIri(\n        activeCtx, id, {vocab: true, base: false}, localCtx, defined, options);\n      if(!_isAbsoluteIri(id) && !api.isKeyword(id)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a @context @id value must be an ' +\n          'absolute IRI, a blank node identifier, or a keyword.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx});\n      }\n\n      // if term has the form of an IRI it must map the same\n      if(term.match(/(?::[^:])|\\//)) {\n        const termDefined = new Map(defined).set(term, true);\n        const termIri = _expandIri(\n          activeCtx, term, {vocab: true, base: false},\n          localCtx, termDefined, options);\n        if(termIri !== id) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; term in form of IRI must ' +\n            'expand to definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid IRI mapping', context: localCtx});\n        }\n      }\n\n      mapping['@id'] = id;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = (simpleTerm &&\n        !mapping._termHasColon &&\n        id.match(/[:\\/\\?#\\[\\]@]$/) !== null);\n    }\n  }\n\n  if(!('@id' in mapping)) {\n    // see if the term has a prefix\n    if(mapping._termHasColon) {\n      const prefix = term.substr(0, colon);\n      if(localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx, localCtx, term: prefix, defined, options\n        });\n      }\n\n      if(activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        const suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if(term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if(!('@vocab' in activeCtx)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @context terms must define an @id.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx, term});\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if(value['@protected'] === true ||\n    (defined.get('@protected') === true && value['@protected'] !== false)) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n\n  if('@type' in value) {\n    let type = value['@type'];\n    if(!_isString(type)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an @context @type value must be a string.',\n        'jsonld.SyntaxError',\n        {code: 'invalid type mapping', context: localCtx});\n    }\n\n    if((type === '@json' || type === '@none')) {\n      if(api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must not be ' +\n          `\"${type}\" in JSON-LD 1.0 mode.`,\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    } else if(type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(\n        activeCtx, type, {vocab: true, base: false}, localCtx, defined,\n        options);\n      if(!_isAbsoluteIri(type)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an ' +\n          'absolute IRI.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n      if(type.indexOf('_:') === 0) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an IRI, ' +\n          'not a blank node identifier.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n\n  if('@container' in value) {\n    // normalize container to an array form\n    const container = _isString(value['@container']) ?\n      [value['@container']] : (value['@container'] || []);\n    const validContainers = ['@list', '@set', '@index', '@language'];\n    let isValid = true;\n    const hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if(api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if(container.includes('@list')) {\n        if(container.length !== 1) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @list must ' +\n            'have no other values',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else if(container.includes('@graph')) {\n        if(container.some(key =>\n          key !== '@graph' && key !== '@id' && key !== '@index' &&\n          key !== '@set')) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @graph must ' +\n            'have no other values other than @id, @index, and @set',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n\n      if(container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id';\n\n        // type mapping must be either @id or @vocab\n        if(!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; container: @type requires @type to be ' +\n            '@id or @vocab.',\n            'jsonld.SyntaxError',\n            {code: 'invalid type mapping', context: localCtx});\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(c => validContainers.includes(c));\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if(!isValid) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value must be ' +\n        'one of the following: ' + validContainers.join(', '),\n        'jsonld.SyntaxError',\n        {code: 'invalid container mapping', context: localCtx});\n    }\n\n    if(mapping.reverse &&\n      !container.every(c => ['@index', '@set'].includes(c))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value for a @reverse ' +\n        'type definition must be @index or @set.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // property indexing\n  if('@index' in value) {\n    if(!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index without @index in @container: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index must expand to an IRI: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    mapping['@index'] = value['@index'];\n  }\n\n  // scoped contexts\n  if('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if('@language' in value && !('@type' in value)) {\n    let language = value['@language'];\n    if(language !== null && !_isString(language)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @language value must be ' +\n        'a string or null.', 'jsonld.SyntaxError',\n        {code: 'invalid language mapping', context: localCtx});\n    }\n\n    // add @language to mapping\n    if(language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if('@prefix' in value) {\n    if(term.match(/:|\\//)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @prefix used on a compact IRI term',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords may not be used as prefixes',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context value for @prefix must be boolean',\n        'jsonld.SyntaxError',\n        {code: 'invalid @prefix value', context: localCtx});\n    }\n  }\n\n  if('@direction' in value) {\n    const direction = value['@direction'];\n    if(direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @direction value must be ' +\n        'null, \"ltr\", or \"rtl\".',\n        'jsonld.SyntaxError',\n        {code: 'invalid base direction', context: localCtx});\n    }\n    mapping['@direction'] = direction;\n  }\n\n  if('@nest' in value) {\n    const nest = value['@nest'];\n    if(!_isString(nest) || (nest !== '@nest' && nest.indexOf('@') === 0)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @nest value must be ' +\n        'a string which is not a keyword other than @nest.',\n        'jsonld.SyntaxError',\n        {code: 'invalid @nest value', context: localCtx});\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  const id = mapping['@id'];\n  if(id === '@context' || id === '@preserve') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',\n      'jsonld.SyntaxError', {code: 'invalid keyword alias', context: localCtx});\n  }\n\n  // Check for overriding protected terms\n  if(previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if(!_deepCompare(previousMapping, mapping)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; tried to redefine a protected term.',\n        'jsonld.SyntaxError',\n        {code: 'protected term redefinition', context: localCtx, term});\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = (activeCtx, value, relativeTo, options) => {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined,\n    options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if(value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // ignore non-keyword things that look like a keyword\n  if(value.match(REGEX_KEYWORD)) {\n    return null;\n  }\n\n  // define term dependency if not defined\n  if(localCtx && localCtx.hasOwnProperty(value) &&\n    defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx, localCtx, term: value, defined, options\n    });\n  }\n\n  relativeTo = relativeTo || {};\n  if(relativeTo.vocab) {\n    const mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if(mapping === null) {\n      return null;\n    }\n\n    if(_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  const colon = value.indexOf(':');\n  if(colon > 0) {\n    const prefix = value.substr(0, colon);\n    const suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if(prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if(localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx, localCtx, term: prefix, defined, options\n      });\n    }\n\n    // use mapping if prefix is defined\n    const mapping = activeCtx.mappings.get(prefix);\n    if(mapping && mapping._prefix) {\n      return mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    if(_isAbsoluteIri(value)) {\n      return value;\n    }\n  }\n\n  // A flag that captures whether the iri being expanded is\n  // the value for an @type\n  //let typeExpansion = false;\n\n  //if(options !== undefined && options.typeExpansion !== undefined) {\n  //  typeExpansion = options.typeExpansion;\n  //}\n\n  if(relativeTo.vocab && '@vocab' in activeCtx) {\n    // prepend vocab\n    const prependedResult = activeCtx['@vocab'] + value;\n    // FIXME: needed? may be better as debug event.\n    /*\n    if(options && options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'prepending @vocab during expansion',\n          level: 'info',\n          message: 'Prepending @vocab during expansion.',\n          details: {\n            type: '@vocab',\n            vocab: activeCtx['@vocab'],\n            value,\n            result: prependedResult,\n            typeExpansion\n          }\n        },\n        options\n      });\n    }\n    */\n    // the null case preserves value as potentially relative\n    value = prependedResult;\n  } else if(relativeTo.base) {\n    // prepend base\n    let prependedResult;\n    let base;\n    if('@base' in activeCtx) {\n      if(activeCtx['@base']) {\n        base = prependBase(options.base, activeCtx['@base']);\n        prependedResult = prependBase(base, value);\n      } else {\n        base = activeCtx['@base'];\n        prependedResult = value;\n      }\n    } else {\n      base = options.base;\n      prependedResult = prependBase(options.base, value);\n    }\n    // FIXME: needed? may be better as debug event.\n    /*\n    if(options && options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'prepending @base during expansion',\n          level: 'info',\n          message: 'Prepending @base during expansion.',\n          details: {\n            type: '@base',\n            base,\n            value,\n            result: prependedResult,\n            typeExpansion\n          }\n        },\n        options\n      });\n    }\n    */\n    // the null case preserves value as potentially relative\n    value = prependedResult;\n  }\n\n  // FIXME: duplicate? needed? maybe just enable in a verbose debug mode\n  /*\n  if(!_isAbsoluteIri(value) && options && options.eventHandler) {\n    // emit event indicating a relative IRI was found, which can result in it\n    // being dropped when converting to other RDF representations\n    _handleEvent({\n      event: {\n        type: ['JsonLdEvent'],\n        code: 'relative IRI after expansion',\n        // FIXME: what level?\n        level: 'warning',\n        message: 'Relative IRI after expansion.',\n        details: {\n          relativeIri: value,\n          typeExpansion\n        }\n      },\n      options\n    });\n    // NOTE: relative reference events emitted at calling sites as needed\n  }\n  */\n\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = options => {\n  const key = JSON.stringify({processingMode: options.processingMode});\n  const cached = INITIAL_CONTEXT_CACHE.get(key);\n  if(cached) {\n    return cached;\n  }\n\n  const initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if(INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    const activeCtx = this;\n\n    // lazily create inverse\n    if(activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    const inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    const fastCurieMap = activeCtx.fastCurieMap = {};\n    const irisToTerms = {};\n\n    // handle default language\n    const defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase();\n\n    // handle default direction\n    const defaultDirection = activeCtx['@direction'];\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    const mappings = activeCtx.mappings;\n    const terms = [...mappings.keys()].sort(_compareShortestLeast);\n    for(const term of terms) {\n      const mapping = mappings.get(term);\n      if(mapping === null) {\n        continue;\n      }\n\n      let container = mapping['@container'] || '@none';\n      container = [].concat(container).sort().join('');\n\n      if(mapping['@id'] === null) {\n        continue;\n      }\n      // iterate over every IRI in the mapping\n      const ids = _asArray(mapping['@id']);\n      for(const iri of ids) {\n        let entry = inverse[iri];\n        const isKeyword = api.isKeyword(iri);\n\n        if(!entry) {\n          // initialize entry\n          inverse[iri] = entry = {};\n\n          if(!isKeyword && !mapping._termHasColon) {\n            // init IRI to term map and fast CURIE prefixes\n            irisToTerms[iri] = [term];\n            const fastCurieEntry = {iri, terms: irisToTerms[iri]};\n            if(iri[0] in fastCurieMap) {\n              fastCurieMap[iri[0]].push(fastCurieEntry);\n            } else {\n              fastCurieMap[iri[0]] = [fastCurieEntry];\n            }\n          }\n        } else if(!isKeyword && !mapping._termHasColon) {\n          // add IRI to term match\n          irisToTerms[iri].push(term);\n        }\n\n        // add new entry\n        if(!entry[container]) {\n          entry[container] = {\n            '@language': {},\n            '@type': {},\n            '@any': {}\n          };\n        }\n        entry = entry[container];\n        _addPreferredTerm(term, entry['@any'], '@none');\n\n        if(mapping.reverse) {\n          // term is preferred for values using @reverse\n          _addPreferredTerm(term, entry['@type'], '@reverse');\n        } else if(mapping['@type'] === '@none') {\n          _addPreferredTerm(term, entry['@any'], '@none');\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else if('@type' in mapping) {\n          // term is preferred for values using specific type\n          _addPreferredTerm(term, entry['@type'], mapping['@type']);\n        } else if('@language' in mapping && '@direction' in mapping) {\n          // term is preferred for values using specific language and direction\n          const language = mapping['@language'];\n          const direction = mapping['@direction'];\n          if(language && direction) {\n            _addPreferredTerm(term, entry['@language'],\n              `${language}_${direction}`.toLowerCase());\n          } else if(language) {\n            _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n          } else if(direction) {\n            _addPreferredTerm(term, entry['@language'], `_${direction}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@null');\n          }\n        } else if('@language' in mapping) {\n          _addPreferredTerm(term, entry['@language'],\n            (mapping['@language'] || '@null').toLowerCase());\n        } else if('@direction' in mapping) {\n          if(mapping['@direction']) {\n            _addPreferredTerm(term, entry['@language'],\n              `_${mapping['@direction']}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@none');\n          }\n        } else if(defaultDirection) {\n          _addPreferredTerm(term, entry['@language'], `_${defaultDirection}`);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else {\n          // add entries for no type and no language\n          _addPreferredTerm(term, entry['@language'], defaultLanguage);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        }\n      }\n    }\n\n    // build fast CURIE map\n    for(const key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, key, 1);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    const entries = iriMap[key];\n    const next = iriMap[key] = {};\n\n    let iri;\n    let letter;\n    for(const entry of entries) {\n      iri = entry.iri;\n      if(idx >= iri.length) {\n        letter = '';\n      } else {\n        letter = iri[idx];\n      }\n      if(letter in next) {\n        next[letter].push(entry);\n      } else {\n        next[letter] = [entry];\n      }\n    }\n\n    for(const key in next) {\n      if(key === '') {\n        continue;\n      }\n      _buildIriMap(next, key, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if(!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    const child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if(this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertToPreviousContext = this.revertToPreviousContext;\n    if('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n    if('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertToPreviousContext() {\n    if(!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = (ctx, key, type) => {\n  // invalid key\n  if(key === null) {\n    if(type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if(ctx.mappings.has(key)) {\n    const entry = ctx.mappings.get(key);\n\n    if(_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if(entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if(type === '@language' && type in ctx) {\n    return ctx[type];\n  }\n\n  // get default direction\n  if(type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n\n  if(type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = (activeCtx, version) => {\n  if(version.toString() >= '1.1') {\n    return !activeCtx.processingMode ||\n      activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = v => {\n  if(!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n  switch(v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if((!(x1 && typeof x1 === 'object')) ||\n     (!(x2 && typeof x2 === 'object'))) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  const x1Array = Array.isArray(x1);\n  if(x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if(x1Array) {\n    if(x1.length !== x2.length) {\n      return false;\n    }\n    for(let i = 0; i < x1.length; ++i) {\n      if(!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  const k1s = Object.keys(x1);\n  const k2s = Object.keys(x2);\n  if(k1s.length !== k2s.length) {\n    return false;\n  }\n  for(const k1 in x1) {\n    let v1 = x1[k1];\n    let v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if(k1 === '@container') {\n      if(Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if(!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9jb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyx1REFBUTtBQUM3QixvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBZTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlEQUFTOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFEQUFPOztBQUVuQjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkRBQVU7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx1REFBUTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGVBQWU7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVDQUF1QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsR0FBRyxVQUFVO0FBQ3ZDLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWiw0REFBNEQsVUFBVTtBQUN0RSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBEQUEwRCxpQkFBaUI7QUFDM0U7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9jb250ZXh0LmpzPzc5MzgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmcsXG4gIGlzVW5kZWZpbmVkOiBfaXNVbmRlZmluZWRcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNBYnNvbHV0ZTogX2lzQWJzb2x1dGVJcmksXG4gIGlzUmVsYXRpdmU6IF9pc1JlbGF0aXZlSXJpLFxuICBwcmVwZW5kQmFzZVxufSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbmNvbnN0IHtcbiAgaGFuZGxlRXZlbnQ6IF9oYW5kbGVFdmVudFxufSA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbmNvbnN0IHtcbiAgUkVHRVhfQkNQNDcsXG4gIFJFR0VYX0tFWVdPUkQsXG4gIGFzQXJyYXk6IF9hc0FycmF5LFxuICBjb21wYXJlU2hvcnRlc3RMZWFzdDogX2NvbXBhcmVTaG9ydGVzdExlYXN0XG59ID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IElOSVRJQUxfQ09OVEVYVF9DQUNIRSA9IG5ldyBNYXAoKTtcbmNvbnN0IElOSVRJQUxfQ09OVEVYVF9DQUNIRV9NQVhfU0laRSA9IDEwMDAwO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIGxvY2FsIGNvbnRleHQgYW5kIHJldHVybnMgYSBuZXcgYWN0aXZlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSBsb2NhbEN0eCB0aGUgbG9jYWwgY29udGV4dCB0byBwcm9jZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGNvbnRleHQgcHJvY2Vzc2luZyBvcHRpb25zLlxuICogQHBhcmFtIHByb3BhZ2F0ZSBgdHJ1ZWAgaWYgYGZhbHNlYCwgcmV0YWlucyBhbnkgcHJldmlvdXNseSBkZWZpbmVkIHRlcm0sXG4gKiAgIHdoaWNoIGNhbiBiZSByb2xsZWQgYmFjayB3aGVuIHRoZSBkZXNjZW5kaW5nIGludG8gYSBuZXcgbm9kZSBvYmplY3QuXG4gKiBAcGFyYW0gb3ZlcnJpZGVQcm90ZWN0ZWQgYGZhbHNlYCBhbGxvd3MgcHJvdGVjdGVkIHRlcm1zIHRvIGJlIG1vZGlmaWVkLlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBhY3RpdmUgY29udGV4dC5cbiAqL1xuYXBpLnByb2Nlc3MgPSBhc3luYyAoe1xuICBhY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zLFxuICBwcm9wYWdhdGUgPSB0cnVlLFxuICBvdmVycmlkZVByb3RlY3RlZCA9IGZhbHNlLFxuICBjeWNsZXMgPSBuZXcgU2V0KClcbn0pID0+IHtcbiAgLy8gbm9ybWFsaXplIGxvY2FsIGNvbnRleHQgdG8gYW4gYXJyYXkgb2YgQGNvbnRleHQgb2JqZWN0c1xuICBpZihfaXNPYmplY3QobG9jYWxDdHgpICYmICdAY29udGV4dCcgaW4gbG9jYWxDdHggJiZcbiAgICBfaXNBcnJheShsb2NhbEN0eFsnQGNvbnRleHQnXSkpIHtcbiAgICBsb2NhbEN0eCA9IGxvY2FsQ3R4WydAY29udGV4dCddO1xuICB9XG4gIGNvbnN0IGN0eHMgPSBfYXNBcnJheShsb2NhbEN0eCk7XG5cbiAgLy8gbm8gY29udGV4dHMgaW4gYXJyYXksIHJldHVybiBjdXJyZW50IGFjdGl2ZSBjb250ZXh0IHcvbyBjaGFuZ2VzXG4gIGlmKGN0eHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUN0eDtcbiAgfVxuXG4gIC8vIGV2ZW50IGhhbmRsZXIgZm9yIGNhcHR1cmluZyBldmVudHMgdG8gcmVwbGF5IHdoZW4gdXNpbmcgYSBjYWNoZWQgY29udGV4dFxuICBjb25zdCBldmVudHMgPSBbXTtcbiAgY29uc3QgZXZlbnRDYXB0dXJlSGFuZGxlciA9IFtcbiAgICAoe2V2ZW50LCBuZXh0fSkgPT4ge1xuICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgXTtcbiAgLy8gY2hhaW4gdG8gb3JpZ2luYWwgaGFuZGxlclxuICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgIGV2ZW50Q2FwdHVyZUhhbmRsZXIucHVzaChvcHRpb25zLmV2ZW50SGFuZGxlcik7XG4gIH1cbiAgLy8gc3RvcmUgb3JpZ2luYWwgb3B0aW9ucyB0byB1c2Ugd2hlbiByZXBsYXlpbmcgZXZlbnRzXG4gIGNvbnN0IG9yaWdpbmFsT3B0aW9ucyA9IG9wdGlvbnM7XG4gIC8vIHNoYWxsb3cgY2xvbmUgb3B0aW9ucyB3aXRoIGV2ZW50IGNhcHR1cmUgaGFuZGxlclxuICBvcHRpb25zID0gey4uLm9wdGlvbnMsIGV2ZW50SGFuZGxlcjogZXZlbnRDYXB0dXJlSGFuZGxlcn07XG5cbiAgLy8gcmVzb2x2ZSBjb250ZXh0c1xuICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IG9wdGlvbnMuY29udGV4dFJlc29sdmVyLnJlc29sdmUoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBjb250ZXh0OiBsb2NhbEN0eCxcbiAgICBkb2N1bWVudExvYWRlcjogb3B0aW9ucy5kb2N1bWVudExvYWRlcixcbiAgICBiYXNlOiBvcHRpb25zLmJhc2VcbiAgfSk7XG5cbiAgLy8gb3ZlcnJpZGUgcHJvcGFnYXRlIGlmIGZpcnN0IHJlc29sdmVkIGNvbnRleHQgaGFzIGBAcHJvcGFnYXRlYFxuICBpZihfaXNPYmplY3QocmVzb2x2ZWRbMF0uZG9jdW1lbnQpICYmXG4gICAgdHlwZW9mIHJlc29sdmVkWzBdLmRvY3VtZW50WydAcHJvcGFnYXRlJ10gPT09ICdib29sZWFuJykge1xuICAgIC8vIHJldHJpZXZlIGVhcmx5LCBlcnJvciBjaGVja2luZyBkb25lIGxhdGVyXG4gICAgcHJvcGFnYXRlID0gcmVzb2x2ZWRbMF0uZG9jdW1lbnRbJ0Bwcm9wYWdhdGUnXTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgZWFjaCBjb250ZXh0IGluIG9yZGVyLCB1cGRhdGUgYWN0aXZlIGNvbnRleHRcbiAgLy8gb24gZWFjaCBpdGVyYXRpb24gdG8gZW5zdXJlIHByb3BlciBjYWNoaW5nXG4gIGxldCBydmFsID0gYWN0aXZlQ3R4O1xuXG4gIC8vIHRyYWNrIHRoZSBwcmV2aW91cyBjb250ZXh0XG4gIC8vIGlmIG5vdCBwcm9wYWdhdGluZywgbWFrZSBzdXJlIHJ2YWwgaGFzIGEgcHJldmlvdXMgY29udGV4dFxuICBpZighcHJvcGFnYXRlICYmICFydmFsLnByZXZpb3VzQ29udGV4dCkge1xuICAgIC8vIGNsb25lIGBydmFsYCBjb250ZXh0IGJlZm9yZSB1cGRhdGluZ1xuICAgIHJ2YWwgPSBydmFsLmNsb25lKCk7XG4gICAgcnZhbC5wcmV2aW91c0NvbnRleHQgPSBhY3RpdmVDdHg7XG4gIH1cblxuICBmb3IoY29uc3QgcmVzb2x2ZWRDb250ZXh0IG9mIHJlc29sdmVkKSB7XG4gICAgbGV0IHtkb2N1bWVudDogY3R4fSA9IHJlc29sdmVkQ29udGV4dDtcblxuICAgIC8vIHVwZGF0ZSBhY3RpdmUgY29udGV4dCB0byBvbmUgY29tcHV0ZWQgZnJvbSBsYXN0IGl0ZXJhdGlvblxuICAgIGFjdGl2ZUN0eCA9IHJ2YWw7XG5cbiAgICAvLyByZXNldCB0byBpbml0aWFsIGNvbnRleHRcbiAgICBpZihjdHggPT09IG51bGwpIHtcbiAgICAgIC8vIFdlIGNhbid0IG51bGxpZnkgaWYgdGhlcmUgYXJlIHByb3RlY3RlZCB0ZXJtcyBhbmQgd2UncmVcbiAgICAgIC8vIG5vdCBhbGxvd2luZyBvdmVycmlkZXMgKGUuZy4gcHJvY2Vzc2luZyBhIHByb3BlcnR5IHRlcm0gc2NvcGVkIGNvbnRleHQpXG4gICAgICBpZighb3ZlcnJpZGVQcm90ZWN0ZWQgJiYgT2JqZWN0LmtleXMoYWN0aXZlQ3R4LnByb3RlY3RlZCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnVHJpZWQgdG8gbnVsbGlmeSBhIGNvbnRleHQgd2l0aCBwcm90ZWN0ZWQgdGVybXMgb3V0c2lkZSBvZiAnICtcbiAgICAgICAgICAnYSB0ZXJtIGRlZmluaXRpb24uJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgY29udGV4dCBudWxsaWZpY2F0aW9uJ30pO1xuICAgICAgfVxuICAgICAgcnZhbCA9IGFjdGl2ZUN0eCA9IGFwaS5nZXRJbml0aWFsQ29udGV4dChvcHRpb25zKS5jbG9uZSgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHByb2Nlc3NlZCBjb250ZXh0IGZyb20gY2FjaGUgaWYgYXZhaWxhYmxlXG4gICAgY29uc3QgcHJvY2Vzc2VkID0gcmVzb2x2ZWRDb250ZXh0LmdldFByb2Nlc3NlZChhY3RpdmVDdHgpO1xuICAgIGlmKHByb2Nlc3NlZCkge1xuICAgICAgaWYob3JpZ2luYWxPcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICAvLyByZXBsYXkgZXZlbnRzIHdpdGggb3JpZ2luYWwgbm9uLWNhcHR1cmluZyBvcHRpb25zXG4gICAgICAgIGZvcihjb25zdCBldmVudCBvZiBwcm9jZXNzZWQuZXZlbnRzKSB7XG4gICAgICAgICAgX2hhbmRsZUV2ZW50KHtldmVudCwgb3B0aW9uczogb3JpZ2luYWxPcHRpb25zfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcnZhbCA9IGFjdGl2ZUN0eCA9IHByb2Nlc3NlZC5jb250ZXh0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVyZWZlcmVuY2UgQGNvbnRleHQga2V5IGlmIHByZXNlbnRcbiAgICBpZihfaXNPYmplY3QoY3R4KSAmJiAnQGNvbnRleHQnIGluIGN0eCkge1xuICAgICAgY3R4ID0gY3R4WydAY29udGV4dCddO1xuICAgIH1cblxuICAgIC8vIGNvbnRleHQgbXVzdCBiZSBhbiBvYmplY3QgYnkgbm93LCBhbGwgVVJMcyByZXRyaWV2ZWQgYmVmb3JlIHRoaXMgY2FsbFxuICAgIGlmKCFfaXNPYmplY3QoY3R4KSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBsb2NhbCBjb250ZXh0JywgY29udGV4dDogY3R4fSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdGhlcmUgaXMgbGlrZWx5IGEgYHByZXZpb3VzQ29udGV4dGAgY2xvbmluZyBvcHRpbWl6YXRpb24gdGhhdFxuICAgIC8vIGNvdWxkIGJlIGFwcGxpZWQgaGVyZSAobm8gbmVlZCB0byBjb3B5IGl0IHVuZGVyIGNlcnRhaW4gY29uZGl0aW9ucylcblxuICAgIC8vIGNsb25lIGNvbnRleHQgYmVmb3JlIHVwZGF0aW5nIGl0XG4gICAgcnZhbCA9IHJ2YWwuY2xvbmUoKTtcblxuICAgIC8vIGRlZmluZSBjb250ZXh0IG1hcHBpbmdzIGZvciBrZXlzIGluIGxvY2FsIGNvbnRleHRcbiAgICBjb25zdCBkZWZpbmVkID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gaGFuZGxlIEB2ZXJzaW9uXG4gICAgaWYoJ0B2ZXJzaW9uJyBpbiBjdHgpIHtcbiAgICAgIGlmKGN0eFsnQHZlcnNpb24nXSAhPT0gMS4xKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnVW5zdXBwb3J0ZWQgSlNPTi1MRCB2ZXJzaW9uOiAnICsgY3R4WydAdmVyc2lvbiddLFxuICAgICAgICAgICdqc29ubGQuVW5zdXBwb3J0ZWRWZXJzaW9uJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgQHZlcnNpb24gdmFsdWUnLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH1cbiAgICAgIGlmKGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSAmJlxuICAgICAgICBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUgPT09ICdqc29uLWxkLTEuMCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdAdmVyc2lvbjogJyArIGN0eFsnQHZlcnNpb24nXSArICcgbm90IGNvbXBhdGlibGUgd2l0aCAnICtcbiAgICAgICAgICBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUsXG4gICAgICAgICAgJ2pzb25sZC5Qcm9jZXNzaW5nTW9kZUNvbmZsaWN0JyxcbiAgICAgICAgICB7Y29kZTogJ3Byb2Nlc3NpbmcgbW9kZSBjb25mbGljdCcsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfVxuICAgICAgcnZhbC5wcm9jZXNzaW5nTW9kZSA9ICdqc29uLWxkLTEuMSc7XG4gICAgICBydmFsWydAdmVyc2lvbiddID0gY3R4WydAdmVyc2lvbiddO1xuICAgICAgZGVmaW5lZC5zZXQoJ0B2ZXJzaW9uJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgbm90IHNldCBleHBsaWNpdGx5LCBzZXQgcHJvY2Vzc2luZ01vZGUgdG8gXCJqc29uLWxkLTEuMVwiXG4gICAgcnZhbC5wcm9jZXNzaW5nTW9kZSA9XG4gICAgICBydmFsLnByb2Nlc3NpbmdNb2RlIHx8IGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZTtcblxuICAgIC8vIGhhbmRsZSBAYmFzZVxuICAgIGlmKCdAYmFzZScgaW4gY3R4KSB7XG4gICAgICBsZXQgYmFzZSA9IGN0eFsnQGJhc2UnXTtcblxuICAgICAgaWYoYmFzZSA9PT0gbnVsbCB8fCBfaXNBYnNvbHV0ZUlyaShiYXNlKSkge1xuICAgICAgICAvLyBubyBhY3Rpb25cbiAgICAgIH0gZWxzZSBpZihfaXNSZWxhdGl2ZUlyaShiYXNlKSkge1xuICAgICAgICBiYXNlID0gcHJlcGVuZEJhc2UocnZhbFsnQGJhc2UnXSwgYmFzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRoZSB2YWx1ZSBvZiBcIkBiYXNlXCIgaW4gYSAnICtcbiAgICAgICAgICAnQGNvbnRleHQgbXVzdCBiZSBhbiBhYnNvbHV0ZSBJUkksIGEgcmVsYXRpdmUgSVJJLCBvciBudWxsLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBiYXNlIElSSScsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfVxuXG4gICAgICBydmFsWydAYmFzZSddID0gYmFzZTtcbiAgICAgIGRlZmluZWQuc2V0KCdAYmFzZScsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBAdm9jYWJcbiAgICBpZignQHZvY2FiJyBpbiBjdHgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3R4WydAdm9jYWInXTtcbiAgICAgIGlmKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBydmFsWydAdm9jYWInXTtcbiAgICAgIH0gZWxzZSBpZighX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRoZSB2YWx1ZSBvZiBcIkB2b2NhYlwiIGluIGEgJyArXG4gICAgICAgICAgJ0Bjb250ZXh0IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgdm9jYWIgbWFwcGluZycsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfSBlbHNlIGlmKCFfaXNBYnNvbHV0ZUlyaSh2YWx1ZSkgJiYgYXBpLnByb2Nlc3NpbmdNb2RlKHJ2YWwsIDEuMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0aGUgdmFsdWUgb2YgXCJAdm9jYWJcIiBpbiBhICcgK1xuICAgICAgICAgICdAY29udGV4dCBtdXN0IGJlIGFuIGFic29sdXRlIElSSS4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgdm9jYWIgbWFwcGluZycsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgdm9jYWIgPSBfZXhwYW5kSXJpKHJ2YWwsIHZhbHVlLCB7dm9jYWI6IHRydWUsIGJhc2U6IHRydWV9LFxuICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKHZvY2FiKSkge1xuICAgICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgICAgICBjb2RlOiAncmVsYXRpdmUgQHZvY2FiIHJlZmVyZW5jZScsXG4gICAgICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVsYXRpdmUgQHZvY2FiIHJlZmVyZW5jZSBmb3VuZC4nLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgIHZvY2FiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnZhbFsnQHZvY2FiJ10gPSB2b2NhYjtcbiAgICAgIH1cbiAgICAgIGRlZmluZWQuc2V0KCdAdm9jYWInLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgQGxhbmd1YWdlXG4gICAgaWYoJ0BsYW5ndWFnZScgaW4gY3R4KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eFsnQGxhbmd1YWdlJ107XG4gICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcnZhbFsnQGxhbmd1YWdlJ107XG4gICAgICB9IGVsc2UgaWYoIV9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0aGUgdmFsdWUgb2YgXCJAbGFuZ3VhZ2VcIiBpbiBhICcgK1xuICAgICAgICAgICdAY29udGV4dCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgZGVmYXVsdCBsYW5ndWFnZScsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIXZhbHVlLm1hdGNoKFJFR0VYX0JDUDQ3KSkge1xuICAgICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZCBAbGFuZ3VhZ2UgdmFsdWUnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0BsYW5ndWFnZSB2YWx1ZSBtdXN0IGJlIHZhbGlkIEJDUDQ3LicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnZhbFsnQGxhbmd1YWdlJ10gPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgZGVmaW5lZC5zZXQoJ0BsYW5ndWFnZScsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBAZGlyZWN0aW9uXG4gICAgaWYoJ0BkaXJlY3Rpb24nIGluIGN0eCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdHhbJ0BkaXJlY3Rpb24nXTtcbiAgICAgIGlmKGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA9PT0gJ2pzb24tbGQtMS4wJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBkaXJlY3Rpb24gbm90IGNvbXBhdGlibGUgd2l0aCAnICtcbiAgICAgICAgICBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRleHQgbWVtYmVyJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9XG4gICAgICBpZih2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgcnZhbFsnQGRpcmVjdGlvbiddO1xuICAgICAgfSBlbHNlIGlmKHZhbHVlICE9PSAnbHRyJyAmJiB2YWx1ZSAhPT0gJ3J0bCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyB0aGUgdmFsdWUgb2YgXCJAZGlyZWN0aW9uXCIgaW4gYSAnICtcbiAgICAgICAgICAnQGNvbnRleHQgbXVzdCBiZSBudWxsLCBcImx0clwiLCBvciBcInJ0bFwiLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGJhc2UgZGlyZWN0aW9uJywgY29udGV4dDogY3R4fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydmFsWydAZGlyZWN0aW9uJ10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGRlZmluZWQuc2V0KCdAZGlyZWN0aW9uJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEBwcm9wYWdhdGVcbiAgICAvLyBub3RlOiB3ZSd2ZSBhbHJlYWR5IGV4dHJhY3RlZCBpdCwgaGVyZSB3ZSBqdXN0IGRvIGVycm9yIGNoZWNraW5nXG4gICAgaWYoJ0Bwcm9wYWdhdGUnIGluIGN0eCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjdHhbJ0Bwcm9wYWdhdGUnXTtcbiAgICAgIGlmKGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA9PT0gJ2pzb24tbGQtMS4wJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBwcm9wYWdhdGUgbm90IGNvbXBhdGlibGUgd2l0aCAnICtcbiAgICAgICAgICBhY3RpdmVDdHgucHJvY2Vzc2luZ01vZGUsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRleHQgZW50cnknLCBjb250ZXh0OiBjdHh9KTtcbiAgICAgIH1cbiAgICAgIGlmKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQHByb3BhZ2F0ZSB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBAcHJvcGFnYXRlIHZhbHVlJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgIH1cbiAgICAgIGRlZmluZWQuc2V0KCdAcHJvcGFnYXRlJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEBpbXBvcnRcbiAgICBpZignQGltcG9ydCcgaW4gY3R4KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eFsnQGltcG9ydCddO1xuICAgICAgaWYoYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID09PSAnanNvbi1sZC0xLjAnKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGltcG9ydCBub3QgY29tcGF0aWJsZSB3aXRoICcgK1xuICAgICAgICAgIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgY29udGV4dCBlbnRyeScsIGNvbnRleHQ6IGN0eH0pO1xuICAgICAgfVxuICAgICAgaWYoIV9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAaW1wb3J0IG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgQGltcG9ydCB2YWx1ZScsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc29sdmUgY29udGV4dHNcbiAgICAgIGNvbnN0IHJlc29sdmVkSW1wb3J0ID0gYXdhaXQgb3B0aW9ucy5jb250ZXh0UmVzb2x2ZXIucmVzb2x2ZSh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgY29udGV4dDogdmFsdWUsXG4gICAgICAgIGRvY3VtZW50TG9hZGVyOiBvcHRpb25zLmRvY3VtZW50TG9hZGVyLFxuICAgICAgICBiYXNlOiBvcHRpb25zLmJhc2VcbiAgICAgIH0pO1xuICAgICAgaWYocmVzb2x2ZWRJbXBvcnQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGltcG9ydCBtdXN0IHJlZmVyZW5jZSBhIHNpbmdsZSBjb250ZXh0LicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHJlbW90ZSBjb250ZXh0JywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2Nlc3NlZEltcG9ydCA9IHJlc29sdmVkSW1wb3J0WzBdLmdldFByb2Nlc3NlZChhY3RpdmVDdHgpO1xuICAgICAgaWYocHJvY2Vzc2VkSW1wb3J0KSB7XG4gICAgICAgIC8vIE5vdGU6IGlmIHRoZSBzYW1lIGNvbnRleHQgd2VyZSB1c2VkIGluIHRoaXMgYWN0aXZlIGNvbnRleHRcbiAgICAgICAgLy8gYXMgYSByZWZlcmVuY2UgY29udGV4dCwgdGhlbiBwcm9jZXNzZWRfaW5wdXQgbWlnaHQgbm90XG4gICAgICAgIC8vIGJlIGEgZGljdC5cbiAgICAgICAgY3R4ID0gcHJvY2Vzc2VkSW1wb3J0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW1wb3J0Q3R4ID0gcmVzb2x2ZWRJbXBvcnRbMF0uZG9jdW1lbnQ7XG4gICAgICAgIGlmKCdAaW1wb3J0JyBpbiBpbXBvcnRDdHgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDogJyArXG4gICAgICAgICAgICAnaW1wb3J0ZWQgY29udGV4dCBtdXN0IG5vdCBpbmNsdWRlIEBpbXBvcnQuJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRleHQgZW50cnknLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVyZ2UgY3R4IGludG8gaW1wb3J0Q3R4IGFuZCByZXBsYWNlIHJ2YWwgd2l0aCB0aGUgcmVzdWx0XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gaW1wb3J0Q3R4KSB7XG4gICAgICAgICAgaWYoIWN0eC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjdHhba2V5XSA9IGltcG9ydEN0eFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgY291bGQgcG90ZW5pYWxseSBjb25mbGljdCBpZiB0aGUgaW1wb3J0XG4gICAgICAgIC8vIHdlcmUgdXNlZCBpbiB0aGUgc2FtZSBhY3RpdmUgY29udGV4dCBhcyBhIHJlZmVyZW5jZWRcbiAgICAgICAgLy8gY29udGV4dCBhbmQgYW4gaW1wb3J0LiBJbiB0aGlzIGNhc2UsIHdlXG4gICAgICAgIC8vIGNvdWxkIG92ZXJyaWRlIHRoZSBjYWNoZWQgcmVzdWx0LCBidXQgc2VlbXMgdW5saWtlbHkuXG4gICAgICAgIHJlc29sdmVkSW1wb3J0WzBdLnNldFByb2Nlc3NlZChhY3RpdmVDdHgsIGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGRlZmluZWQuc2V0KCdAaW1wb3J0JywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIEBwcm90ZWN0ZWQ7IGRldGVybWluZSB3aGV0aGVyIHRoaXMgc3ViLWNvbnRleHQgaXMgZGVjbGFyaW5nXG4gICAgLy8gYWxsIGl0cyB0ZXJtcyB0byBiZSBcInByb3RlY3RlZFwiIChleGNlcHRpb25zIGNhbiBiZSBtYWRlIG9uIGFcbiAgICAvLyBwZXItZGVmaW5pdGlvbiBiYXNpcylcbiAgICBkZWZpbmVkLnNldCgnQHByb3RlY3RlZCcsIGN0eFsnQHByb3RlY3RlZCddIHx8IGZhbHNlKTtcblxuICAgIC8vIHByb2Nlc3MgYWxsIG90aGVyIGtleXNcbiAgICBmb3IoY29uc3Qga2V5IGluIGN0eCkge1xuICAgICAgYXBpLmNyZWF0ZVRlcm1EZWZpbml0aW9uKHtcbiAgICAgICAgYWN0aXZlQ3R4OiBydmFsLFxuICAgICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgICB0ZXJtOiBrZXksXG4gICAgICAgIGRlZmluZWQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG92ZXJyaWRlUHJvdGVjdGVkXG4gICAgICB9KTtcblxuICAgICAgaWYoX2lzT2JqZWN0KGN0eFtrZXldKSAmJiAnQGNvbnRleHQnIGluIGN0eFtrZXldKSB7XG4gICAgICAgIGNvbnN0IGtleUN0eCA9IGN0eFtrZXldWydAY29udGV4dCddO1xuICAgICAgICBsZXQgcHJvY2VzcyA9IHRydWU7XG4gICAgICAgIGlmKF9pc1N0cmluZyhrZXlDdHgpKSB7XG4gICAgICAgICAgY29uc3QgdXJsID0gcHJlcGVuZEJhc2Uob3B0aW9ucy5iYXNlLCBrZXlDdHgpO1xuICAgICAgICAgIC8vIHRyYWNrIHByb2Nlc3NlZCBjb250ZXh0cyB0byBhdm9pZCBzY29wZWQgY29udGV4dCByZWN1cnNpb25cbiAgICAgICAgICBpZihjeWNsZXMuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHByb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3ljbGVzLmFkZCh1cmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZSBjb250ZXh0IHRvIHZhbGlkYXRlXG4gICAgICAgIGlmKHByb2Nlc3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgYXBpLnByb2Nlc3Moe1xuICAgICAgICAgICAgICBhY3RpdmVDdHg6IHJ2YWwuY2xvbmUoKSxcbiAgICAgICAgICAgICAgbG9jYWxDdHg6IGN0eFtrZXldWydAY29udGV4dCddLFxuICAgICAgICAgICAgICBvdmVycmlkZVByb3RlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgY3ljbGVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGludmFsaWQgc2NvcGVkIGNvbnRleHQuJyxcbiAgICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZCBzY29wZWQgY29udGV4dCcsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY3R4W2tleV1bJ0Bjb250ZXh0J10sXG4gICAgICAgICAgICAgICAgdGVybToga2V5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhY2hlIHByb2Nlc3NlZCByZXN1bHRcbiAgICByZXNvbHZlZENvbnRleHQuc2V0UHJvY2Vzc2VkKGFjdGl2ZUN0eCwge1xuICAgICAgY29udGV4dDogcnZhbCxcbiAgICAgIGV2ZW50c1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXJtIGRlZmluaXRpb24gZHVyaW5nIGNvbnRleHQgcHJvY2Vzc2luZy5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBjdXJyZW50IGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIGxvY2FsQ3R4IHRoZSBsb2NhbCBjb250ZXh0IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB0ZXJtIHRoZSB0ZXJtIGluIHRoZSBsb2NhbCBjb250ZXh0IHRvIGRlZmluZSB0aGUgbWFwcGluZyBmb3IuXG4gKiBAcGFyYW0gZGVmaW5lZCBhIG1hcCBvZiBkZWZpbmluZy9kZWZpbmVkIGtleXMgdG8gZGV0ZWN0IGN5Y2xlcyBhbmQgcHJldmVudFxuICogICAgICAgICAgZG91YmxlIGRlZmluaXRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNyZWF0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3ZlcnJpZGVQcm90ZWN0ZWQgYGZhbHNlYCBhbGxvd3MgcHJvdGVjdGVkIHRlcm1zIHRvIGJlIG1vZGlmaWVkLlxuICovXG5hcGkuY3JlYXRlVGVybURlZmluaXRpb24gPSAoe1xuICBhY3RpdmVDdHgsXG4gIGxvY2FsQ3R4LFxuICB0ZXJtLFxuICBkZWZpbmVkLFxuICBvcHRpb25zLFxuICBvdmVycmlkZVByb3RlY3RlZCA9IGZhbHNlLFxufSkgPT4ge1xuICBpZihkZWZpbmVkLmhhcyh0ZXJtKSkge1xuICAgIC8vIHRlcm0gYWxyZWFkeSBkZWZpbmVkXG4gICAgaWYoZGVmaW5lZC5nZXQodGVybSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY3ljbGUgZGV0ZWN0ZWRcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnQ3ljbGljYWwgY29udGV4dCBkZWZpbml0aW9uIGRldGVjdGVkLicsXG4gICAgICAnanNvbmxkLkN5Y2xpY2FsQ29udGV4dCcsXG4gICAgICB7Y29kZTogJ2N5Y2xpYyBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gIH1cblxuICAvLyBub3cgZGVmaW5pbmcgdGVybVxuICBkZWZpbmVkLnNldCh0ZXJtLCBmYWxzZSk7XG5cbiAgLy8gZ2V0IGNvbnRleHQgdGVybSB2YWx1ZVxuICBsZXQgdmFsdWU7XG4gIGlmKGxvY2FsQ3R4Lmhhc093blByb3BlcnR5KHRlcm0pKSB7XG4gICAgdmFsdWUgPSBsb2NhbEN0eFt0ZXJtXTtcbiAgfVxuXG4gIGlmKHRlcm0gPT09ICdAdHlwZScgJiZcbiAgICAgX2lzT2JqZWN0KHZhbHVlKSAmJlxuICAgICAodmFsdWVbJ0Bjb250YWluZXInXSB8fCAnQHNldCcpID09PSAnQHNldCcgJiZcbiAgICAgYXBpLnByb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSkge1xuXG4gICAgY29uc3QgdmFsaWRLZXlzID0gWydAY29udGFpbmVyJywgJ0BpZCcsICdAcHJvdGVjdGVkJ107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICBpZihrZXlzLmxlbmd0aCA9PT0gMCB8fCBrZXlzLnNvbWUoayA9PiAhdmFsaWRLZXlzLmluY2x1ZGVzKGspKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsga2V5d29yZHMgY2Fubm90IGJlIG92ZXJyaWRkZW4uJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAna2V5d29yZCByZWRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eCwgdGVybX0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKGFwaS5pc0tleXdvcmQodGVybSkpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsga2V5d29yZHMgY2Fubm90IGJlIG92ZXJyaWRkZW4uJyxcbiAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAge2NvZGU6ICdrZXl3b3JkIHJlZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gIH0gZWxzZSBpZih0ZXJtLm1hdGNoKFJFR0VYX0tFWVdPUkQpKSB7XG4gICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgIGNvZGU6ICdyZXNlcnZlZCB0ZXJtJyxcbiAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnVGVybXMgYmVnaW5uaW5nIHdpdGggXCJAXCIgYXJlICcgK1xuICAgICAgICAgICAgJ3Jlc2VydmVkIGZvciBmdXR1cmUgdXNlIGFuZCBkcm9wcGVkLicsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdGVybVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmKHRlcm0gPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgdGVybSBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nLicsXG4gICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICB9XG5cbiAgLy8ga2VlcCByZWZlcmVuY2UgdG8gcHJldmlvdXMgbWFwcGluZyBmb3IgcG90ZW50aWFsIGBAcHJvdGVjdGVkYCBjaGVja1xuICBjb25zdCBwcmV2aW91c01hcHBpbmcgPSBhY3RpdmVDdHgubWFwcGluZ3MuZ2V0KHRlcm0pO1xuXG4gIC8vIHJlbW92ZSBvbGQgbWFwcGluZ1xuICBpZihhY3RpdmVDdHgubWFwcGluZ3MuaGFzKHRlcm0pKSB7XG4gICAgYWN0aXZlQ3R4Lm1hcHBpbmdzLmRlbGV0ZSh0ZXJtKTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgc2hvcnQtaGFuZCB2YWx1ZSB0byBvYmplY3Qgdy9AaWRcbiAgbGV0IHNpbXBsZVRlcm0gPSBmYWxzZTtcbiAgaWYoX2lzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHNpbXBsZVRlcm0gPSB0cnVlO1xuICAgIHZhbHVlID0geydAaWQnOiB2YWx1ZX07XG4gIH1cblxuICBpZighX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCB0ZXJtIHZhbHVlcyBtdXN0IGJlICcgK1xuICAgICAgJ3N0cmluZ3Mgb3Igb2JqZWN0cy4nLFxuICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICB7Y29kZTogJ2ludmFsaWQgdGVybSBkZWZpbml0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBuZXcgbWFwcGluZ1xuICBjb25zdCBtYXBwaW5nID0ge307XG4gIGFjdGl2ZUN0eC5tYXBwaW5ncy5zZXQodGVybSwgbWFwcGluZyk7XG4gIG1hcHBpbmcucmV2ZXJzZSA9IGZhbHNlO1xuXG4gIC8vIG1ha2Ugc3VyZSB0ZXJtIGRlZmluaXRpb24gb25seSBoYXMgZXhwZWN0ZWQga2V5d29yZHNcbiAgY29uc3QgdmFsaWRLZXlzID0gWydAY29udGFpbmVyJywgJ0BpZCcsICdAbGFuZ3VhZ2UnLCAnQHJldmVyc2UnLCAnQHR5cGUnXTtcblxuICAvLyBKU09OLUxEIDEuMSBzdXBwb3J0XG4gIGlmKGFwaS5wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkpIHtcbiAgICB2YWxpZEtleXMucHVzaChcbiAgICAgICdAY29udGV4dCcsICdAZGlyZWN0aW9uJywgJ0BpbmRleCcsICdAbmVzdCcsICdAcHJlZml4JywgJ0Bwcm90ZWN0ZWQnKTtcbiAgfVxuXG4gIGZvcihjb25zdCBrdyBpbiB2YWx1ZSkge1xuICAgIGlmKCF2YWxpZEtleXMuaW5jbHVkZXMoa3cpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIHRlcm0gZGVmaW5pdGlvbiBtdXN0IG5vdCBjb250YWluICcgKyBrdyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFsd2F5cyBjb21wdXRlIHdoZXRoZXIgdGVybSBoYXMgYSBjb2xvbiBhcyBhbiBvcHRpbWl6YXRpb24gZm9yXG4gIC8vIF9jb21wYWN0SXJpXG4gIGNvbnN0IGNvbG9uID0gdGVybS5pbmRleE9mKCc6Jyk7XG4gIG1hcHBpbmcuX3Rlcm1IYXNDb2xvbiA9IChjb2xvbiA+IDApO1xuXG4gIGlmKCdAcmV2ZXJzZScgaW4gdmFsdWUpIHtcbiAgICBpZignQGlkJyBpbiB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBAcmV2ZXJzZSB0ZXJtIGRlZmluaXRpb24gbXVzdCBub3QgJyArXG4gICAgICAgICdjb250YWluIEBpZC4nLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHJldmVyc2UgcHJvcGVydHknLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZignQG5lc3QnIGluIHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEByZXZlcnNlIHRlcm0gZGVmaW5pdGlvbiBtdXN0IG5vdCAnICtcbiAgICAgICAgJ2NvbnRhaW4gQG5lc3QuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5JywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgY29uc3QgcmV2ZXJzZSA9IHZhbHVlWydAcmV2ZXJzZSddO1xuICAgIGlmKCFfaXNTdHJpbmcocmV2ZXJzZSkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgQGNvbnRleHQgQHJldmVyc2UgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIElSSSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICBpZihyZXZlcnNlLm1hdGNoKFJFR0VYX0tFWVdPUkQpKSB7XG4gICAgICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICBjb2RlOiAncmVzZXJ2ZWQgQHJldmVyc2UgdmFsdWUnLFxuICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdAcmV2ZXJzZSB2YWx1ZXMgYmVnaW5uaW5nIHdpdGggXCJAXCIgYXJlICcgK1xuICAgICAgICAgICAgICAncmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgYW5kIGRyb3BwZWQuJyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgcmV2ZXJzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKHByZXZpb3VzTWFwcGluZykge1xuICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3Muc2V0KHRlcm0sIHByZXZpb3VzTWFwcGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVDdHgubWFwcGluZ3MuZGVsZXRlKHRlcm0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBhbmQgYWRkIEBpZCBtYXBwaW5nXG4gICAgY29uc3QgaWQgPSBfZXhwYW5kSXJpKFxuICAgICAgYWN0aXZlQ3R4LCByZXZlcnNlLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSwgbG9jYWxDdHgsIGRlZmluZWQsXG4gICAgICBvcHRpb25zKTtcbiAgICBpZighX2lzQWJzb2x1dGVJcmkoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEBjb250ZXh0IEByZXZlcnNlIHZhbHVlIG11c3QgYmUgYW4gJyArXG4gICAgICAgICdhYnNvbHV0ZSBJUkkgb3IgYSBibGFuayBub2RlIGlkZW50aWZpZXIuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgbWFwcGluZ1snQGlkJ10gPSBpZDtcbiAgICBtYXBwaW5nLnJldmVyc2UgPSB0cnVlO1xuICB9IGVsc2UgaWYoJ0BpZCcgaW4gdmFsdWUpIHtcbiAgICBsZXQgaWQgPSB2YWx1ZVsnQGlkJ107XG4gICAgaWYoaWQgJiYgIV9pc1N0cmluZyhpZCkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEgQGNvbnRleHQgQGlkIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkgJyArXG4gICAgICAgICdvZiBzdHJpbmdzIG9yIGEgc3RyaW5nLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZihpZCA9PT0gbnVsbCkge1xuICAgICAgLy8gcmVzZXJ2ZSBhIG51bGwgdGVybSwgd2hpY2ggbWF5IGJlIHByb3RlY3RlZFxuICAgICAgbWFwcGluZ1snQGlkJ10gPSBudWxsO1xuICAgIH0gZWxzZSBpZighYXBpLmlzS2V5d29yZChpZCkgJiYgaWQubWF0Y2goUkVHRVhfS0VZV09SRCkpIHtcbiAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgIGNvZGU6ICdyZXNlcnZlZCBAaWQgdmFsdWUnLFxuICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgICdAaWQgdmFsdWVzIGJlZ2lubmluZyB3aXRoIFwiQFwiIGFyZSAnICtcbiAgICAgICAgICAgICAgJ3Jlc2VydmVkIGZvciBmdXR1cmUgdXNlIGFuZCBkcm9wcGVkLicsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYocHJldmlvdXNNYXBwaW5nKSB7XG4gICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5zZXQodGVybSwgcHJldmlvdXNNYXBwaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUN0eC5tYXBwaW5ncy5kZWxldGUodGVybSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmKGlkICE9PSB0ZXJtKSB7XG4gICAgICAvLyBleHBhbmQgYW5kIGFkZCBAaWQgbWFwcGluZ1xuICAgICAgaWQgPSBfZXhwYW5kSXJpKFxuICAgICAgICBhY3RpdmVDdHgsIGlkLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSwgbG9jYWxDdHgsIGRlZmluZWQsIG9wdGlvbnMpO1xuICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKGlkKSAmJiAhYXBpLmlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhIEBjb250ZXh0IEBpZCB2YWx1ZSBtdXN0IGJlIGFuICcgK1xuICAgICAgICAgICdhYnNvbHV0ZSBJUkksIGEgYmxhbmsgbm9kZSBpZGVudGlmaWVyLCBvciBhIGtleXdvcmQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0ZXJtIGhhcyB0aGUgZm9ybSBvZiBhbiBJUkkgaXQgbXVzdCBtYXAgdGhlIHNhbWVcbiAgICAgIGlmKHRlcm0ubWF0Y2goLyg/OjpbXjpdKXxcXC8vKSkge1xuICAgICAgICBjb25zdCB0ZXJtRGVmaW5lZCA9IG5ldyBNYXAoZGVmaW5lZCkuc2V0KHRlcm0sIHRydWUpO1xuICAgICAgICBjb25zdCB0ZXJtSXJpID0gX2V4cGFuZElyaShcbiAgICAgICAgICBhY3RpdmVDdHgsIHRlcm0sIHt2b2NhYjogdHJ1ZSwgYmFzZTogZmFsc2V9LFxuICAgICAgICAgIGxvY2FsQ3R4LCB0ZXJtRGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIGlmKHRlcm1JcmkgIT09IGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IHRlcm0gaW4gZm9ybSBvZiBJUkkgbXVzdCAnICtcbiAgICAgICAgICAgICdleHBhbmQgdG8gZGVmaW5pdGlvbi4nLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgSVJJIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcHBpbmdbJ0BpZCddID0gaWQ7XG4gICAgICAvLyBpbmRpY2F0ZSBpZiB0aGlzIHRlcm0gbWF5IGJlIHVzZWQgYXMgYSBjb21wYWN0IElSSSBwcmVmaXhcbiAgICAgIG1hcHBpbmcuX3ByZWZpeCA9IChzaW1wbGVUZXJtICYmXG4gICAgICAgICFtYXBwaW5nLl90ZXJtSGFzQ29sb24gJiZcbiAgICAgICAgaWQubWF0Y2goL1s6XFwvXFw/I1xcW1xcXUBdJC8pICE9PSBudWxsKTtcbiAgICB9XG4gIH1cblxuICBpZighKCdAaWQnIGluIG1hcHBpbmcpKSB7XG4gICAgLy8gc2VlIGlmIHRoZSB0ZXJtIGhhcyBhIHByZWZpeFxuICAgIGlmKG1hcHBpbmcuX3Rlcm1IYXNDb2xvbikge1xuICAgICAgY29uc3QgcHJlZml4ID0gdGVybS5zdWJzdHIoMCwgY29sb24pO1xuICAgICAgaWYobG9jYWxDdHguaGFzT3duUHJvcGVydHkocHJlZml4KSkge1xuICAgICAgICAvLyBkZWZpbmUgcGFyZW50IHByZWZpeFxuICAgICAgICBhcGkuY3JlYXRlVGVybURlZmluaXRpb24oe1xuICAgICAgICAgIGFjdGl2ZUN0eCwgbG9jYWxDdHgsIHRlcm06IHByZWZpeCwgZGVmaW5lZCwgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYoYWN0aXZlQ3R4Lm1hcHBpbmdzLmhhcyhwcmVmaXgpKSB7XG4gICAgICAgIC8vIHNldCBAaWQgYmFzZWQgb24gcHJlZml4IHBhcmVudFxuICAgICAgICBjb25zdCBzdWZmaXggPSB0ZXJtLnN1YnN0cihjb2xvbiArIDEpO1xuICAgICAgICBtYXBwaW5nWydAaWQnXSA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQocHJlZml4KVsnQGlkJ10gKyBzdWZmaXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZXJtIGlzIGFuIGFic29sdXRlIElSSVxuICAgICAgICBtYXBwaW5nWydAaWQnXSA9IHRlcm07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHRlcm0gPT09ICdAdHlwZScpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSwgd2VyZSB3ZSd2ZSBwcmV2aW91c2x5IGRldGVybWluZWQgdGhhdCBjb250YWluZXIgaXMgQHNldFxuICAgICAgbWFwcGluZ1snQGlkJ10gPSB0ZXJtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub24tSVJJcyAqbXVzdCogZGVmaW5lIEBpZHMgaWYgQHZvY2FiIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgIGlmKCEoJ0B2b2NhYicgaW4gYWN0aXZlQ3R4KSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IHRlcm1zIG11c3QgZGVmaW5lIGFuIEBpZC4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBJUkkgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4LCB0ZXJtfSk7XG4gICAgICB9XG4gICAgICAvLyBwcmVwZW5kIHZvY2FiIHRvIHRlcm1cbiAgICAgIG1hcHBpbmdbJ0BpZCddID0gYWN0aXZlQ3R4WydAdm9jYWInXSArIHRlcm07XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHRlcm0gcHJvdGVjdGlvblxuICBpZih2YWx1ZVsnQHByb3RlY3RlZCddID09PSB0cnVlIHx8XG4gICAgKGRlZmluZWQuZ2V0KCdAcHJvdGVjdGVkJykgPT09IHRydWUgJiYgdmFsdWVbJ0Bwcm90ZWN0ZWQnXSAhPT0gZmFsc2UpKSB7XG4gICAgYWN0aXZlQ3R4LnByb3RlY3RlZFt0ZXJtXSA9IHRydWU7XG4gICAgbWFwcGluZy5wcm90ZWN0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gSVJJIG1hcHBpbmcgbm93IGRlZmluZWRcbiAgZGVmaW5lZC5zZXQodGVybSwgdHJ1ZSk7XG5cbiAgaWYoJ0B0eXBlJyBpbiB2YWx1ZSkge1xuICAgIGxldCB0eXBlID0gdmFsdWVbJ0B0eXBlJ107XG4gICAgaWYoIV9pc1N0cmluZyh0eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gQGNvbnRleHQgQHR5cGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuXG4gICAgaWYoKHR5cGUgPT09ICdAanNvbicgfHwgdHlwZSA9PT0gJ0Bub25lJykpIHtcbiAgICAgIGlmKGFwaS5wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBAY29udGV4dCBAdHlwZSB2YWx1ZSBtdXN0IG5vdCBiZSAnICtcbiAgICAgICAgICBgXCIke3R5cGV9XCIgaW4gSlNPTi1MRCAxLjAgbW9kZS5gLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlICE9PSAnQGlkJyAmJiB0eXBlICE9PSAnQHZvY2FiJykge1xuICAgICAgLy8gZXhwYW5kIEB0eXBlIHRvIGZ1bGwgSVJJXG4gICAgICB0eXBlID0gX2V4cGFuZElyaShcbiAgICAgICAgYWN0aXZlQ3R4LCB0eXBlLCB7dm9jYWI6IHRydWUsIGJhc2U6IGZhbHNlfSwgbG9jYWxDdHgsIGRlZmluZWQsXG4gICAgICAgIG9wdGlvbnMpO1xuICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gQGNvbnRleHQgQHR5cGUgdmFsdWUgbXVzdCBiZSBhbiAnICtcbiAgICAgICAgICAnYWJzb2x1dGUgSVJJLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICB9XG4gICAgICBpZih0eXBlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBAY29udGV4dCBAdHlwZSB2YWx1ZSBtdXN0IGJlIGFuIElSSSwgJyArXG4gICAgICAgICAgJ25vdCBhIGJsYW5rIG5vZGUgaWRlbnRpZmllci4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCB0eXBlIG1hcHBpbmcnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBAdHlwZSB0byBtYXBwaW5nXG4gICAgbWFwcGluZ1snQHR5cGUnXSA9IHR5cGU7XG4gIH1cblxuICBpZignQGNvbnRhaW5lcicgaW4gdmFsdWUpIHtcbiAgICAvLyBub3JtYWxpemUgY29udGFpbmVyIHRvIGFuIGFycmF5IGZvcm1cbiAgICBjb25zdCBjb250YWluZXIgPSBfaXNTdHJpbmcodmFsdWVbJ0Bjb250YWluZXInXSkgP1xuICAgICAgW3ZhbHVlWydAY29udGFpbmVyJ11dIDogKHZhbHVlWydAY29udGFpbmVyJ10gfHwgW10pO1xuICAgIGNvbnN0IHZhbGlkQ29udGFpbmVycyA9IFsnQGxpc3QnLCAnQHNldCcsICdAaW5kZXgnLCAnQGxhbmd1YWdlJ107XG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgIGNvbnN0IGhhc1NldCA9IGNvbnRhaW5lci5pbmNsdWRlcygnQHNldCcpO1xuXG4gICAgLy8gSlNPTi1MRCAxLjEgc3VwcG9ydFxuICAgIGlmKGFwaS5wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkpIHtcbiAgICAgIHZhbGlkQ29udGFpbmVycy5wdXNoKCdAZ3JhcGgnLCAnQGlkJywgJ0B0eXBlJyk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbnRhaW5lciBsZW5ndGhcbiAgICAgIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGxpc3QnKSkge1xuICAgICAgICBpZihjb250YWluZXIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBjb250ZXh0IEBjb250YWluZXIgd2l0aCBAbGlzdCBtdXN0ICcgK1xuICAgICAgICAgICAgJ2hhdmUgbm8gb3RoZXIgdmFsdWVzJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRhaW5lciBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJykpIHtcbiAgICAgICAgaWYoY29udGFpbmVyLnNvbWUoa2V5ID0+XG4gICAgICAgICAga2V5ICE9PSAnQGdyYXBoJyAmJiBrZXkgIT09ICdAaWQnICYmIGtleSAhPT0gJ0BpbmRleCcgJiZcbiAgICAgICAgICBrZXkgIT09ICdAc2V0JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQGNvbnRhaW5lciB3aXRoIEBncmFwaCBtdXN0ICcgK1xuICAgICAgICAgICAgJ2hhdmUgbm8gb3RoZXIgdmFsdWVzIG90aGVyIHRoYW4gQGlkLCBAaW5kZXgsIGFuZCBAc2V0JyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRhaW5lciBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBjb250YWluZXIgbWF5IGFsc28gaW5jbHVkZSBAc2V0XG4gICAgICAgIGlzVmFsaWQgJj0gY29udGFpbmVyLmxlbmd0aCA8PSAoaGFzU2V0ID8gMiA6IDEpO1xuICAgICAgfVxuXG4gICAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0B0eXBlJykpIHtcbiAgICAgICAgLy8gSWYgbWFwcGluZyBkb2VzIG5vdCBoYXZlIGFuIEB0eXBlLFxuICAgICAgICAvLyBzZXQgaXQgdG8gQGlkXG4gICAgICAgIG1hcHBpbmdbJ0B0eXBlJ10gPSBtYXBwaW5nWydAdHlwZSddIHx8ICdAaWQnO1xuXG4gICAgICAgIC8vIHR5cGUgbWFwcGluZyBtdXN0IGJlIGVpdGhlciBAaWQgb3IgQHZvY2FiXG4gICAgICAgIGlmKCFbJ0BpZCcsICdAdm9jYWInXS5pbmNsdWRlcyhtYXBwaW5nWydAdHlwZSddKSkge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBjb250YWluZXI6IEB0eXBlIHJlcXVpcmVzIEB0eXBlIHRvIGJlICcgK1xuICAgICAgICAgICAgJ0BpZCBvciBAdm9jYWIuJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgbWFwcGluZycsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gSlNPTi1MRCAxLjAsIGNvbnRhaW5lciBtdXN0IG5vdCBiZSBhbiBhcnJheSAoaXQgbXVzdCBiZSBhIHN0cmluZyxcbiAgICAgIC8vIHdoaWNoIGlzIG9uZSBvZiB0aGUgdmFsaWRDb250YWluZXJzKVxuICAgICAgaXNWYWxpZCAmPSAhX2lzQXJyYXkodmFsdWVbJ0Bjb250YWluZXInXSk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbnRhaW5lciBsZW5ndGhcbiAgICAgIGlzVmFsaWQgJj0gY29udGFpbmVyLmxlbmd0aCA8PSAxO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGFnYWluc3QgdmFsaWQgY29udGFpbmVyc1xuICAgIGlzVmFsaWQgJj0gY29udGFpbmVyLmV2ZXJ5KGMgPT4gdmFsaWRDb250YWluZXJzLmluY2x1ZGVzKGMpKTtcblxuICAgIC8vIEBzZXQgbm90IGFsbG93ZWQgd2l0aCBAbGlzdFxuICAgIGlzVmFsaWQgJj0gIShoYXNTZXQgJiYgY29udGFpbmVyLmluY2x1ZGVzKCdAbGlzdCcpKTtcblxuICAgIGlmKCFpc1ZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAY29udGFpbmVyIHZhbHVlIG11c3QgYmUgJyArXG4gICAgICAgICdvbmUgb2YgdGhlIGZvbGxvd2luZzogJyArIHZhbGlkQ29udGFpbmVycy5qb2luKCcsICcpLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIGNvbnRhaW5lciBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICBpZihtYXBwaW5nLnJldmVyc2UgJiZcbiAgICAgICFjb250YWluZXIuZXZlcnkoYyA9PiBbJ0BpbmRleCcsICdAc2V0J10uaW5jbHVkZXMoYykpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAY29udGFpbmVyIHZhbHVlIGZvciBhIEByZXZlcnNlICcgK1xuICAgICAgICAndHlwZSBkZWZpbml0aW9uIG11c3QgYmUgQGluZGV4IG9yIEBzZXQuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5JywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgQGNvbnRhaW5lciB0byBtYXBwaW5nXG4gICAgbWFwcGluZ1snQGNvbnRhaW5lciddID0gY29udGFpbmVyO1xuICB9XG5cbiAgLy8gcHJvcGVydHkgaW5kZXhpbmdcbiAgaWYoJ0BpbmRleCcgaW4gdmFsdWUpIHtcbiAgICBpZighKCdAY29udGFpbmVyJyBpbiB2YWx1ZSkgfHwgIW1hcHBpbmdbJ0Bjb250YWluZXInXS5pbmNsdWRlcygnQGluZGV4JykpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IEBpbmRleCB3aXRob3V0IEBpbmRleCBpbiBAY29udGFpbmVyOiAnICtcbiAgICAgICAgYFwiJHt2YWx1ZVsnQGluZGV4J119XCIgb24gdGVybSBcIiR7dGVybX1cIi5gLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIGlmKCFfaXNTdHJpbmcodmFsdWVbJ0BpbmRleCddKSB8fCB2YWx1ZVsnQGluZGV4J10uaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAaW5kZXggbXVzdCBleHBhbmQgdG8gYW4gSVJJOiAnICtcbiAgICAgICAgYFwiJHt2YWx1ZVsnQGluZGV4J119XCIgb24gdGVybSBcIiR7dGVybX1cIi5gLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIHRlcm0gZGVmaW5pdGlvbicsIGNvbnRleHQ6IGxvY2FsQ3R4fSk7XG4gICAgfVxuICAgIG1hcHBpbmdbJ0BpbmRleCddID0gdmFsdWVbJ0BpbmRleCddO1xuICB9XG5cbiAgLy8gc2NvcGVkIGNvbnRleHRzXG4gIGlmKCdAY29udGV4dCcgaW4gdmFsdWUpIHtcbiAgICBtYXBwaW5nWydAY29udGV4dCddID0gdmFsdWVbJ0Bjb250ZXh0J107XG4gIH1cblxuICBpZignQGxhbmd1YWdlJyBpbiB2YWx1ZSAmJiAhKCdAdHlwZScgaW4gdmFsdWUpKSB7XG4gICAgbGV0IGxhbmd1YWdlID0gdmFsdWVbJ0BsYW5ndWFnZSddO1xuICAgIGlmKGxhbmd1YWdlICE9PSBudWxsICYmICFfaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAbGFuZ3VhZ2UgdmFsdWUgbXVzdCBiZSAnICtcbiAgICAgICAgJ2Egc3RyaW5nIG9yIG51bGwuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBsYW5ndWFnZSBtYXBwaW5nJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgQGxhbmd1YWdlIHRvIG1hcHBpbmdcbiAgICBpZihsYW5ndWFnZSAhPT0gbnVsbCkge1xuICAgICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBtYXBwaW5nWydAbGFuZ3VhZ2UnXSA9IGxhbmd1YWdlO1xuICB9XG5cbiAgLy8gdGVybSBtYXkgYmUgdXNlZCBhcyBhIHByZWZpeFxuICBpZignQHByZWZpeCcgaW4gdmFsdWUpIHtcbiAgICBpZih0ZXJtLm1hdGNoKC86fFxcLy8pKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBAcHJlZml4IHVzZWQgb24gYSBjb21wYWN0IElSSSB0ZXJtJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZihhcGkuaXNLZXl3b3JkKG1hcHBpbmdbJ0BpZCddKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsga2V5d29yZHMgbWF5IG5vdCBiZSB1c2VkIGFzIHByZWZpeGVzJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB0ZXJtIGRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgICBpZih0eXBlb2YgdmFsdWVbJ0BwcmVmaXgnXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtYXBwaW5nLl9wcmVmaXggPSB2YWx1ZVsnQHByZWZpeCddID09PSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCB2YWx1ZSBmb3IgQHByZWZpeCBtdXN0IGJlIGJvb2xlYW4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBwcmVmaXggdmFsdWUnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmKCdAZGlyZWN0aW9uJyBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHZhbHVlWydAZGlyZWN0aW9uJ107XG4gICAgaWYoZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gJ2x0cicgJiYgZGlyZWN0aW9uICE9PSAncnRsJykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGRpcmVjdGlvbiB2YWx1ZSBtdXN0IGJlICcgK1xuICAgICAgICAnbnVsbCwgXCJsdHJcIiwgb3IgXCJydGxcIi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIGJhc2UgZGlyZWN0aW9uJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgbWFwcGluZ1snQGRpcmVjdGlvbiddID0gZGlyZWN0aW9uO1xuICB9XG5cbiAgaWYoJ0BuZXN0JyBpbiB2YWx1ZSkge1xuICAgIGNvbnN0IG5lc3QgPSB2YWx1ZVsnQG5lc3QnXTtcbiAgICBpZighX2lzU3RyaW5nKG5lc3QpIHx8IChuZXN0ICE9PSAnQG5lc3QnICYmIG5lc3QuaW5kZXhPZignQCcpID09PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQGNvbnRleHQgQG5lc3QgdmFsdWUgbXVzdCBiZSAnICtcbiAgICAgICAgJ2Egc3RyaW5nIHdoaWNoIGlzIG5vdCBhIGtleXdvcmQgb3RoZXIgdGhhbiBAbmVzdC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBuZXN0IHZhbHVlJywgY29udGV4dDogbG9jYWxDdHh9KTtcbiAgICB9XG4gICAgbWFwcGluZ1snQG5lc3QnXSA9IG5lc3Q7XG4gIH1cblxuICAvLyBkaXNhbGxvdyBhbGlhc2luZyBAY29udGV4dCBhbmQgQHByZXNlcnZlXG4gIGNvbnN0IGlkID0gbWFwcGluZ1snQGlkJ107XG4gIGlmKGlkID09PSAnQGNvbnRleHQnIHx8IGlkID09PSAnQHByZXNlcnZlJykge1xuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBAY29udGV4dCBhbmQgQHByZXNlcnZlIGNhbm5vdCBiZSBhbGlhc2VkLicsXG4gICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGtleXdvcmQgYWxpYXMnLCBjb250ZXh0OiBsb2NhbEN0eH0pO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG92ZXJyaWRpbmcgcHJvdGVjdGVkIHRlcm1zXG4gIGlmKHByZXZpb3VzTWFwcGluZyAmJiBwcmV2aW91c01hcHBpbmcucHJvdGVjdGVkICYmICFvdmVycmlkZVByb3RlY3RlZCkge1xuICAgIC8vIGZvcmNlIG5ldyB0ZXJtIHRvIGNvbnRpbnVlIHRvIGJlIHByb3RlY3RlZCBhbmQgc2VlIGlmIHRoZSBtYXBwaW5ncyB3b3VsZFxuICAgIC8vIGJlIGVxdWFsXG4gICAgYWN0aXZlQ3R4LnByb3RlY3RlZFt0ZXJtXSA9IHRydWU7XG4gICAgbWFwcGluZy5wcm90ZWN0ZWQgPSB0cnVlO1xuICAgIGlmKCFfZGVlcENvbXBhcmUocHJldmlvdXNNYXBwaW5nLCBtYXBwaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgdHJpZWQgdG8gcmVkZWZpbmUgYSBwcm90ZWN0ZWQgdGVybS4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdwcm90ZWN0ZWQgdGVybSByZWRlZmluaXRpb24nLCBjb250ZXh0OiBsb2NhbEN0eCwgdGVybX0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeHBhbmRzIGEgc3RyaW5nIHRvIGEgZnVsbCBJUkkuIFRoZSBzdHJpbmcgbWF5IGJlIGEgdGVybSwgYSBwcmVmaXgsIGFcbiAqIHJlbGF0aXZlIElSSSwgb3IgYW4gYWJzb2x1dGUgSVJJLiBUaGUgYXNzb2NpYXRlZCBhYnNvbHV0ZSBJUkkgd2lsbCBiZVxuICogcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgc3RyaW5nIHRvIGV4cGFuZC5cbiAqIEBwYXJhbSByZWxhdGl2ZVRvIG9wdGlvbnMgZm9yIGhvdyB0byByZXNvbHZlIHJlbGF0aXZlIElSSXM6XG4gKiAgICAgICAgICBiYXNlOiB0cnVlIHRvIHJlc29sdmUgYWdhaW5zdCB0aGUgYmFzZSBJUkksIGZhbHNlIG5vdCB0by5cbiAqICAgICAgICAgIHZvY2FiOiB0cnVlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIEB2b2NhYiwgZmFsc2Ugbm90IHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHByb2Nlc3Npbmcgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBleHBhbmRlZCB2YWx1ZS5cbiAqL1xuYXBpLmV4cGFuZElyaSA9IChhY3RpdmVDdHgsIHZhbHVlLCByZWxhdGl2ZVRvLCBvcHRpb25zKSA9PiB7XG4gIHJldHVybiBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgdmFsdWUsIHJlbGF0aXZlVG8sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeHBhbmRzIGEgc3RyaW5nIHRvIGEgZnVsbCBJUkkuIFRoZSBzdHJpbmcgbWF5IGJlIGEgdGVybSwgYSBwcmVmaXgsIGFcbiAqIHJlbGF0aXZlIElSSSwgb3IgYW4gYWJzb2x1dGUgSVJJLiBUaGUgYXNzb2NpYXRlZCBhYnNvbHV0ZSBJUkkgd2lsbCBiZVxuICogcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSB2YWx1ZSB0aGUgc3RyaW5nIHRvIGV4cGFuZC5cbiAqIEBwYXJhbSByZWxhdGl2ZVRvIG9wdGlvbnMgZm9yIGhvdyB0byByZXNvbHZlIHJlbGF0aXZlIElSSXM6XG4gKiAgICAgICAgICBiYXNlOiB0cnVlIHRvIHJlc29sdmUgYWdhaW5zdCB0aGUgYmFzZSBJUkksIGZhbHNlIG5vdCB0by5cbiAqICAgICAgICAgIHZvY2FiOiB0cnVlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIEB2b2NhYiwgZmFsc2Ugbm90IHRvLlxuICogQHBhcmFtIGxvY2FsQ3R4IHRoZSBsb2NhbCBjb250ZXh0IGJlaW5nIHByb2Nlc3NlZCAob25seSBnaXZlbiBpZiBjYWxsZWRcbiAqICAgICAgICAgIGR1cmluZyBjb250ZXh0IHByb2Nlc3NpbmcpLlxuICogQHBhcmFtIGRlZmluZWQgYSBtYXAgZm9yIHRyYWNraW5nIGN5Y2xlcyBpbiBjb250ZXh0IGRlZmluaXRpb25zIChvbmx5IGdpdmVuXG4gKiAgICAgICAgICBpZiBjYWxsZWQgZHVyaW5nIGNvbnRleHQgcHJvY2Vzc2luZykuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgdmFsdWUsIHJlbGF0aXZlVG8sIGxvY2FsQ3R4LCBkZWZpbmVkLCBvcHRpb25zKSB7XG4gIC8vIGFscmVhZHkgZXhwYW5kZWRcbiAgaWYodmFsdWUgPT09IG51bGwgfHwgIV9pc1N0cmluZyh2YWx1ZSkgfHwgYXBpLmlzS2V5d29yZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBpZ25vcmUgbm9uLWtleXdvcmQgdGhpbmdzIHRoYXQgbG9vayBsaWtlIGEga2V5d29yZFxuICBpZih2YWx1ZS5tYXRjaChSRUdFWF9LRVlXT1JEKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZGVmaW5lIHRlcm0gZGVwZW5kZW5jeSBpZiBub3QgZGVmaW5lZFxuICBpZihsb2NhbEN0eCAmJiBsb2NhbEN0eC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiZcbiAgICBkZWZpbmVkLmdldCh2YWx1ZSkgIT09IHRydWUpIHtcbiAgICBhcGkuY3JlYXRlVGVybURlZmluaXRpb24oe1xuICAgICAgYWN0aXZlQ3R4LCBsb2NhbEN0eCwgdGVybTogdmFsdWUsIGRlZmluZWQsIG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvIHx8IHt9O1xuICBpZihyZWxhdGl2ZVRvLnZvY2FiKSB7XG4gICAgY29uc3QgbWFwcGluZyA9IGFjdGl2ZUN0eC5tYXBwaW5ncy5nZXQodmFsdWUpO1xuXG4gICAgLy8gdmFsdWUgaXMgZXhwbGljaXRseSBpZ25vcmVkIHdpdGggYSBudWxsIG1hcHBpbmdcbiAgICBpZihtYXBwaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZihfaXNPYmplY3QobWFwcGluZykgJiYgJ0BpZCcgaW4gbWFwcGluZykge1xuICAgICAgLy8gdmFsdWUgaXMgYSB0ZXJtXG4gICAgICByZXR1cm4gbWFwcGluZ1snQGlkJ107XG4gICAgfVxuICB9XG5cbiAgLy8gc3BsaXQgdmFsdWUgaW50byBwcmVmaXg6c3VmZml4XG4gIGNvbnN0IGNvbG9uID0gdmFsdWUuaW5kZXhPZignOicpO1xuICBpZihjb2xvbiA+IDApIHtcbiAgICBjb25zdCBwcmVmaXggPSB2YWx1ZS5zdWJzdHIoMCwgY29sb24pO1xuICAgIGNvbnN0IHN1ZmZpeCA9IHZhbHVlLnN1YnN0cihjb2xvbiArIDEpO1xuXG4gICAgLy8gZG8gbm90IGV4cGFuZCBibGFuayBub2RlcyAocHJlZml4IG9mICdfJykgb3IgYWxyZWFkeS1hYnNvbHV0ZVxuICAgIC8vIElSSXMgKHN1ZmZpeCBvZiAnLy8nKVxuICAgIGlmKHByZWZpeCA9PT0gJ18nIHx8IHN1ZmZpeC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gcHJlZml4IGRlcGVuZGVuY3kgbm90IGRlZmluZWQsIGRlZmluZSBpdFxuICAgIGlmKGxvY2FsQ3R4ICYmIGxvY2FsQ3R4Lmhhc093blByb3BlcnR5KHByZWZpeCkpIHtcbiAgICAgIGFwaS5jcmVhdGVUZXJtRGVmaW5pdGlvbih7XG4gICAgICAgIGFjdGl2ZUN0eCwgbG9jYWxDdHgsIHRlcm06IHByZWZpeCwgZGVmaW5lZCwgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gdXNlIG1hcHBpbmcgaWYgcHJlZml4IGlzIGRlZmluZWRcbiAgICBjb25zdCBtYXBwaW5nID0gYWN0aXZlQ3R4Lm1hcHBpbmdzLmdldChwcmVmaXgpO1xuICAgIGlmKG1hcHBpbmcgJiYgbWFwcGluZy5fcHJlZml4KSB7XG4gICAgICByZXR1cm4gbWFwcGluZ1snQGlkJ10gKyBzdWZmaXg7XG4gICAgfVxuXG4gICAgLy8gYWxyZWFkeSBhYnNvbHV0ZSBJUklcbiAgICBpZihfaXNBYnNvbHV0ZUlyaSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBBIGZsYWcgdGhhdCBjYXB0dXJlcyB3aGV0aGVyIHRoZSBpcmkgYmVpbmcgZXhwYW5kZWQgaXNcbiAgLy8gdGhlIHZhbHVlIGZvciBhbiBAdHlwZVxuICAvL2xldCB0eXBlRXhwYW5zaW9uID0gZmFsc2U7XG5cbiAgLy9pZihvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50eXBlRXhwYW5zaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgLy8gIHR5cGVFeHBhbnNpb24gPSBvcHRpb25zLnR5cGVFeHBhbnNpb247XG4gIC8vfVxuXG4gIGlmKHJlbGF0aXZlVG8udm9jYWIgJiYgJ0B2b2NhYicgaW4gYWN0aXZlQ3R4KSB7XG4gICAgLy8gcHJlcGVuZCB2b2NhYlxuICAgIGNvbnN0IHByZXBlbmRlZFJlc3VsdCA9IGFjdGl2ZUN0eFsnQHZvY2FiJ10gKyB2YWx1ZTtcbiAgICAvLyBGSVhNRTogbmVlZGVkPyBtYXkgYmUgYmV0dGVyIGFzIGRlYnVnIGV2ZW50LlxuICAgIC8qXG4gICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgX2hhbmRsZUV2ZW50KHtcbiAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgY29kZTogJ3ByZXBlbmRpbmcgQHZvY2FiIGR1cmluZyBleHBhbnNpb24nLFxuICAgICAgICAgIGxldmVsOiAnaW5mbycsXG4gICAgICAgICAgbWVzc2FnZTogJ1ByZXBlbmRpbmcgQHZvY2FiIGR1cmluZyBleHBhbnNpb24uJyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB0eXBlOiAnQHZvY2FiJyxcbiAgICAgICAgICAgIHZvY2FiOiBhY3RpdmVDdHhbJ0B2b2NhYiddLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZXN1bHQ6IHByZXBlbmRlZFJlc3VsdCxcbiAgICAgICAgICAgIHR5cGVFeHBhbnNpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAqL1xuICAgIC8vIHRoZSBudWxsIGNhc2UgcHJlc2VydmVzIHZhbHVlIGFzIHBvdGVudGlhbGx5IHJlbGF0aXZlXG4gICAgdmFsdWUgPSBwcmVwZW5kZWRSZXN1bHQ7XG4gIH0gZWxzZSBpZihyZWxhdGl2ZVRvLmJhc2UpIHtcbiAgICAvLyBwcmVwZW5kIGJhc2VcbiAgICBsZXQgcHJlcGVuZGVkUmVzdWx0O1xuICAgIGxldCBiYXNlO1xuICAgIGlmKCdAYmFzZScgaW4gYWN0aXZlQ3R4KSB7XG4gICAgICBpZihhY3RpdmVDdHhbJ0BiYXNlJ10pIHtcbiAgICAgICAgYmFzZSA9IHByZXBlbmRCYXNlKG9wdGlvbnMuYmFzZSwgYWN0aXZlQ3R4WydAYmFzZSddKTtcbiAgICAgICAgcHJlcGVuZGVkUmVzdWx0ID0gcHJlcGVuZEJhc2UoYmFzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9IGFjdGl2ZUN0eFsnQGJhc2UnXTtcbiAgICAgICAgcHJlcGVuZGVkUmVzdWx0ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBvcHRpb25zLmJhc2U7XG4gICAgICBwcmVwZW5kZWRSZXN1bHQgPSBwcmVwZW5kQmFzZShvcHRpb25zLmJhc2UsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gRklYTUU6IG5lZWRlZD8gbWF5IGJlIGJldHRlciBhcyBkZWJ1ZyBldmVudC5cbiAgICAvKlxuICAgIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgIGNvZGU6ICdwcmVwZW5kaW5nIEBiYXNlIGR1cmluZyBleHBhbnNpb24nLFxuICAgICAgICAgIGxldmVsOiAnaW5mbycsXG4gICAgICAgICAgbWVzc2FnZTogJ1ByZXBlbmRpbmcgQGJhc2UgZHVyaW5nIGV4cGFuc2lvbi4nLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdAYmFzZScsXG4gICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZXN1bHQ6IHByZXBlbmRlZFJlc3VsdCxcbiAgICAgICAgICAgIHR5cGVFeHBhbnNpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAqL1xuICAgIC8vIHRoZSBudWxsIGNhc2UgcHJlc2VydmVzIHZhbHVlIGFzIHBvdGVudGlhbGx5IHJlbGF0aXZlXG4gICAgdmFsdWUgPSBwcmVwZW5kZWRSZXN1bHQ7XG4gIH1cblxuICAvLyBGSVhNRTogZHVwbGljYXRlPyBuZWVkZWQ/IG1heWJlIGp1c3QgZW5hYmxlIGluIGEgdmVyYm9zZSBkZWJ1ZyBtb2RlXG4gIC8qXG4gIGlmKCFfaXNBYnNvbHV0ZUlyaSh2YWx1ZSkgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgIC8vIGVtaXQgZXZlbnQgaW5kaWNhdGluZyBhIHJlbGF0aXZlIElSSSB3YXMgZm91bmQsIHdoaWNoIGNhbiByZXN1bHQgaW4gaXRcbiAgICAvLyBiZWluZyBkcm9wcGVkIHdoZW4gY29udmVydGluZyB0byBvdGhlciBSREYgcmVwcmVzZW50YXRpb25zXG4gICAgX2hhbmRsZUV2ZW50KHtcbiAgICAgIGV2ZW50OiB7XG4gICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgY29kZTogJ3JlbGF0aXZlIElSSSBhZnRlciBleHBhbnNpb24nLFxuICAgICAgICAvLyBGSVhNRTogd2hhdCBsZXZlbD9cbiAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgbWVzc2FnZTogJ1JlbGF0aXZlIElSSSBhZnRlciBleHBhbnNpb24uJyxcbiAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgIHJlbGF0aXZlSXJpOiB2YWx1ZSxcbiAgICAgICAgICB0eXBlRXhwYW5zaW9uXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gICAgLy8gTk9URTogcmVsYXRpdmUgcmVmZXJlbmNlIGV2ZW50cyBlbWl0dGVkIGF0IGNhbGxpbmcgc2l0ZXMgYXMgbmVlZGVkXG4gIH1cbiAgKi9cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5pdGlhbCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtiYXNlXSB0aGUgZG9jdW1lbnQgYmFzZSBJUkkuXG4gKlxuICogQHJldHVybiB0aGUgaW5pdGlhbCBjb250ZXh0LlxuICovXG5hcGkuZ2V0SW5pdGlhbENvbnRleHQgPSBvcHRpb25zID0+IHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoe3Byb2Nlc3NpbmdNb2RlOiBvcHRpb25zLnByb2Nlc3NpbmdNb2RlfSk7XG4gIGNvbnN0IGNhY2hlZCA9IElOSVRJQUxfQ09OVEVYVF9DQUNIRS5nZXQoa2V5KTtcbiAgaWYoY2FjaGVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuXG4gIGNvbnN0IGluaXRpYWxDb250ZXh0ID0ge1xuICAgIHByb2Nlc3NpbmdNb2RlOiBvcHRpb25zLnByb2Nlc3NpbmdNb2RlLFxuICAgIG1hcHBpbmdzOiBuZXcgTWFwKCksXG4gICAgaW52ZXJzZTogbnVsbCxcbiAgICBnZXRJbnZlcnNlOiBfY3JlYXRlSW52ZXJzZUNvbnRleHQsXG4gICAgY2xvbmU6IF9jbG9uZUFjdGl2ZUNvbnRleHQsXG4gICAgcmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQ6IF9yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCxcbiAgICBwcm90ZWN0ZWQ6IHt9XG4gIH07XG4gIC8vIFRPRE86IGNvbnNpZGVyIHVzaW5nIExSVSBjYWNoZSBpbnN0ZWFkXG4gIGlmKElOSVRJQUxfQ09OVEVYVF9DQUNIRS5zaXplID09PSBJTklUSUFMX0NPTlRFWFRfQ0FDSEVfTUFYX1NJWkUpIHtcbiAgICAvLyBjbGVhciB3aG9sZSBjYWNoZSAtLSBhc3N1bWVzIHNjZW5hcmlvIHdoZXJlIHRoZSBjYWNoZSBmaWxscyBtZWFuc1xuICAgIC8vIHRoZSBjYWNoZSBpc24ndCBiZWluZyB1c2VkIHZlcnkgZWZmaWNpZW50bHkgYW55d2F5XG4gICAgSU5JVElBTF9DT05URVhUX0NBQ0hFLmNsZWFyKCk7XG4gIH1cbiAgSU5JVElBTF9DT05URVhUX0NBQ0hFLnNldChrZXksIGluaXRpYWxDb250ZXh0KTtcbiAgcmV0dXJuIGluaXRpYWxDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gaW52ZXJzZSBjb250ZXh0IGZvciB1c2UgaW4gdGhlIGNvbXBhY3Rpb24gYWxnb3JpdGhtLCBpZlxuICAgKiBub3QgYWxyZWFkeSBnZW5lcmF0ZWQgZm9yIHRoZSBnaXZlbiBhY3RpdmUgY29udGV4dC5cbiAgICpcbiAgICogQHJldHVybiB0aGUgaW52ZXJzZSBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gX2NyZWF0ZUludmVyc2VDb250ZXh0KCkge1xuICAgIGNvbnN0IGFjdGl2ZUN0eCA9IHRoaXM7XG5cbiAgICAvLyBsYXppbHkgY3JlYXRlIGludmVyc2VcbiAgICBpZihhY3RpdmVDdHguaW52ZXJzZSkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUN0eC5pbnZlcnNlO1xuICAgIH1cbiAgICBjb25zdCBpbnZlcnNlID0gYWN0aXZlQ3R4LmludmVyc2UgPSB7fTtcblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgYnVpbGRpbmcgZmFzdCBDVVJJRSBtYXBcbiAgICBjb25zdCBmYXN0Q3VyaWVNYXAgPSBhY3RpdmVDdHguZmFzdEN1cmllTWFwID0ge307XG4gICAgY29uc3QgaXJpc1RvVGVybXMgPSB7fTtcblxuICAgIC8vIGhhbmRsZSBkZWZhdWx0IGxhbmd1YWdlXG4gICAgY29uc3QgZGVmYXVsdExhbmd1YWdlID0gKGFjdGl2ZUN0eFsnQGxhbmd1YWdlJ10gfHwgJ0Bub25lJykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGhhbmRsZSBkZWZhdWx0IGRpcmVjdGlvblxuICAgIGNvbnN0IGRlZmF1bHREaXJlY3Rpb24gPSBhY3RpdmVDdHhbJ0BkaXJlY3Rpb24nXTtcblxuICAgIC8vIGNyZWF0ZSB0ZXJtIHNlbGVjdGlvbnMgZm9yIGVhY2ggbWFwcGluZyBpbiB0aGUgY29udGV4dCwgb3JkZXJlZCBieVxuICAgIC8vIHNob3J0ZXN0IGFuZCB0aGVuIGxleGljb2dyYXBoaWNhbGx5IGxlYXN0XG4gICAgY29uc3QgbWFwcGluZ3MgPSBhY3RpdmVDdHgubWFwcGluZ3M7XG4gICAgY29uc3QgdGVybXMgPSBbLi4ubWFwcGluZ3Mua2V5cygpXS5zb3J0KF9jb21wYXJlU2hvcnRlc3RMZWFzdCk7XG4gICAgZm9yKGNvbnN0IHRlcm0gb2YgdGVybXMpIHtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBtYXBwaW5ncy5nZXQodGVybSk7XG4gICAgICBpZihtYXBwaW5nID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29udGFpbmVyID0gbWFwcGluZ1snQGNvbnRhaW5lciddIHx8ICdAbm9uZSc7XG4gICAgICBjb250YWluZXIgPSBbXS5jb25jYXQoY29udGFpbmVyKS5zb3J0KCkuam9pbignJyk7XG5cbiAgICAgIGlmKG1hcHBpbmdbJ0BpZCddID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIGV2ZXJ5IElSSSBpbiB0aGUgbWFwcGluZ1xuICAgICAgY29uc3QgaWRzID0gX2FzQXJyYXkobWFwcGluZ1snQGlkJ10pO1xuICAgICAgZm9yKGNvbnN0IGlyaSBvZiBpZHMpIHtcbiAgICAgICAgbGV0IGVudHJ5ID0gaW52ZXJzZVtpcmldO1xuICAgICAgICBjb25zdCBpc0tleXdvcmQgPSBhcGkuaXNLZXl3b3JkKGlyaSk7XG5cbiAgICAgICAgaWYoIWVudHJ5KSB7XG4gICAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbnRyeVxuICAgICAgICAgIGludmVyc2VbaXJpXSA9IGVudHJ5ID0ge307XG5cbiAgICAgICAgICBpZighaXNLZXl3b3JkICYmICFtYXBwaW5nLl90ZXJtSGFzQ29sb24pIHtcbiAgICAgICAgICAgIC8vIGluaXQgSVJJIHRvIHRlcm0gbWFwIGFuZCBmYXN0IENVUklFIHByZWZpeGVzXG4gICAgICAgICAgICBpcmlzVG9UZXJtc1tpcmldID0gW3Rlcm1dO1xuICAgICAgICAgICAgY29uc3QgZmFzdEN1cmllRW50cnkgPSB7aXJpLCB0ZXJtczogaXJpc1RvVGVybXNbaXJpXX07XG4gICAgICAgICAgICBpZihpcmlbMF0gaW4gZmFzdEN1cmllTWFwKSB7XG4gICAgICAgICAgICAgIGZhc3RDdXJpZU1hcFtpcmlbMF1dLnB1c2goZmFzdEN1cmllRW50cnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmFzdEN1cmllTWFwW2lyaVswXV0gPSBbZmFzdEN1cmllRW50cnldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCFpc0tleXdvcmQgJiYgIW1hcHBpbmcuX3Rlcm1IYXNDb2xvbikge1xuICAgICAgICAgIC8vIGFkZCBJUkkgdG8gdGVybSBtYXRjaFxuICAgICAgICAgIGlyaXNUb1Rlcm1zW2lyaV0ucHVzaCh0ZXJtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBuZXcgZW50cnlcbiAgICAgICAgaWYoIWVudHJ5W2NvbnRhaW5lcl0pIHtcbiAgICAgICAgICBlbnRyeVtjb250YWluZXJdID0ge1xuICAgICAgICAgICAgJ0BsYW5ndWFnZSc6IHt9LFxuICAgICAgICAgICAgJ0B0eXBlJzoge30sXG4gICAgICAgICAgICAnQGFueSc6IHt9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeSA9IGVudHJ5W2NvbnRhaW5lcl07XG4gICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAYW55J10sICdAbm9uZScpO1xuXG4gICAgICAgIGlmKG1hcHBpbmcucmV2ZXJzZSkge1xuICAgICAgICAgIC8vIHRlcm0gaXMgcHJlZmVycmVkIGZvciB2YWx1ZXMgdXNpbmcgQHJldmVyc2VcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQHR5cGUnXSwgJ0ByZXZlcnNlJyk7XG4gICAgICAgIH0gZWxzZSBpZihtYXBwaW5nWydAdHlwZSddID09PSAnQG5vbmUnKSB7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BhbnknXSwgJ0Bub25lJyk7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCAnQG5vbmUnKTtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQHR5cGUnXSwgJ0Bub25lJyk7XG4gICAgICAgIH0gZWxzZSBpZignQHR5cGUnIGluIG1hcHBpbmcpIHtcbiAgICAgICAgICAvLyB0ZXJtIGlzIHByZWZlcnJlZCBmb3IgdmFsdWVzIHVzaW5nIHNwZWNpZmljIHR5cGVcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQHR5cGUnXSwgbWFwcGluZ1snQHR5cGUnXSk7XG4gICAgICAgIH0gZWxzZSBpZignQGxhbmd1YWdlJyBpbiBtYXBwaW5nICYmICdAZGlyZWN0aW9uJyBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgLy8gdGVybSBpcyBwcmVmZXJyZWQgZm9yIHZhbHVlcyB1c2luZyBzcGVjaWZpYyBsYW5ndWFnZSBhbmQgZGlyZWN0aW9uXG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBtYXBwaW5nWydAbGFuZ3VhZ2UnXTtcbiAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBtYXBwaW5nWydAZGlyZWN0aW9uJ107XG4gICAgICAgICAgaWYobGFuZ3VhZ2UgJiYgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sXG4gICAgICAgICAgICAgIGAke2xhbmd1YWdlfV8ke2RpcmVjdGlvbn1gLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSBpZihsYW5ndWFnZSkge1xuICAgICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCBsYW5ndWFnZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sIGBfJHtkaXJlY3Rpb259YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgJ0BudWxsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoJ0BsYW5ndWFnZScgaW4gbWFwcGluZykge1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSxcbiAgICAgICAgICAgIChtYXBwaW5nWydAbGFuZ3VhZ2UnXSB8fCAnQG51bGwnKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmKCdAZGlyZWN0aW9uJyBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgaWYobWFwcGluZ1snQGRpcmVjdGlvbiddKSB7XG4gICAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQGxhbmd1YWdlJ10sXG4gICAgICAgICAgICAgIGBfJHttYXBwaW5nWydAZGlyZWN0aW9uJ119YCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgJ0Bub25lJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZGVmYXVsdERpcmVjdGlvbikge1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgYF8ke2RlZmF1bHREaXJlY3Rpb259YCk7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCAnQG5vbmUnKTtcbiAgICAgICAgICBfYWRkUHJlZmVycmVkVGVybSh0ZXJtLCBlbnRyeVsnQHR5cGUnXSwgJ0Bub25lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWRkIGVudHJpZXMgZm9yIG5vIHR5cGUgYW5kIG5vIGxhbmd1YWdlXG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0BsYW5ndWFnZSddLCBkZWZhdWx0TGFuZ3VhZ2UpO1xuICAgICAgICAgIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5WydAbGFuZ3VhZ2UnXSwgJ0Bub25lJyk7XG4gICAgICAgICAgX2FkZFByZWZlcnJlZFRlcm0odGVybSwgZW50cnlbJ0B0eXBlJ10sICdAbm9uZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgZmFzdCBDVVJJRSBtYXBcbiAgICBmb3IoY29uc3Qga2V5IGluIGZhc3RDdXJpZU1hcCkge1xuICAgICAgX2J1aWxkSXJpTWFwKGZhc3RDdXJpZU1hcCwga2V5LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW52ZXJzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGEgcmVjdXJzaXZlIGFsZ29yaXRobSB0byBidWlsZCBhIGxvb2t1cCBtYXAgZm9yIHF1aWNrbHkgZmluZGluZ1xuICAgKiBwb3RlbnRpYWwgQ1VSSUVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXJpTWFwIHRoZSBtYXAgdG8gYnVpbGQuXG4gICAqIEBwYXJhbSBrZXkgdGhlIGN1cnJlbnQga2V5IGluIHRoZSBtYXAgdG8gd29yayBvbi5cbiAgICogQHBhcmFtIGlkeCB0aGUgaW5kZXggaW50byB0aGUgSVJJIHRvIGNvbXBhcmUuXG4gICAqL1xuICBmdW5jdGlvbiBfYnVpbGRJcmlNYXAoaXJpTWFwLCBrZXksIGlkeCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBpcmlNYXBba2V5XTtcbiAgICBjb25zdCBuZXh0ID0gaXJpTWFwW2tleV0gPSB7fTtcblxuICAgIGxldCBpcmk7XG4gICAgbGV0IGxldHRlcjtcbiAgICBmb3IoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgaXJpID0gZW50cnkuaXJpO1xuICAgICAgaWYoaWR4ID49IGlyaS5sZW5ndGgpIHtcbiAgICAgICAgbGV0dGVyID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXR0ZXIgPSBpcmlbaWR4XTtcbiAgICAgIH1cbiAgICAgIGlmKGxldHRlciBpbiBuZXh0KSB7XG4gICAgICAgIG5leHRbbGV0dGVyXS5wdXNoKGVudHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRbbGV0dGVyXSA9IFtlbnRyeV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICBpZihrZXkgPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgX2J1aWxkSXJpTWFwKG5leHQsIGtleSwgaWR4ICsgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHRlcm0gZm9yIHRoZSBnaXZlbiBlbnRyeSBpZiBub3QgYWxyZWFkeSBhZGRlZC5cbiAgICpcbiAgICogQHBhcmFtIHRlcm0gdGhlIHRlcm0gdG8gYWRkLlxuICAgKiBAcGFyYW0gZW50cnkgdGhlIGludmVyc2UgY29udGV4dCB0eXBlT3JMYW5ndWFnZSBlbnRyeSB0byBhZGQgdG8uXG4gICAqIEBwYXJhbSB0eXBlT3JMYW5ndWFnZVZhbHVlIHRoZSBrZXkgaW4gdGhlIGVudHJ5IHRvIGFkZCB0by5cbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRQcmVmZXJyZWRUZXJtKHRlcm0sIGVudHJ5LCB0eXBlT3JMYW5ndWFnZVZhbHVlKSB7XG4gICAgaWYoIWVudHJ5Lmhhc093blByb3BlcnR5KHR5cGVPckxhbmd1YWdlVmFsdWUpKSB7XG4gICAgICBlbnRyeVt0eXBlT3JMYW5ndWFnZVZhbHVlXSA9IHRlcm07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyBhbiBhY3RpdmUgY29udGV4dCwgY3JlYXRpbmcgYSBjaGlsZCBhY3RpdmUgY29udGV4dC5cbiAgICpcbiAgICogQHJldHVybiBhIGNsb25lIChjaGlsZCkgb2YgdGhlIGFjdGl2ZSBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gX2Nsb25lQWN0aXZlQ29udGV4dCgpIHtcbiAgICBjb25zdCBjaGlsZCA9IHt9O1xuICAgIGNoaWxkLm1hcHBpbmdzID0gdXRpbC5jbG9uZSh0aGlzLm1hcHBpbmdzKTtcbiAgICBjaGlsZC5jbG9uZSA9IHRoaXMuY2xvbmU7XG4gICAgY2hpbGQuaW52ZXJzZSA9IG51bGw7XG4gICAgY2hpbGQuZ2V0SW52ZXJzZSA9IHRoaXMuZ2V0SW52ZXJzZTtcbiAgICBjaGlsZC5wcm90ZWN0ZWQgPSB1dGlsLmNsb25lKHRoaXMucHJvdGVjdGVkKTtcbiAgICBpZih0aGlzLnByZXZpb3VzQ29udGV4dCkge1xuICAgICAgY2hpbGQucHJldmlvdXNDb250ZXh0ID0gdGhpcy5wcmV2aW91c0NvbnRleHQuY2xvbmUoKTtcbiAgICB9XG4gICAgY2hpbGQucmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQgPSB0aGlzLnJldmVydFRvUHJldmlvdXNDb250ZXh0O1xuICAgIGlmKCdAYmFzZScgaW4gdGhpcykge1xuICAgICAgY2hpbGRbJ0BiYXNlJ10gPSB0aGlzWydAYmFzZSddO1xuICAgIH1cbiAgICBpZignQGxhbmd1YWdlJyBpbiB0aGlzKSB7XG4gICAgICBjaGlsZFsnQGxhbmd1YWdlJ10gPSB0aGlzWydAbGFuZ3VhZ2UnXTtcbiAgICB9XG4gICAgaWYoJ0B2b2NhYicgaW4gdGhpcykge1xuICAgICAgY2hpbGRbJ0B2b2NhYiddID0gdGhpc1snQHZvY2FiJ107XG4gICAgfVxuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXZlcnRzIGFueSB0eXBlLXNjb3BlZCBjb250ZXh0IGluIHRoaXMgYWN0aXZlIGNvbnRleHQgdG8gdGhlIHByZXZpb3VzXG4gICAqIGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBfcmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQoKSB7XG4gICAgaWYoIXRoaXMucHJldmlvdXNDb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldmlvdXNDb250ZXh0LmNsb25lKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBhY3RpdmUgY29udGV4dCBrZXkgYW5kIHR5cGUsIG51bGwgaWYgbm9uZSBpc1xuICogc2V0IG9yIHVuZGVmaW5lZCBpZiBub25lIGlzIHNldCBhbmQgdHlwZSBpcyAnQGNvbnRleHQnLlxuICpcbiAqIEBwYXJhbSBjdHggdGhlIGFjdGl2ZSBjb250ZXh0LlxuICogQHBhcmFtIGtleSB0aGUgY29udGV4dCBrZXkuXG4gKiBAcGFyYW0gW3R5cGVdIHRoZSB0eXBlIG9mIHZhbHVlIHRvIGdldCAoZWc6ICdAaWQnLCAnQHR5cGUnKSwgaWYgbm90XG4gKiAgICAgICAgICBzcGVjaWZpZWQgZ2V0cyB0aGUgZW50aXJlIGVudHJ5IGZvciBhIGtleSwgbnVsbCBpZiBub3QgZm91bmQuXG4gKlxuICogQHJldHVybiB0aGUgdmFsdWUsIG51bGwsIG9yIHVuZGVmaW5lZC5cbiAqL1xuYXBpLmdldENvbnRleHRWYWx1ZSA9IChjdHgsIGtleSwgdHlwZSkgPT4ge1xuICAvLyBpbnZhbGlkIGtleVxuICBpZihrZXkgPT09IG51bGwpIHtcbiAgICBpZih0eXBlID09PSAnQGNvbnRleHQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGdldCBzcGVjaWZpYyBlbnRyeSBpbmZvcm1hdGlvblxuICBpZihjdHgubWFwcGluZ3MuaGFzKGtleSkpIHtcbiAgICBjb25zdCBlbnRyeSA9IGN0eC5tYXBwaW5ncy5nZXQoa2V5KTtcblxuICAgIGlmKF9pc1VuZGVmaW5lZCh0eXBlKSkge1xuICAgICAgLy8gcmV0dXJuIHdob2xlIGVudHJ5XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIGlmKGVudHJ5Lmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAvLyByZXR1cm4gZW50cnkgdmFsdWUgZm9yIHR5cGVcbiAgICAgIHJldHVybiBlbnRyeVt0eXBlXTtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgZGVmYXVsdCBsYW5ndWFnZVxuICBpZih0eXBlID09PSAnQGxhbmd1YWdlJyAmJiB0eXBlIGluIGN0eCkge1xuICAgIHJldHVybiBjdHhbdHlwZV07XG4gIH1cblxuICAvLyBnZXQgZGVmYXVsdCBkaXJlY3Rpb25cbiAgaWYodHlwZSA9PT0gJ0BkaXJlY3Rpb24nICYmIHR5cGUgaW4gY3R4KSB7XG4gICAgcmV0dXJuIGN0eFt0eXBlXTtcbiAgfVxuXG4gIGlmKHR5cGUgPT09ICdAY29udGV4dCcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzaW5nIE1vZGUgY2hlY2suXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY3VycmVudCBhY3RpdmUgY29udGV4dC5cbiAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBzdHJpbmcgb3IgbnVtZXJpYyB2ZXJzaW9uIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gYm9vbGVhbi5cbiAqL1xuYXBpLnByb2Nlc3NpbmdNb2RlID0gKGFjdGl2ZUN0eCwgdmVyc2lvbikgPT4ge1xuICBpZih2ZXJzaW9uLnRvU3RyaW5nKCkgPj0gJzEuMScpIHtcbiAgICByZXR1cm4gIWFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSB8fFxuICAgICAgYWN0aXZlQ3R4LnByb2Nlc3NpbmdNb2RlID49ICdqc29uLWxkLScgKyB2ZXJzaW9uLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFjdGl2ZUN0eC5wcm9jZXNzaW5nTW9kZSA9PT0gJ2pzb24tbGQtMS4wJztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBrZXl3b3JkLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0tleXdvcmQgPSB2ID0+IHtcbiAgaWYoIV9pc1N0cmluZyh2KSB8fCB2WzBdICE9PSAnQCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3dpdGNoKHYpIHtcbiAgICBjYXNlICdAYmFzZSc6XG4gICAgY2FzZSAnQGNvbnRhaW5lcic6XG4gICAgY2FzZSAnQGNvbnRleHQnOlxuICAgIGNhc2UgJ0BkZWZhdWx0JzpcbiAgICBjYXNlICdAZGlyZWN0aW9uJzpcbiAgICBjYXNlICdAZW1iZWQnOlxuICAgIGNhc2UgJ0BleHBsaWNpdCc6XG4gICAgY2FzZSAnQGdyYXBoJzpcbiAgICBjYXNlICdAaWQnOlxuICAgIGNhc2UgJ0BpbmNsdWRlZCc6XG4gICAgY2FzZSAnQGluZGV4JzpcbiAgICBjYXNlICdAanNvbic6XG4gICAgY2FzZSAnQGxhbmd1YWdlJzpcbiAgICBjYXNlICdAbGlzdCc6XG4gICAgY2FzZSAnQG5lc3QnOlxuICAgIGNhc2UgJ0Bub25lJzpcbiAgICBjYXNlICdAb21pdERlZmF1bHQnOlxuICAgIGNhc2UgJ0BwcmVmaXgnOlxuICAgIGNhc2UgJ0BwcmVzZXJ2ZSc6XG4gICAgY2FzZSAnQHByb3RlY3RlZCc6XG4gICAgY2FzZSAnQHJlcXVpcmVBbGwnOlxuICAgIGNhc2UgJ0ByZXZlcnNlJzpcbiAgICBjYXNlICdAc2V0JzpcbiAgICBjYXNlICdAdHlwZSc6XG4gICAgY2FzZSAnQHZhbHVlJzpcbiAgICBjYXNlICdAdmVyc2lvbic6XG4gICAgY2FzZSAnQHZvY2FiJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIF9kZWVwQ29tcGFyZSh4MSwgeDIpIHtcbiAgLy8gY29tcGFyZSBgbnVsbGAgb3IgcHJpbWl0aXZlIHR5cGVzIGRpcmVjdGx5XG4gIGlmKCghKHgxICYmIHR5cGVvZiB4MSA9PT0gJ29iamVjdCcpKSB8fFxuICAgICAoISh4MiAmJiB0eXBlb2YgeDIgPT09ICdvYmplY3QnKSkpIHtcbiAgICByZXR1cm4geDEgPT09IHgyO1xuICB9XG4gIC8vIHgxIGFuZCB4MiBhcmUgb2JqZWN0cyAoYWxzbyBwb3RlbnRpYWxseSBhcnJheXMpXG4gIGNvbnN0IHgxQXJyYXkgPSBBcnJheS5pc0FycmF5KHgxKTtcbiAgaWYoeDFBcnJheSAhPT0gQXJyYXkuaXNBcnJheSh4MikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYoeDFBcnJheSkge1xuICAgIGlmKHgxLmxlbmd0aCAhPT0geDIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCB4MS5sZW5ndGg7ICsraSkge1xuICAgICAgaWYoIV9kZWVwQ29tcGFyZSh4MVtpXSwgeDJbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8geDEgYW5kIHgyIGFyZSBub24tYXJyYXkgb2JqZWN0c1xuICBjb25zdCBrMXMgPSBPYmplY3Qua2V5cyh4MSk7XG4gIGNvbnN0IGsycyA9IE9iamVjdC5rZXlzKHgyKTtcbiAgaWYoazFzLmxlbmd0aCAhPT0gazJzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IoY29uc3QgazEgaW4geDEpIHtcbiAgICBsZXQgdjEgPSB4MVtrMV07XG4gICAgbGV0IHYyID0geDJbazFdO1xuICAgIC8vIHNwZWNpYWwgY2FzZTogYEBjb250YWluZXJgIGNhbiBiZSBpbiBhbnkgb3JkZXJcbiAgICBpZihrMSA9PT0gJ0Bjb250YWluZXInKSB7XG4gICAgICBpZihBcnJheS5pc0FycmF5KHYxKSAmJiBBcnJheS5pc0FycmF5KHYyKSkge1xuICAgICAgICB2MSA9IHYxLnNsaWNlKCkuc29ydCgpO1xuICAgICAgICB2MiA9IHYyLnNsaWNlKCkuc29ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZighX2RlZXBDb21wYXJlKHYxLCB2MikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/context.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/documentLoaders/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsonld/lib/documentLoaders/node.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst https = __webpack_require__(/*! https */ \"https\");\nconst {parseLinkHeader, buildHeaders} = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\nconst {LINK_HEADER_CONTEXT} = __webpack_require__(/*! ../constants */ \"(ssr)/./node_modules/jsonld/lib/constants.js\");\nconst JsonLdError = __webpack_require__(/*! ../JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\nconst RequestQueue = __webpack_require__(/*! ../RequestQueue */ \"(ssr)/./node_modules/jsonld/lib/RequestQueue.js\");\nconst {prependBase} = __webpack_require__(/*! ../url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\nconst {httpClient} = __webpack_require__(/*! @digitalbazaar/http-client */ \"(ssr)/./node_modules/@digitalbazaar/http-client/dist/cjs/index.cjs\");\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          [secure]: require all URLs to use HTTPS. (default: false)\n *          [strictSSL]: true to require SSL certificates to be valid,\n *            false not to. (default: true)\n *          [maxRedirects]: the maximum number of redirects to permit.\n *            (default: none)\n *          [headers]: an object (map) of headers which will be passed as\n *            request headers for the requested document. Accept is not\n *            allowed. (default: none).\n *          [httpAgent]: a Node.js `http.Agent` to use with 'http' requests.\n *            (default: none)\n *          [httpsAgent]: a Node.js `https.Agent` to use with 'https' requests.\n *            (default: An agent with rejectUnauthorized to the strictSSL\n *            value)\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  headers = {},\n  httpAgent,\n  httpsAgent\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // if no default user-agent header, copy headers and set one\n  if(!('user-agent' in headers)) {\n    headers = Object.assign({}, headers, {\n      'user-agent': 'jsonld.js'\n    });\n  }\n  const http = __webpack_require__(/*! http */ \"http\");\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    const isHttp = url.startsWith('http:');\n    const isHttps = url.startsWith('https:');\n    if(!isHttp && !isHttps) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && !isHttps) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let alternate = null;\n\n    const {res, body} = await _fetch({\n      url, headers, strictSSL, httpAgent, httpsAgent\n    });\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.status];\n    if(res.status >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${statusText}`,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.status\n        });\n    }\n    const link = res.headers.get('link');\n    let location = res.headers.get('location');\n    const contentType = res.headers.get('content-type');\n\n    // handle Link Header\n    if(link && contentType !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeaders = parseLinkHeader(link);\n      const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];\n      if(Array.isArray(linkedContext)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkedContext) {\n        doc.contextUrl = linkedContext.target;\n      }\n\n      // \"alternate\" link header is a redirect\n      alternate = linkHeaders.alternate;\n      if(alternate &&\n        alternate.type == 'application/ld+json' &&\n        !(contentType || '')\n          .match(/^application\\/(\\w*\\+)?json$/)) {\n        location = prependBase(url, alternate.target);\n      }\n    }\n\n    // handle redirect\n    if((alternate ||\n      res.status >= 300 && res.status < 400) && location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.status,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.status,\n            redirects\n          });\n      }\n      redirects.push(url);\n      // location can be relative, turn into full url\n      const nextUrl = new URL(location, url).href;\n      return loadDocument(nextUrl, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nasync function _fetch({url, headers, strictSSL, httpAgent, httpsAgent}) {\n  try {\n    const options = {\n      headers,\n      redirect: 'manual',\n      // ky specific to avoid redirects throwing\n      throwHttpErrors: false\n    };\n    const isHttps = url.startsWith('https:');\n    if(isHttps) {\n      options.agent =\n        httpsAgent || new https.Agent({rejectUnauthorized: strictSSL});\n    } else {\n      if(httpAgent) {\n        options.agent = httpAgent;\n      }\n    }\n    const res = await httpClient.get(url, options);\n    return {res, body: res.data};\n  } catch(e) {\n    // HTTP errors have a response in them\n    // ky considers redirects HTTP errors\n    if(e.response) {\n      return {res: e.response, body: null};\n    }\n    throw new JsonLdError(\n      'URL could not be dereferenced, an error occurred.',\n      'jsonld.LoadDocumentError',\n      {code: 'loading document failed', url, cause: e});\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9kb2N1bWVudExvYWRlcnMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsT0FBTywrQkFBK0IsRUFBRSxtQkFBTyxDQUFDLHdEQUFTO0FBQ3pELE9BQU8scUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUNwRCxvQkFBb0IsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsd0VBQWlCO0FBQzlDLE9BQU8sYUFBYSxFQUFFLG1CQUFPLENBQUMsc0RBQVE7QUFDdEMsT0FBTyxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxzR0FBNEI7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsRUFBRSxHQUFHLCtDQUErQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0JBQU07O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsOEJBQThCLHFDQUFxQztBQUNuRTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLFdBQVc7QUFDdEI7QUFDQSxLQUFLO0FBQ0wsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLCtCQUErQixXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQSxTQUFTLDREQUE0RDtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhCQUE4QjtBQUNyRSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQ0FBK0M7QUFDdEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbGliL2RvY3VtZW50TG9hZGVycy9ub2RlLmpzP2I2ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDIxIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3Qge3BhcnNlTGlua0hlYWRlciwgYnVpbGRIZWFkZXJzfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IHtMSU5LX0hFQURFUl9DT05URVhUfSA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuLi9Kc29uTGRFcnJvcicpO1xuY29uc3QgUmVxdWVzdFF1ZXVlID0gcmVxdWlyZSgnLi4vUmVxdWVzdFF1ZXVlJyk7XG5jb25zdCB7cHJlcGVuZEJhc2V9ID0gcmVxdWlyZSgnLi4vdXJsJyk7XG5jb25zdCB7aHR0cENsaWVudH0gPSByZXF1aXJlKCdAZGlnaXRhbGJhemFhci9odHRwLWNsaWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBidWlsdC1pbiBub2RlIGRvY3VtZW50IGxvYWRlci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbc2VjdXJlXTogcmVxdWlyZSBhbGwgVVJMcyB0byB1c2UgSFRUUFMuIChkZWZhdWx0OiBmYWxzZSlcbiAqICAgICAgICAgIFtzdHJpY3RTU0xdOiB0cnVlIHRvIHJlcXVpcmUgU1NMIGNlcnRpZmljYXRlcyB0byBiZSB2YWxpZCxcbiAqICAgICAgICAgICAgZmFsc2Ugbm90IHRvLiAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIFttYXhSZWRpcmVjdHNdOiB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzIHRvIHBlcm1pdC5cbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IG5vbmUpXG4gKiAgICAgICAgICBbaGVhZGVyc106IGFuIG9iamVjdCAobWFwKSBvZiBoZWFkZXJzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGFzXG4gKiAgICAgICAgICAgIHJlcXVlc3QgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3RlZCBkb2N1bWVudC4gQWNjZXB0IGlzIG5vdFxuICogICAgICAgICAgICBhbGxvd2VkLiAoZGVmYXVsdDogbm9uZSkuXG4gKiAgICAgICAgICBbaHR0cEFnZW50XTogYSBOb2RlLmpzIGBodHRwLkFnZW50YCB0byB1c2Ugd2l0aCAnaHR0cCcgcmVxdWVzdHMuXG4gKiAgICAgICAgICAgIChkZWZhdWx0OiBub25lKVxuICogICAgICAgICAgW2h0dHBzQWdlbnRdOiBhIE5vZGUuanMgYGh0dHBzLkFnZW50YCB0byB1c2Ugd2l0aCAnaHR0cHMnIHJlcXVlc3RzLlxuICogICAgICAgICAgICAoZGVmYXVsdDogQW4gYWdlbnQgd2l0aCByZWplY3RVbmF1dGhvcml6ZWQgdG8gdGhlIHN0cmljdFNTTFxuICogICAgICAgICAgICB2YWx1ZSlcbiAqXG4gKiBAcmV0dXJuIHRoZSBub2RlIGRvY3VtZW50IGxvYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoe1xuICBzZWN1cmUsXG4gIHN0cmljdFNTTCA9IHRydWUsXG4gIG1heFJlZGlyZWN0cyA9IC0xLFxuICBoZWFkZXJzID0ge30sXG4gIGh0dHBBZ2VudCxcbiAgaHR0cHNBZ2VudFxufSA9IHtzdHJpY3RTU0w6IHRydWUsIG1heFJlZGlyZWN0czogLTEsIGhlYWRlcnM6IHt9fSkgPT4ge1xuICBoZWFkZXJzID0gYnVpbGRIZWFkZXJzKGhlYWRlcnMpO1xuICAvLyBpZiBubyBkZWZhdWx0IHVzZXItYWdlbnQgaGVhZGVyLCBjb3B5IGhlYWRlcnMgYW5kIHNldCBvbmVcbiAgaWYoISgndXNlci1hZ2VudCcgaW4gaGVhZGVycykpIHtcbiAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZGVycywge1xuICAgICAgJ3VzZXItYWdlbnQnOiAnanNvbmxkLmpzJ1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbiAgY29uc3QgcXVldWUgPSBuZXcgUmVxdWVzdFF1ZXVlKCk7XG4gIHJldHVybiBxdWV1ZS53cmFwTG9hZGVyKGZ1bmN0aW9uKHVybCkge1xuICAgIHJldHVybiBsb2FkRG9jdW1lbnQodXJsLCBbXSk7XG4gIH0pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvYWREb2N1bWVudCh1cmwsIHJlZGlyZWN0cykge1xuICAgIGNvbnN0IGlzSHR0cCA9IHVybC5zdGFydHNXaXRoKCdodHRwOicpO1xuICAgIGNvbnN0IGlzSHR0cHMgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Jyk7XG4gICAgaWYoIWlzSHR0cCAmJiAhaXNIdHRwcykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ7IG9ubHkgXCJodHRwXCIgYW5kIFwiaHR0cHNcIiBVUkxzIGFyZSAnICtcbiAgICAgICAgJ3N1cHBvcnRlZC4nLFxuICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLCB7Y29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJywgdXJsfSk7XG4gICAgfVxuICAgIGlmKHNlY3VyZSAmJiAhaXNIdHRwcykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQ7IHNlY3VyZSBtb2RlIGlzIGVuYWJsZWQgYW5kICcgK1xuICAgICAgICAndGhlIFVSTFxcJ3Mgc2NoZW1lIGlzIG5vdCBcImh0dHBzXCIuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkVXJsJywge2NvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsIHVybH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBkaXNhYmxlIGNhY2hlIHVudGlsIEhUVFAgY2FjaGluZyBpbXBsZW1lbnRlZFxuICAgIGxldCBkb2MgPSBudWxsOy8vY2FjaGUuZ2V0KHVybCk7XG4gICAgaWYoZG9jICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZG9jO1xuICAgIH1cblxuICAgIGxldCBhbHRlcm5hdGUgPSBudWxsO1xuXG4gICAgY29uc3Qge3JlcywgYm9keX0gPSBhd2FpdCBfZmV0Y2goe1xuICAgICAgdXJsLCBoZWFkZXJzLCBzdHJpY3RTU0wsIGh0dHBBZ2VudCwgaHR0cHNBZ2VudFxuICAgIH0pO1xuICAgIGRvYyA9IHtjb250ZXh0VXJsOiBudWxsLCBkb2N1bWVudFVybDogdXJsLCBkb2N1bWVudDogYm9keSB8fCBudWxsfTtcblxuICAgIC8vIGhhbmRsZSBlcnJvclxuICAgIGNvbnN0IHN0YXR1c1RleHQgPSBodHRwLlNUQVRVU19DT0RFU1tyZXMuc3RhdHVzXTtcbiAgICBpZihyZXMuc3RhdHVzID49IDQwMCkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICBgVVJMIFwiJHt1cmx9XCIgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZDogJHtzdGF0dXNUZXh0fWAsXG4gICAgICAgICdqc29ubGQuSW52YWxpZFVybCcsIHtcbiAgICAgICAgICBjb2RlOiAnbG9hZGluZyBkb2N1bWVudCBmYWlsZWQnLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzLnN0YXR1c1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbGluayA9IHJlcy5oZWFkZXJzLmdldCgnbGluaycpO1xuICAgIGxldCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmdldCgnbG9jYXRpb24nKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG5cbiAgICAvLyBoYW5kbGUgTGluayBIZWFkZXJcbiAgICBpZihsaW5rICYmIGNvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vbGQranNvbicpIHtcbiAgICAgIC8vIG9ubHkgMSByZWxhdGVkIGxpbmsgaGVhZGVyIHBlcm1pdHRlZFxuICAgICAgY29uc3QgbGlua0hlYWRlcnMgPSBwYXJzZUxpbmtIZWFkZXIobGluayk7XG4gICAgICBjb25zdCBsaW5rZWRDb250ZXh0ID0gbGlua0hlYWRlcnNbTElOS19IRUFERVJfQ09OVEVYVF07XG4gICAgICBpZihBcnJheS5pc0FycmF5KGxpbmtlZENvbnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnVVJMIGNvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQsIGl0IGhhcyBtb3JlIHRoYW4gb25lIGFzc29jaWF0ZWQgJyArXG4gICAgICAgICAgJ0hUVFAgTGluayBIZWFkZXIuJyxcbiAgICAgICAgICAnanNvbmxkLkludmFsaWRVcmwnLFxuICAgICAgICAgIHtjb2RlOiAnbXVsdGlwbGUgY29udGV4dCBsaW5rIGhlYWRlcnMnLCB1cmx9KTtcbiAgICAgIH1cbiAgICAgIGlmKGxpbmtlZENvbnRleHQpIHtcbiAgICAgICAgZG9jLmNvbnRleHRVcmwgPSBsaW5rZWRDb250ZXh0LnRhcmdldDtcbiAgICAgIH1cblxuICAgICAgLy8gXCJhbHRlcm5hdGVcIiBsaW5rIGhlYWRlciBpcyBhIHJlZGlyZWN0XG4gICAgICBhbHRlcm5hdGUgPSBsaW5rSGVhZGVycy5hbHRlcm5hdGU7XG4gICAgICBpZihhbHRlcm5hdGUgJiZcbiAgICAgICAgYWx0ZXJuYXRlLnR5cGUgPT0gJ2FwcGxpY2F0aW9uL2xkK2pzb24nICYmXG4gICAgICAgICEoY29udGVudFR5cGUgfHwgJycpXG4gICAgICAgICAgLm1hdGNoKC9eYXBwbGljYXRpb25cXC8oXFx3KlxcKyk/anNvbiQvKSkge1xuICAgICAgICBsb2NhdGlvbiA9IHByZXBlbmRCYXNlKHVybCwgYWx0ZXJuYXRlLnRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHJlZGlyZWN0XG4gICAgaWYoKGFsdGVybmF0ZSB8fFxuICAgICAgcmVzLnN0YXR1cyA+PSAzMDAgJiYgcmVzLnN0YXR1cyA8IDQwMCkgJiYgbG9jYXRpb24pIHtcbiAgICAgIGlmKHJlZGlyZWN0cy5sZW5ndGggPT09IG1heFJlZGlyZWN0cykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ1VSTCBjb3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkOyB0aGVyZSB3ZXJlIHRvbyBtYW55IHJlZGlyZWN0cy4nLFxuICAgICAgICAgICdqc29ubGQuVG9vTWFueVJlZGlyZWN0cycsIHtcbiAgICAgICAgICAgIGNvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgIHJlZGlyZWN0c1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYocmVkaXJlY3RzLmluZGV4T2YodXJsKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZDsgaW5maW5pdGUgcmVkaXJlY3Rpb24gd2FzIGRldGVjdGVkLicsXG4gICAgICAgICAgJ2pzb25sZC5JbmZpbml0ZVJlZGlyZWN0RGV0ZWN0ZWQnLCB7XG4gICAgICAgICAgICBjb2RlOiAncmVjdXJzaXZlIGNvbnRleHQgaW5jbHVzaW9uJyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGh0dHBTdGF0dXNDb2RlOiByZXMuc3RhdHVzLFxuICAgICAgICAgICAgcmVkaXJlY3RzXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZWRpcmVjdHMucHVzaCh1cmwpO1xuICAgICAgLy8gbG9jYXRpb24gY2FuIGJlIHJlbGF0aXZlLCB0dXJuIGludG8gZnVsbCB1cmxcbiAgICAgIGNvbnN0IG5leHRVcmwgPSBuZXcgVVJMKGxvY2F0aW9uLCB1cmwpLmhyZWY7XG4gICAgICByZXR1cm4gbG9hZERvY3VtZW50KG5leHRVcmwsIHJlZGlyZWN0cyk7XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgZm9yIGVhY2ggcmVkaXJlY3RlZCBVUkxcbiAgICByZWRpcmVjdHMucHVzaCh1cmwpO1xuICAgIC8vIFRPRE86IGRpc2FibGUgY2FjaGUgdW50aWwgSFRUUCBjYWNoaW5nIGltcGxlbWVudGVkXG4gICAgLypcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmVkaXJlY3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjYWNoZS5zZXQoXG4gICAgICAgIHJlZGlyZWN0c1tpXSxcbiAgICAgICAge2NvbnRleHRVcmw6IG51bGwsIGRvY3VtZW50VXJsOiByZWRpcmVjdHNbaV0sIGRvY3VtZW50OiBib2R5fSk7XG4gICAgfVxuICAgICovXG5cbiAgICByZXR1cm4gZG9jO1xuICB9XG59O1xuXG5hc3luYyBmdW5jdGlvbiBfZmV0Y2goe3VybCwgaGVhZGVycywgc3RyaWN0U1NMLCBodHRwQWdlbnQsIGh0dHBzQWdlbnR9KSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAvLyBreSBzcGVjaWZpYyB0byBhdm9pZCByZWRpcmVjdHMgdGhyb3dpbmdcbiAgICAgIHRocm93SHR0cEVycm9yczogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGlzSHR0cHMgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Jyk7XG4gICAgaWYoaXNIdHRwcykge1xuICAgICAgb3B0aW9ucy5hZ2VudCA9XG4gICAgICAgIGh0dHBzQWdlbnQgfHwgbmV3IGh0dHBzLkFnZW50KHtyZWplY3RVbmF1dGhvcml6ZWQ6IHN0cmljdFNTTH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihodHRwQWdlbnQpIHtcbiAgICAgICAgb3B0aW9ucy5hZ2VudCA9IGh0dHBBZ2VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cENsaWVudC5nZXQodXJsLCBvcHRpb25zKTtcbiAgICByZXR1cm4ge3JlcywgYm9keTogcmVzLmRhdGF9O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBIVFRQIGVycm9ycyBoYXZlIGEgcmVzcG9uc2UgaW4gdGhlbVxuICAgIC8vIGt5IGNvbnNpZGVycyByZWRpcmVjdHMgSFRUUCBlcnJvcnNcbiAgICBpZihlLnJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4ge3JlczogZS5yZXNwb25zZSwgYm9keTogbnVsbH07XG4gICAgfVxuICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICdVUkwgY291bGQgbm90IGJlIGRlcmVmZXJlbmNlZCwgYW4gZXJyb3Igb2NjdXJyZWQuJyxcbiAgICAgICdqc29ubGQuTG9hZERvY3VtZW50RXJyb3InLFxuICAgICAge2NvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsIHVybCwgY2F1c2U6IGV9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/documentLoaders/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/events.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/events.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray\n} = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst {\n  asArray: _asArray\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\n\nconst api = {};\nmodule.exports = api;\n\n// default handler, store as null or an array\n// exposed to allow fast external pre-handleEvent() checks\napi.defaultEventHandler = null;\n\n/**\n * Setup event handler.\n *\n * Return an array event handler constructed from an optional safe mode\n * handler, an optional options event handler, and an optional default handler.\n *\n * @param {object} options - processing options\n *   {function|object|array} [eventHandler] - an event handler.\n *\n * @return an array event handler.\n */\napi.setupEventHandler = ({options = {}}) => {\n  // build in priority order\n  const eventHandler = [].concat(\n    options.safe ? api.safeEventHandler : [],\n    options.eventHandler ? _asArray(options.eventHandler) : [],\n    api.defaultEventHandler ? api.defaultEventHandler : []\n  );\n  // null if no handlers\n  return eventHandler.length === 0 ? null : eventHandler;\n};\n\n/**\n * Handle an event.\n *\n * Top level APIs have a common 'eventHandler' option. This option can be a\n * function, array of functions, object mapping event.code to functions (with a\n * default to call next()), or any combination of such handlers. Handlers will\n * be called with an object with an 'event' entry and a 'next' function. Custom\n * handlers should process the event as appropriate. The 'next()' function\n * should be called to let the next handler process the event.\n *\n * NOTE: Only call this function if options.eventHandler is set and is an\n * array of hanlers. This is an optimization. Callers are expected to check\n * for an event handler before constructing events and calling this function.\n *\n * @param {object} event - event structure:\n *   {string} code - event code\n *   {string} level - severity level, one of: ['warning']\n *   {string} message - human readable message\n *   {object} details - event specific details\n * @param {object} options - processing options\n *   {array} eventHandler - an event handler array.\n */\napi.handleEvent = ({\n  event,\n  options\n}) => {\n  _handle({event, handlers: options.eventHandler});\n};\n\nfunction _handle({event, handlers}) {\n  let doNext = true;\n  for(let i = 0; doNext && i < handlers.length; ++i) {\n    doNext = false;\n    const handler = handlers[i];\n    if(_isArray(handler)) {\n      doNext = _handle({event, handlers: handler});\n    } else if(typeof handler === 'function') {\n      handler({event, next: () => {\n        doNext = true;\n      }});\n    } else if(typeof handler === 'object') {\n      if(event.code in handler) {\n        handler[event.code]({event, next: () => {\n          doNext = true;\n        }});\n      } else {\n        doNext = true;\n      }\n    } else {\n      throw new JsonLdError(\n        'Invalid event handler.',\n        'jsonld.InvalidEventHandler',\n        {event});\n    }\n  }\n  return doNext;\n}\n\nconst _notSafeEventCodes = new Set([\n  'empty object',\n  'free-floating scalar',\n  'invalid @language value',\n  'invalid property',\n  // NOTE: spec edge case\n  'null @id value',\n  'null @value value',\n  'object with only @id',\n  'object with only @language',\n  'object with only @list',\n  'object with only @value',\n  'relative @id reference',\n  'relative @type reference',\n  'relative @vocab reference',\n  'reserved @id value',\n  'reserved @reverse value',\n  'reserved term',\n  // toRDF\n  'blank node predicate',\n  'relative graph reference',\n  'relative object reference',\n  'relative predicate reference',\n  'relative subject reference',\n  // toRDF / fromRDF\n  'rdfDirection not set'\n]);\n\n// safe handler that rejects unsafe warning conditions\napi.safeEventHandler = function safeEventHandler({event, next}) {\n  // fail on all unsafe warnings\n  if(event.level === 'warning' && _notSafeEventCodes.has(event.code)) {\n    throw new JsonLdError(\n      'Safe mode validation error.',\n      'jsonld.ValidationError',\n      {event}\n    );\n  }\n  next();\n};\n\n// logs all events and continues\napi.logEventHandler = function logEventHandler({event, next}) {\n  console.log(`EVENT: ${event.message}`, {event});\n  next();\n};\n\n// log 'warning' level events\napi.logWarningEventHandler = function logWarningEventHandler({event, next}) {\n  if(event.level === 'warning') {\n    console.warn(`WARNING: ${event.message}`, {event});\n  }\n  next();\n};\n\n// fallback to throw errors for any unhandled events\napi.unhandledEventHandler = function unhandledEventHandler({event}) {\n  throw new JsonLdError(\n    'No handler for event.',\n    'jsonld.UnhandledEvent',\n    {event}\n  );\n};\n\n/**\n * Set default event handler.\n *\n * By default, all event are unhandled. It is recommended to pass in an\n * eventHandler into each call. However, this call allows using a default\n * eventHandler when one is not otherwise provided.\n *\n * @param {object} options - default handler options:\n *   {function|object|array} eventHandler - a default event handler.\n *     falsey to unset.\n */\napi.setDefaultEventHandler = function({eventHandler} = {}) {\n  api.defaultEventHandler = eventHandler ? _asArray(eventHandler) : null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9ldmVudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMscUVBQWU7O0FBRTNDO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5REFBUzs7QUFFckI7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVEQUFROztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsTUFBTSx1QkFBdUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsTUFBTSxRQUFRO0FBQ2QsTUFBTSxRQUFRO0FBQ2QsTUFBTSxRQUFRO0FBQ2QsTUFBTSxRQUFRO0FBQ2QsV0FBVyxRQUFRO0FBQ25CLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFdBQVcsc0NBQXNDO0FBQ2pEOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVELHdCQUF3QixjQUFjLElBQUksTUFBTTtBQUNoRDtBQUNBOztBQUVBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSw2QkFBNkIsY0FBYyxJQUFJLE1BQU07QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsTUFBTSx1QkFBdUI7QUFDN0I7QUFDQTtBQUNBLHVDQUF1QyxjQUFjLElBQUk7QUFDekQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbGliL2V2ZW50cy5qcz9iYzZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcblxuY29uc3Qge1xuICBpc0FycmF5OiBfaXNBcnJheVxufSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3Qge1xuICBhc0FycmF5OiBfYXNBcnJheVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vLyBkZWZhdWx0IGhhbmRsZXIsIHN0b3JlIGFzIG51bGwgb3IgYW4gYXJyYXlcbi8vIGV4cG9zZWQgdG8gYWxsb3cgZmFzdCBleHRlcm5hbCBwcmUtaGFuZGxlRXZlbnQoKSBjaGVja3NcbmFwaS5kZWZhdWx0RXZlbnRIYW5kbGVyID0gbnVsbDtcblxuLyoqXG4gKiBTZXR1cCBldmVudCBoYW5kbGVyLlxuICpcbiAqIFJldHVybiBhbiBhcnJheSBldmVudCBoYW5kbGVyIGNvbnN0cnVjdGVkIGZyb20gYW4gb3B0aW9uYWwgc2FmZSBtb2RlXG4gKiBoYW5kbGVyLCBhbiBvcHRpb25hbCBvcHRpb25zIGV2ZW50IGhhbmRsZXIsIGFuZCBhbiBvcHRpb25hbCBkZWZhdWx0IGhhbmRsZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBwcm9jZXNzaW5nIG9wdGlvbnNcbiAqICAge2Z1bmN0aW9ufG9iamVjdHxhcnJheX0gW2V2ZW50SGFuZGxlcl0gLSBhbiBldmVudCBoYW5kbGVyLlxuICpcbiAqIEByZXR1cm4gYW4gYXJyYXkgZXZlbnQgaGFuZGxlci5cbiAqL1xuYXBpLnNldHVwRXZlbnRIYW5kbGVyID0gKHtvcHRpb25zID0ge319KSA9PiB7XG4gIC8vIGJ1aWxkIGluIHByaW9yaXR5IG9yZGVyXG4gIGNvbnN0IGV2ZW50SGFuZGxlciA9IFtdLmNvbmNhdChcbiAgICBvcHRpb25zLnNhZmUgPyBhcGkuc2FmZUV2ZW50SGFuZGxlciA6IFtdLFxuICAgIG9wdGlvbnMuZXZlbnRIYW5kbGVyID8gX2FzQXJyYXkob3B0aW9ucy5ldmVudEhhbmRsZXIpIDogW10sXG4gICAgYXBpLmRlZmF1bHRFdmVudEhhbmRsZXIgPyBhcGkuZGVmYXVsdEV2ZW50SGFuZGxlciA6IFtdXG4gICk7XG4gIC8vIG51bGwgaWYgbm8gaGFuZGxlcnNcbiAgcmV0dXJuIGV2ZW50SGFuZGxlci5sZW5ndGggPT09IDAgPyBudWxsIDogZXZlbnRIYW5kbGVyO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgYW4gZXZlbnQuXG4gKlxuICogVG9wIGxldmVsIEFQSXMgaGF2ZSBhIGNvbW1vbiAnZXZlbnRIYW5kbGVyJyBvcHRpb24uIFRoaXMgb3B0aW9uIGNhbiBiZSBhXG4gKiBmdW5jdGlvbiwgYXJyYXkgb2YgZnVuY3Rpb25zLCBvYmplY3QgbWFwcGluZyBldmVudC5jb2RlIHRvIGZ1bmN0aW9ucyAod2l0aCBhXG4gKiBkZWZhdWx0IHRvIGNhbGwgbmV4dCgpKSwgb3IgYW55IGNvbWJpbmF0aW9uIG9mIHN1Y2ggaGFuZGxlcnMuIEhhbmRsZXJzIHdpbGxcbiAqIGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCB3aXRoIGFuICdldmVudCcgZW50cnkgYW5kIGEgJ25leHQnIGZ1bmN0aW9uLiBDdXN0b21cbiAqIGhhbmRsZXJzIHNob3VsZCBwcm9jZXNzIHRoZSBldmVudCBhcyBhcHByb3ByaWF0ZS4gVGhlICduZXh0KCknIGZ1bmN0aW9uXG4gKiBzaG91bGQgYmUgY2FsbGVkIHRvIGxldCB0aGUgbmV4dCBoYW5kbGVyIHByb2Nlc3MgdGhlIGV2ZW50LlxuICpcbiAqIE5PVEU6IE9ubHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGlmIG9wdGlvbnMuZXZlbnRIYW5kbGVyIGlzIHNldCBhbmQgaXMgYW5cbiAqIGFycmF5IG9mIGhhbmxlcnMuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uLiBDYWxsZXJzIGFyZSBleHBlY3RlZCB0byBjaGVja1xuICogZm9yIGFuIGV2ZW50IGhhbmRsZXIgYmVmb3JlIGNvbnN0cnVjdGluZyBldmVudHMgYW5kIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBldmVudCBzdHJ1Y3R1cmU6XG4gKiAgIHtzdHJpbmd9IGNvZGUgLSBldmVudCBjb2RlXG4gKiAgIHtzdHJpbmd9IGxldmVsIC0gc2V2ZXJpdHkgbGV2ZWwsIG9uZSBvZjogWyd3YXJuaW5nJ11cbiAqICAge3N0cmluZ30gbWVzc2FnZSAtIGh1bWFuIHJlYWRhYmxlIG1lc3NhZ2VcbiAqICAge29iamVjdH0gZGV0YWlscyAtIGV2ZW50IHNwZWNpZmljIGRldGFpbHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gcHJvY2Vzc2luZyBvcHRpb25zXG4gKiAgIHthcnJheX0gZXZlbnRIYW5kbGVyIC0gYW4gZXZlbnQgaGFuZGxlciBhcnJheS5cbiAqL1xuYXBpLmhhbmRsZUV2ZW50ID0gKHtcbiAgZXZlbnQsXG4gIG9wdGlvbnNcbn0pID0+IHtcbiAgX2hhbmRsZSh7ZXZlbnQsIGhhbmRsZXJzOiBvcHRpb25zLmV2ZW50SGFuZGxlcn0pO1xufTtcblxuZnVuY3Rpb24gX2hhbmRsZSh7ZXZlbnQsIGhhbmRsZXJzfSkge1xuICBsZXQgZG9OZXh0ID0gdHJ1ZTtcbiAgZm9yKGxldCBpID0gMDsgZG9OZXh0ICYmIGkgPCBoYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgIGRvTmV4dCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tpXTtcbiAgICBpZihfaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZG9OZXh0ID0gX2hhbmRsZSh7ZXZlbnQsIGhhbmRsZXJzOiBoYW5kbGVyfSk7XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyKHtldmVudCwgbmV4dDogKCkgPT4ge1xuICAgICAgICBkb05leHQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gZWxzZSBpZih0eXBlb2YgaGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmKGV2ZW50LmNvZGUgaW4gaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyW2V2ZW50LmNvZGVdKHtldmVudCwgbmV4dDogKCkgPT4ge1xuICAgICAgICAgIGRvTmV4dCA9IHRydWU7XG4gICAgICAgIH19KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvTmV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgZXZlbnQgaGFuZGxlci4nLFxuICAgICAgICAnanNvbmxkLkludmFsaWRFdmVudEhhbmRsZXInLFxuICAgICAgICB7ZXZlbnR9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRvTmV4dDtcbn1cblxuY29uc3QgX25vdFNhZmVFdmVudENvZGVzID0gbmV3IFNldChbXG4gICdlbXB0eSBvYmplY3QnLFxuICAnZnJlZS1mbG9hdGluZyBzY2FsYXInLFxuICAnaW52YWxpZCBAbGFuZ3VhZ2UgdmFsdWUnLFxuICAnaW52YWxpZCBwcm9wZXJ0eScsXG4gIC8vIE5PVEU6IHNwZWMgZWRnZSBjYXNlXG4gICdudWxsIEBpZCB2YWx1ZScsXG4gICdudWxsIEB2YWx1ZSB2YWx1ZScsXG4gICdvYmplY3Qgd2l0aCBvbmx5IEBpZCcsXG4gICdvYmplY3Qgd2l0aCBvbmx5IEBsYW5ndWFnZScsXG4gICdvYmplY3Qgd2l0aCBvbmx5IEBsaXN0JyxcbiAgJ29iamVjdCB3aXRoIG9ubHkgQHZhbHVlJyxcbiAgJ3JlbGF0aXZlIEBpZCByZWZlcmVuY2UnLFxuICAncmVsYXRpdmUgQHR5cGUgcmVmZXJlbmNlJyxcbiAgJ3JlbGF0aXZlIEB2b2NhYiByZWZlcmVuY2UnLFxuICAncmVzZXJ2ZWQgQGlkIHZhbHVlJyxcbiAgJ3Jlc2VydmVkIEByZXZlcnNlIHZhbHVlJyxcbiAgJ3Jlc2VydmVkIHRlcm0nLFxuICAvLyB0b1JERlxuICAnYmxhbmsgbm9kZSBwcmVkaWNhdGUnLFxuICAncmVsYXRpdmUgZ3JhcGggcmVmZXJlbmNlJyxcbiAgJ3JlbGF0aXZlIG9iamVjdCByZWZlcmVuY2UnLFxuICAncmVsYXRpdmUgcHJlZGljYXRlIHJlZmVyZW5jZScsXG4gICdyZWxhdGl2ZSBzdWJqZWN0IHJlZmVyZW5jZScsXG4gIC8vIHRvUkRGIC8gZnJvbVJERlxuICAncmRmRGlyZWN0aW9uIG5vdCBzZXQnXG5dKTtcblxuLy8gc2FmZSBoYW5kbGVyIHRoYXQgcmVqZWN0cyB1bnNhZmUgd2FybmluZyBjb25kaXRpb25zXG5hcGkuc2FmZUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIHNhZmVFdmVudEhhbmRsZXIoe2V2ZW50LCBuZXh0fSkge1xuICAvLyBmYWlsIG9uIGFsbCB1bnNhZmUgd2FybmluZ3NcbiAgaWYoZXZlbnQubGV2ZWwgPT09ICd3YXJuaW5nJyAmJiBfbm90U2FmZUV2ZW50Q29kZXMuaGFzKGV2ZW50LmNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ1NhZmUgbW9kZSB2YWxpZGF0aW9uIGVycm9yLicsXG4gICAgICAnanNvbmxkLlZhbGlkYXRpb25FcnJvcicsXG4gICAgICB7ZXZlbnR9XG4gICAgKTtcbiAgfVxuICBuZXh0KCk7XG59O1xuXG4vLyBsb2dzIGFsbCBldmVudHMgYW5kIGNvbnRpbnVlc1xuYXBpLmxvZ0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIGxvZ0V2ZW50SGFuZGxlcih7ZXZlbnQsIG5leHR9KSB7XG4gIGNvbnNvbGUubG9nKGBFVkVOVDogJHtldmVudC5tZXNzYWdlfWAsIHtldmVudH0pO1xuICBuZXh0KCk7XG59O1xuXG4vLyBsb2cgJ3dhcm5pbmcnIGxldmVsIGV2ZW50c1xuYXBpLmxvZ1dhcm5pbmdFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiBsb2dXYXJuaW5nRXZlbnRIYW5kbGVyKHtldmVudCwgbmV4dH0pIHtcbiAgaWYoZXZlbnQubGV2ZWwgPT09ICd3YXJuaW5nJykge1xuICAgIGNvbnNvbGUud2FybihgV0FSTklORzogJHtldmVudC5tZXNzYWdlfWAsIHtldmVudH0pO1xuICB9XG4gIG5leHQoKTtcbn07XG5cbi8vIGZhbGxiYWNrIHRvIHRocm93IGVycm9ycyBmb3IgYW55IHVuaGFuZGxlZCBldmVudHNcbmFwaS51bmhhbmRsZWRFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiB1bmhhbmRsZWRFdmVudEhhbmRsZXIoe2V2ZW50fSkge1xuICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgJ05vIGhhbmRsZXIgZm9yIGV2ZW50LicsXG4gICAgJ2pzb25sZC5VbmhhbmRsZWRFdmVudCcsXG4gICAge2V2ZW50fVxuICApO1xufTtcblxuLyoqXG4gKiBTZXQgZGVmYXVsdCBldmVudCBoYW5kbGVyLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGFsbCBldmVudCBhcmUgdW5oYW5kbGVkLiBJdCBpcyByZWNvbW1lbmRlZCB0byBwYXNzIGluIGFuXG4gKiBldmVudEhhbmRsZXIgaW50byBlYWNoIGNhbGwuIEhvd2V2ZXIsIHRoaXMgY2FsbCBhbGxvd3MgdXNpbmcgYSBkZWZhdWx0XG4gKiBldmVudEhhbmRsZXIgd2hlbiBvbmUgaXMgbm90IG90aGVyd2lzZSBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgaGFuZGxlciBvcHRpb25zOlxuICogICB7ZnVuY3Rpb258b2JqZWN0fGFycmF5fSBldmVudEhhbmRsZXIgLSBhIGRlZmF1bHQgZXZlbnQgaGFuZGxlci5cbiAqICAgICBmYWxzZXkgdG8gdW5zZXQuXG4gKi9cbmFwaS5zZXREZWZhdWx0RXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oe2V2ZW50SGFuZGxlcn0gPSB7fSkge1xuICBhcGkuZGVmYXVsdEV2ZW50SGFuZGxlciA9IGV2ZW50SGFuZGxlciA/IF9hc0FycmF5KGV2ZW50SGFuZGxlcikgOiBudWxsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/events.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/expand.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/expand.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\n\nconst {\n  REGEX_BCP47,\n  REGEX_KEYWORD,\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/jsonld/lib/events.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      // FIXME\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'free-floating scalar',\n            level: 'warning',\n            message: 'Dropping free-floating scalar not in a list.',\n            details: {\n              value: element\n              //activeProperty\n              //insideList\n            }\n          },\n          options\n        });\n      }\n      return null;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        // FIXME: add debug event?\n        //unmappedValue: element[i],\n        //activeProperty,\n        //parent: element,\n        //index: i,\n        //expandedParent: rval,\n        //insideList\n\n        // NOTE: no-value events emitted at calling sites as needed\n        continue;\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext\n  });\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and either \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if('@direction' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and either \"@type\" ' +\n        'or either or both \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      // FIXME\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'null @value value',\n            level: 'warning',\n            message: 'Dropping null @value value.',\n            details: {\n              value: rval\n            }\n          },\n          options\n        });\n      }\n      rval = null;\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language\n    // FIXME\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'object with only @language',\n          level: 'warning',\n          message: 'Dropping object with only @language.',\n          details: {\n            value: rval\n          }\n        },\n        options\n      });\n    }\n    rval = null;\n  }\n\n  // drop certain top-level objects that do not occur in lists\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null ||\n      expandedActiveProperty === '@graph' ||\n      (_getContextValue(activeCtx, activeProperty, '@container') || [])\n        .includes('@graph')\n    )) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    rval = _dropUnsafeObject({value: rval, count, options});\n  }\n\n  return rval;\n};\n\n/**\n * Drop empty object, top-level @value/@list, or object with only @id\n *\n * @param value Value to check.\n * @param count Number of properties in object.\n * @param options The expansion options.\n *\n * @return null if dropped, value otherwise.\n */\nfunction _dropUnsafeObject({\n  value,\n  count,\n  options\n}) {\n  if(count === 0 || '@value' in value || '@list' in value ||\n    (count === 1 && '@id' in value)) {\n    // FIXME\n    if(options.eventHandler) {\n      // FIXME: one event or diff event for empty, @v/@l, {@id}?\n      let code;\n      let message;\n      if(count === 0) {\n        code = 'empty object';\n        message = 'Dropping empty object.';\n      } else if('@value' in value) {\n        code = 'object with only @value';\n        message = 'Dropping object with only @value.';\n      } else if('@list' in value) {\n        code = 'object with only @list';\n        message = 'Dropping object with only @list.';\n      } else if(count === 1 && '@id' in value) {\n        code = 'object with only @id';\n        message = 'Dropping object with only @id.';\n      }\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code,\n          level: 'warning',\n          message,\n          details: {\n            value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n  return value;\n}\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, {\n        ...options,\n        typeExpansion: true\n      }) === '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid property',\n            level: 'warning',\n            message: 'Dropping property that did not expand into an ' +\n              'absolute IRI or keyword.',\n            details: {\n              property: key,\n              expandedProperty\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent &&\n         expandedProperty !== '@included' &&\n         expandedProperty !== '@type') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v => {\n          if(_isString(v)) {\n            const ve = _expandIri(activeCtx, v, {base: true}, options);\n            if(options.eventHandler) {\n              if(ve === null) {\n                // NOTE: spec edge case\n                // See https://github.com/w3c/json-ld-api/issues/480\n                if(v === null) {\n                  _handleEvent({\n                    event: {\n                      type: ['JsonLdEvent'],\n                      code: 'null @id value',\n                      level: 'warning',\n                      message: 'Null @id found.',\n                      details: {\n                        id: v\n                      }\n                    },\n                    options\n                  });\n                } else {\n                  // matched KEYWORD regex\n                  _handleEvent({\n                    event: {\n                      type: ['JsonLdEvent'],\n                      code: 'reserved @id value',\n                      level: 'warning',\n                      message: 'Reserved @id found.',\n                      details: {\n                        id: v\n                      }\n                    },\n                    options\n                  });\n                }\n              } else if(!_isAbsoluteIri(ve)) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'relative @id reference',\n                    level: 'warning',\n                    message: 'Relative @id reference found.',\n                    details: {\n                      id: v,\n                      expandedId: ve\n                    }\n                  },\n                  options\n                });\n              }\n            }\n            return ve;\n          }\n          return v;\n        }),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if(_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [\n          _expandIri(typeScopedContext, k, {vocab: true}),\n          _asArray(v).map(vv =>\n            _expandIri(typeScopedContext, vv, {base: true, vocab: true},\n              {...options, typeExpansion: true})\n          )\n        ]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v => {\n          if(_isString(v)) {\n            const ve = _expandIri(typeScopedContext, v,\n              {base: true, vocab: true},\n              {...options, typeExpansion: true});\n            if(ve !== '@json' && !_isAbsoluteIri(ve)) {\n              if(options.eventHandler) {\n                _handleEvent({\n                  event: {\n                    type: ['JsonLdEvent'],\n                    code: 'relative @type reference',\n                    level: 'warning',\n                    message: 'Relative @type reference found.',\n                    details: {\n                      type: v\n                    }\n                  },\n                  options\n                });\n              }\n            }\n            return ve;\n          }\n          return v;\n        }),\n        {propertyIsArray: !!options.isFrame});\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if(expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options\n      }));\n\n      // Expanded values must be node objects\n      if(!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; ' +\n          'values of @included must expand to node objects.',\n          'jsonld.SyntaxError', {code: 'invalid @included value', value});\n      }\n\n      _addValue(\n        expandedParent, '@included', includedResult, {propertyIsArray: true});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for(const language of value) {\n        if(_isString(language) && !language.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if(expandedProperty === '@direction') {\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@direction\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', value});\n      }\n\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for(const dir of value) {\n        if(_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".',\n            'jsonld.SyntaxError',\n            {code: 'invalid base direction', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@direction', value,\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty: '@reverse',\n        element: value,\n        options\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(activeCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = expandedProperty === '@list';\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // FIXME: event?\n      //unmappedValue: value,\n      //expandedProperty,\n      //key,\n      continue;\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are in an array\n      expandedValue = _asArray(expandedValue);\n      if(!options.isFrame) {\n        // drop items if needed\n        expandedValue = expandedValue.filter(v => {\n          const count = Object.keys(v).length;\n          return _dropUnsafeObject({value: v, count, options}) !== null;\n        });\n      }\n      if(expandedValue.length === 0) {\n        // all items dropped, skip adding and continue\n        continue;\n      }\n      // convert to graph\n      expandedValue = expandedValue.map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey\n      });\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true},\n      {...options, typeExpansion: true});\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    const expandedValue = _expandIri(activeCtx, value, {base: true}, options);\n    // NOTE: handle spec edge case and avoid invalid {\"@id\": null}\n    if(expandedValue === null && value.match(REGEX_KEYWORD)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'reserved @id value',\n            level: 'warning',\n            message: 'Reserved @id found.',\n            details: {\n              id: activeProperty\n            }\n          },\n          options\n        });\n      }\n    }\n    return {'@id': expandedValue};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if(direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        if(!key.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language: key\n                }\n              },\n              options\n            });\n          }\n        }\n        val['@language'] = key.toLowerCase();\n      }\n      if(direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap({\n  activeCtx, options, activeProperty, value, asGraph, indexKey, propertyIndex\n}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9leHBhbmQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsb0JBQW9CLG1CQUFPLENBQUMscUVBQWU7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlEQUFTOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUVBQWM7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDZEQUFXOztBQUV2QjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscURBQU87O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdURBQVE7O0FBRXBCO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBVTs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixZQUFZLGVBQWU7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbURBQW1EO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxZQUFZOztBQUU1QztBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0RBQWtEO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSwrQkFBK0IsNENBQTRDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUyxxREFBcUQ7QUFDOUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLCtCQUErQiwyQ0FBMkM7QUFDMUU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sWUFBWTtBQUNuQjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsWUFBWTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxXQUFXLDRDQUE0QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxtQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVMsaUNBQWlDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0EsK0NBQStDLHdCQUF3QjtBQUN2RSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QyxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsU0FBUyxtQ0FBbUM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7O0FBRUE7QUFDQSxzREFBc0Qsc0JBQXNCO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSwrQkFBK0Isb0NBQW9DO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLGlDQUFpQztBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxpQ0FBaUM7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFdBQVcsc0NBQXNDO0FBQ2pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxpQ0FBaUM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlDQUFpQyxzQ0FBc0M7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLGVBQWUsNkRBQTZEO0FBQzVFO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsYUFBYSw2REFBNkQ7QUFDMUU7QUFDQSx1REFBdUQsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsU0FBUywyREFBMkQ7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxXQUFXLHVDQUF1QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBLHlDQUF5QyxXQUFXO0FBQ3BELElBQUk7QUFDSix5Q0FBeUMsd0JBQXdCO0FBQ2pFLE9BQU8sZ0NBQWdDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxXQUFXO0FBQ25FLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcseURBQXlEO0FBQ3BFO0FBQ0EsTUFBTTtBQUNOLGdEQUFnRCxZQUFZO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZXhwYW5kLmpzP2Q1ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuXG5jb25zdCB7XG4gIGlzQXJyYXk6IF9pc0FycmF5LFxuICBpc09iamVjdDogX2lzT2JqZWN0LFxuICBpc0VtcHR5T2JqZWN0OiBfaXNFbXB0eU9iamVjdCxcbiAgaXNTdHJpbmc6IF9pc1N0cmluZyxcbiAgaXNVbmRlZmluZWQ6IF9pc1VuZGVmaW5lZFxufSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3Qge1xuICBpc0xpc3Q6IF9pc0xpc3QsXG4gIGlzVmFsdWU6IF9pc1ZhbHVlLFxuICBpc0dyYXBoOiBfaXNHcmFwaCxcbiAgaXNTdWJqZWN0OiBfaXNTdWJqZWN0XG59ID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5cbmNvbnN0IHtcbiAgZXhwYW5kSXJpOiBfZXhwYW5kSXJpLFxuICBnZXRDb250ZXh0VmFsdWU6IF9nZXRDb250ZXh0VmFsdWUsXG4gIGlzS2V5d29yZDogX2lzS2V5d29yZCxcbiAgcHJvY2VzczogX3Byb2Nlc3NDb250ZXh0LFxuICBwcm9jZXNzaW5nTW9kZTogX3Byb2Nlc3NpbmdNb2RlXG59ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5cbmNvbnN0IHtcbiAgaXNBYnNvbHV0ZTogX2lzQWJzb2x1dGVJcmlcbn0gPSByZXF1aXJlKCcuL3VybCcpO1xuXG5jb25zdCB7XG4gIFJFR0VYX0JDUDQ3LFxuICBSRUdFWF9LRVlXT1JELFxuICBhZGRWYWx1ZTogX2FkZFZhbHVlLFxuICBhc0FycmF5OiBfYXNBcnJheSxcbiAgZ2V0VmFsdWVzOiBfZ2V0VmFsdWVzLFxuICB2YWxpZGF0ZVR5cGVWYWx1ZTogX3ZhbGlkYXRlVHlwZVZhbHVlXG59ID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IHtcbiAgaGFuZGxlRXZlbnQ6IF9oYW5kbGVFdmVudFxufSA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZXhwYW5kcyBhbiBlbGVtZW50IHVzaW5nIHRoZSBnaXZlbiBjb250ZXh0LiBBbnkgY29udGV4dCBpblxuICogdGhlIGVsZW1lbnQgd2lsbCBiZSByZW1vdmVkLiBBbGwgY29udGV4dCBVUkxzIG11c3QgaGF2ZSBiZWVuIHJldHJpZXZlZFxuICogYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIHByb3BlcnR5IGZvciB0aGUgZWxlbWVudCwgbnVsbCBmb3Igbm9uZS5cbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGV4cGFuZC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBleHBhbnNpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBpbnNpZGVMaXN0IHRydWUgaWYgdGhlIGVsZW1lbnQgaXMgYSBsaXN0LCBmYWxzZSBpZiBub3QuXG4gKiBAcGFyYW0gaW5zaWRlSW5kZXggdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnNpZGUgYW4gaW5kZXggY29udGFpbmVyLFxuICogICAgICAgICAgZmFsc2UgaWYgbm90LlxuICogQHBhcmFtIHR5cGVTY29wZWRDb250ZXh0IGFuIG9wdGlvbmFsIHR5cGUtc2NvcGVkIGFjdGl2ZSBjb250ZXh0IGZvclxuICogICAgICAgICAgZXhwYW5kaW5nIHZhbHVlcyBvZiBub2RlcyB0aGF0IHdlcmUgZXhwcmVzc2VkIGFjY29yZGluZyB0b1xuICogICAgICAgICAgYSB0eXBlLXNjb3BlZCBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGV4cGFuZGVkIHZhbHVlLlxuICovXG5hcGkuZXhwYW5kID0gYXN5bmMgKHtcbiAgYWN0aXZlQ3R4LFxuICBhY3RpdmVQcm9wZXJ0eSA9IG51bGwsXG4gIGVsZW1lbnQsXG4gIG9wdGlvbnMgPSB7fSxcbiAgaW5zaWRlTGlzdCA9IGZhbHNlLFxuICBpbnNpZGVJbmRleCA9IGZhbHNlLFxuICB0eXBlU2NvcGVkQ29udGV4dCA9IG51bGxcbn0pID0+IHtcbiAgLy8gbm90aGluZyB0byBleHBhbmRcbiAgaWYoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGRpc2FibGUgZnJhbWluZyBpZiBhY3RpdmVQcm9wZXJ0eSBpcyBAZGVmYXVsdFxuICBpZihhY3RpdmVQcm9wZXJ0eSA9PT0gJ0BkZWZhdWx0Jykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7aXNGcmFtZTogZmFsc2V9KTtcbiAgfVxuXG4gIGlmKCFfaXNBcnJheShlbGVtZW50KSAmJiAhX2lzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgLy8gZHJvcCBmcmVlLWZsb2F0aW5nIHNjYWxhcnMgdGhhdCBhcmUgbm90IGluIGxpc3RzXG4gICAgaWYoIWluc2lkZUxpc3QgJiYgKGFjdGl2ZVByb3BlcnR5ID09PSBudWxsIHx8XG4gICAgICBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHt2b2NhYjogdHJ1ZX0sXG4gICAgICAgIG9wdGlvbnMpID09PSAnQGdyYXBoJykpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICBjb2RlOiAnZnJlZS1mbG9hdGluZyBzY2FsYXInLFxuICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdEcm9wcGluZyBmcmVlLWZsb2F0aW5nIHNjYWxhciBub3QgaW4gYSBsaXN0LicsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50XG4gICAgICAgICAgICAgIC8vYWN0aXZlUHJvcGVydHlcbiAgICAgICAgICAgICAgLy9pbnNpZGVMaXN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZXhwYW5kIGVsZW1lbnQgYWNjb3JkaW5nIHRvIHZhbHVlIGV4cGFuc2lvbiBydWxlc1xuICAgIHJldHVybiBfZXhwYW5kVmFsdWUoe2FjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHZhbHVlOiBlbGVtZW50LCBvcHRpb25zfSk7XG4gIH1cblxuICAvLyByZWN1cnNpdmVseSBleHBhbmQgYXJyYXlcbiAgaWYoX2lzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBsZXQgcnZhbCA9IFtdO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoXG4gICAgICBhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdO1xuICAgIGluc2lkZUxpc3QgPSBpbnNpZGVMaXN0IHx8IGNvbnRhaW5lci5pbmNsdWRlcygnQGxpc3QnKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gZXhwYW5kIGVsZW1lbnRcbiAgICAgIGxldCBlID0gYXdhaXQgYXBpLmV4cGFuZCh7XG4gICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgYWN0aXZlUHJvcGVydHksXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRbaV0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluc2lkZUluZGV4LFxuICAgICAgICB0eXBlU2NvcGVkQ29udGV4dFxuICAgICAgfSk7XG4gICAgICBpZihpbnNpZGVMaXN0ICYmIF9pc0FycmF5KGUpKSB7XG4gICAgICAgIGUgPSB7J0BsaXN0JzogZX07XG4gICAgICB9XG5cbiAgICAgIGlmKGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRklYTUU6IGFkZCBkZWJ1ZyBldmVudD9cbiAgICAgICAgLy91bm1hcHBlZFZhbHVlOiBlbGVtZW50W2ldLFxuICAgICAgICAvL2FjdGl2ZVByb3BlcnR5LFxuICAgICAgICAvL3BhcmVudDogZWxlbWVudCxcbiAgICAgICAgLy9pbmRleDogaSxcbiAgICAgICAgLy9leHBhbmRlZFBhcmVudDogcnZhbCxcbiAgICAgICAgLy9pbnNpZGVMaXN0XG5cbiAgICAgICAgLy8gTk9URTogbm8tdmFsdWUgZXZlbnRzIGVtaXR0ZWQgYXQgY2FsbGluZyBzaXRlcyBhcyBuZWVkZWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmKF9pc0FycmF5KGUpKSB7XG4gICAgICAgIHJ2YWwgPSBydmFsLmNvbmNhdChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwucHVzaChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWw7XG4gIH1cblxuICAvLyByZWN1cnNpdmVseSBleHBhbmQgb2JqZWN0OlxuXG4gIC8vIGZpcnN0LCBleHBhbmQgdGhlIGFjdGl2ZSBwcm9wZXJ0eVxuICBjb25zdCBleHBhbmRlZEFjdGl2ZVByb3BlcnR5ID0gX2V4cGFuZElyaShcbiAgICBhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcblxuICAvLyBHZXQgYW55IHByb3BlcnR5LXNjb3BlZCBjb250ZXh0IGZvciBhY3RpdmVQcm9wZXJ0eVxuICBjb25zdCBwcm9wZXJ0eVNjb3BlZEN0eCA9XG4gICAgX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRleHQnKTtcblxuICAvLyBzZWNvbmQsIGRldGVybWluZSBpZiBhbnkgdHlwZS1zY29wZWQgY29udGV4dCBzaG91bGQgYmUgcmV2ZXJ0ZWQ7IGl0XG4gIC8vIHNob3VsZCBvbmx5IGJlIHJldmVydGVkIHdoZW4gdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gIC8vIDEuIGBlbGVtZW50YCBpcyBub3QgYSB2YWx1ZSBvciBzdWJqZWN0IHJlZmVyZW5jZVxuICAvLyAyLiBgaW5zaWRlSW5kZXhgIGlzIGZhbHNlXG4gIHR5cGVTY29wZWRDb250ZXh0ID0gdHlwZVNjb3BlZENvbnRleHQgfHxcbiAgICAoYWN0aXZlQ3R4LnByZXZpb3VzQ29udGV4dCA/IGFjdGl2ZUN0eCA6IG51bGwpO1xuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQpLnNvcnQoKTtcbiAgbGV0IG11c3RSZXZlcnQgPSAhaW5zaWRlSW5kZXg7XG4gIGlmKG11c3RSZXZlcnQgJiYgdHlwZVNjb3BlZENvbnRleHQgJiYga2V5cy5sZW5ndGggPD0gMiAmJlxuICAgICFrZXlzLmluY2x1ZGVzKCdAY29udGV4dCcpKSB7XG4gICAgZm9yKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBjb25zdCBleHBhbmRlZFByb3BlcnR5ID0gX2V4cGFuZElyaShcbiAgICAgICAgdHlwZVNjb3BlZENvbnRleHQsIGtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHZhbHVlJykge1xuICAgICAgICAvLyB2YWx1ZSBmb3VuZCwgZW5zdXJlIHR5cGUtc2NvcGVkIGNvbnRleHQgaXMgdXNlZCB0byBleHBhbmQgaXRcbiAgICAgICAgbXVzdFJldmVydCA9IGZhbHNlO1xuICAgICAgICBhY3RpdmVDdHggPSB0eXBlU2NvcGVkQ29udGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGlkJyAmJiBrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBzdWJqZWN0IHJlZmVyZW5jZSBmb3VuZCwgZG8gbm90IHJldmVydFxuICAgICAgICBtdXN0UmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmKG11c3RSZXZlcnQpIHtcbiAgICAvLyByZXZlcnQgdHlwZSBzY29wZWQgY29udGV4dFxuICAgIGFjdGl2ZUN0eCA9IGFjdGl2ZUN0eC5yZXZlcnRUb1ByZXZpb3VzQ29udGV4dCgpO1xuICB9XG5cbiAgLy8gYXBwbHkgcHJvcGVydHktc2NvcGVkIGNvbnRleHQgYWZ0ZXIgcmV2ZXJ0aW5nIHRlcm0tc2NvcGVkIGNvbnRleHRcbiAgaWYoIV9pc1VuZGVmaW5lZChwcm9wZXJ0eVNjb3BlZEN0eCkpIHtcbiAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgYWN0aXZlQ3R4LFxuICAgICAgbG9jYWxDdHg6IHByb3BlcnR5U2NvcGVkQ3R4LFxuICAgICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICAvLyBpZiBlbGVtZW50IGhhcyBhIGNvbnRleHQsIHByb2Nlc3MgaXRcbiAgaWYoJ0Bjb250ZXh0JyBpbiBlbGVtZW50KSB7XG4gICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KFxuICAgICAge2FjdGl2ZUN0eCwgbG9jYWxDdHg6IGVsZW1lbnRbJ0Bjb250ZXh0J10sIG9wdGlvbnN9KTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgdHlwZS1zY29wZWQgY29udGV4dCB0byB0aGUgY29udGV4dCBvbiBpbnB1dCwgZm9yIHVzZSBsYXRlclxuICB0eXBlU2NvcGVkQ29udGV4dCA9IGFjdGl2ZUN0eDtcblxuICAvLyBSZW1lbWJlciB0aGUgZmlyc3Qga2V5IGZvdW5kIGV4cGFuZGluZyB0byBAdHlwZVxuICBsZXQgdHlwZUtleSA9IG51bGw7XG5cbiAgLy8gbG9vayBmb3Igc2NvcGVkIGNvbnRleHRzIG9uIGBAdHlwZWBcbiAgZm9yKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgZXhwYW5kZWRQcm9wZXJ0eSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrZXksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgIC8vIHNldCBzY29wZWQgY29udGV4dHMgZnJvbSBAdHlwZVxuICAgICAgLy8gYXZvaWQgc29ydGluZyBpZiBwb3NzaWJsZVxuICAgICAgdHlwZUtleSA9IHR5cGVLZXkgfHwga2V5O1xuICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50W2tleV07XG4gICAgICBjb25zdCB0eXBlcyA9XG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID9cbiAgICAgICAgICAodmFsdWUubGVuZ3RoID4gMSA/IHZhbHVlLnNsaWNlKCkuc29ydCgpIDogdmFsdWUpIDogW3ZhbHVlXTtcbiAgICAgIGZvcihjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IF9nZXRDb250ZXh0VmFsdWUodHlwZVNjb3BlZENvbnRleHQsIHR5cGUsICdAY29udGV4dCcpO1xuICAgICAgICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICAgICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICAgICAgbG9jYWxDdHg6IGN0eCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBwcm9wYWdhdGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBwcm9jZXNzIGVhY2gga2V5IGFuZCB2YWx1ZSBpbiBlbGVtZW50LCBpZ25vcmluZyBAbmVzdCBjb250ZW50XG4gIGxldCBydmFsID0ge307XG4gIGF3YWl0IF9leHBhbmRPYmplY3Qoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICBleHBhbmRlZEFjdGl2ZVByb3BlcnR5LFxuICAgIGVsZW1lbnQsXG4gICAgZXhwYW5kZWRQYXJlbnQ6IHJ2YWwsXG4gICAgb3B0aW9ucyxcbiAgICBpbnNpZGVMaXN0LFxuICAgIHR5cGVLZXksXG4gICAgdHlwZVNjb3BlZENvbnRleHRcbiAgfSk7XG5cbiAgLy8gZ2V0IHByb3BlcnR5IGNvdW50IG9uIGV4cGFuZGVkIG91dHB1dFxuICBrZXlzID0gT2JqZWN0LmtleXMocnZhbCk7XG4gIGxldCBjb3VudCA9IGtleXMubGVuZ3RoO1xuXG4gIGlmKCdAdmFsdWUnIGluIHJ2YWwpIHtcbiAgICAvLyBAdmFsdWUgbXVzdCBvbmx5IGhhdmUgQGxhbmd1YWdlIG9yIEB0eXBlXG4gICAgaWYoJ0B0eXBlJyBpbiBydmFsICYmICgnQGxhbmd1YWdlJyBpbiBydmFsIHx8ICdAZGlyZWN0aW9uJyBpbiBydmFsKSkge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYW4gZWxlbWVudCBjb250YWluaW5nIFwiQHZhbHVlXCIgbWF5IG5vdCAnICtcbiAgICAgICAgJ2NvbnRhaW4gYm90aCBcIkB0eXBlXCIgYW5kIGVpdGhlciBcIkBsYW5ndWFnZVwiIG9yIFwiQGRpcmVjdGlvblwiLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgdmFsdWUgb2JqZWN0JywgZWxlbWVudDogcnZhbH0pO1xuICAgIH1cbiAgICBsZXQgdmFsaWRDb3VudCA9IGNvdW50IC0gMTtcbiAgICBpZignQHR5cGUnIGluIHJ2YWwpIHtcbiAgICAgIHZhbGlkQ291bnQgLT0gMTtcbiAgICB9XG4gICAgaWYoJ0BpbmRleCcgaW4gcnZhbCkge1xuICAgICAgdmFsaWRDb3VudCAtPSAxO1xuICAgIH1cbiAgICBpZignQGxhbmd1YWdlJyBpbiBydmFsKSB7XG4gICAgICB2YWxpZENvdW50IC09IDE7XG4gICAgfVxuICAgIGlmKCdAZGlyZWN0aW9uJyBpbiBydmFsKSB7XG4gICAgICB2YWxpZENvdW50IC09IDE7XG4gICAgfVxuICAgIGlmKHZhbGlkQ291bnQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGFuIGVsZW1lbnQgY29udGFpbmluZyBcIkB2YWx1ZVwiIG1heSBvbmx5ICcgK1xuICAgICAgICAnaGF2ZSBhbiBcIkBpbmRleFwiIHByb3BlcnR5IGFuZCBlaXRoZXIgXCJAdHlwZVwiICcgK1xuICAgICAgICAnb3IgZWl0aGVyIG9yIGJvdGggXCJAbGFuZ3VhZ2VcIiBvciBcIkBkaXJlY3Rpb25cIi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIHZhbHVlIG9iamVjdCcsIGVsZW1lbnQ6IHJ2YWx9KTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gcnZhbFsnQHZhbHVlJ10gPT09IG51bGwgPyBbXSA6IF9hc0FycmF5KHJ2YWxbJ0B2YWx1ZSddKTtcbiAgICBjb25zdCB0eXBlcyA9IF9nZXRWYWx1ZXMocnZhbCwgJ0B0eXBlJyk7XG5cbiAgICAvLyBkcm9wIG51bGwgQHZhbHVlc1xuICAgIGlmKF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkgJiYgdHlwZXMuaW5jbHVkZXMoJ0Bqc29uJykgJiZcbiAgICAgIHR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQW55IHZhbHVlIG9mIEB2YWx1ZSBpcyBva2F5IGlmIEB0eXBlOiBAanNvblxuICAgIH0gZWxzZSBpZih2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGSVhNRVxuICAgICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgICAgX2hhbmRsZUV2ZW50KHtcbiAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgICAgY29kZTogJ251bGwgQHZhbHVlIHZhbHVlJyxcbiAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnRHJvcHBpbmcgbnVsbCBAdmFsdWUgdmFsdWUuJyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJ2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBydmFsID0gbnVsbDtcbiAgICB9IGVsc2UgaWYoIXZhbHVlcy5ldmVyeSh2ID0+IChfaXNTdHJpbmcodikgfHwgX2lzRW1wdHlPYmplY3QodikpKSAmJlxuICAgICAgJ0BsYW5ndWFnZScgaW4gcnZhbCkge1xuICAgICAgLy8gaWYgQGxhbmd1YWdlIGlzIHByZXNlbnQsIEB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nXG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBvbmx5IHN0cmluZ3MgbWF5IGJlIGxhbmd1YWdlLXRhZ2dlZC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAge2NvZGU6ICdpbnZhbGlkIGxhbmd1YWdlLXRhZ2dlZCB2YWx1ZScsIGVsZW1lbnQ6IHJ2YWx9KTtcbiAgICB9IGVsc2UgaWYoIXR5cGVzLmV2ZXJ5KHQgPT5cbiAgICAgIChfaXNBYnNvbHV0ZUlyaSh0KSAmJiAhKF9pc1N0cmluZyh0KSAmJiB0LmluZGV4T2YoJ186JykgPT09IDApIHx8XG4gICAgICBfaXNFbXB0eU9iamVjdCh0KSkpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBhbiBlbGVtZW50IGNvbnRhaW5pbmcgXCJAdmFsdWVcIiBhbmQgXCJAdHlwZVwiICcgK1xuICAgICAgICAnbXVzdCBoYXZlIGFuIGFic29sdXRlIElSSSBmb3IgdGhlIHZhbHVlIG9mIFwiQHR5cGVcIi4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIHR5cGVkIHZhbHVlJywgZWxlbWVudDogcnZhbH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKCdAdHlwZScgaW4gcnZhbCAmJiAhX2lzQXJyYXkocnZhbFsnQHR5cGUnXSkpIHtcbiAgICAvLyBjb252ZXJ0IEB0eXBlIHRvIGFuIGFycmF5XG4gICAgcnZhbFsnQHR5cGUnXSA9IFtydmFsWydAdHlwZSddXTtcbiAgfSBlbHNlIGlmKCdAc2V0JyBpbiBydmFsIHx8ICdAbGlzdCcgaW4gcnZhbCkge1xuICAgIC8vIGhhbmRsZSBAc2V0IGFuZCBAbGlzdFxuICAgIGlmKGNvdW50ID4gMSAmJiAhKGNvdW50ID09PSAyICYmICdAaW5kZXgnIGluIHJ2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpZiBhbiBlbGVtZW50IGhhcyB0aGUgcHJvcGVydHkgXCJAc2V0XCIgJyArXG4gICAgICAgICdvciBcIkBsaXN0XCIsIHRoZW4gaXQgY2FuIGhhdmUgYXQgbW9zdCBvbmUgb3RoZXIgcHJvcGVydHkgdGhhdCBpcyAnICtcbiAgICAgICAgJ1wiQGluZGV4XCIuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCBzZXQgb3IgbGlzdCBvYmplY3QnLCBlbGVtZW50OiBydmFsfSk7XG4gICAgfVxuICAgIC8vIG9wdGltaXplIGF3YXkgQHNldFxuICAgIGlmKCdAc2V0JyBpbiBydmFsKSB7XG4gICAgICBydmFsID0gcnZhbFsnQHNldCddO1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHJ2YWwpO1xuICAgICAgY291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZihjb3VudCA9PT0gMSAmJiAnQGxhbmd1YWdlJyBpbiBydmFsKSB7XG4gICAgLy8gZHJvcCBvYmplY3RzIHdpdGggb25seSBAbGFuZ3VhZ2VcbiAgICAvLyBGSVhNRVxuICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICBldmVudDoge1xuICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICBjb2RlOiAnb2JqZWN0IHdpdGggb25seSBAbGFuZ3VhZ2UnLFxuICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgbWVzc2FnZTogJ0Ryb3BwaW5nIG9iamVjdCB3aXRoIG9ubHkgQGxhbmd1YWdlLicsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdmFsdWU6IHJ2YWxcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBydmFsID0gbnVsbDtcbiAgfVxuXG4gIC8vIGRyb3AgY2VydGFpbiB0b3AtbGV2ZWwgb2JqZWN0cyB0aGF0IGRvIG5vdCBvY2N1ciBpbiBsaXN0c1xuICBpZihfaXNPYmplY3QocnZhbCkgJiZcbiAgICAhb3B0aW9ucy5rZWVwRnJlZUZsb2F0aW5nTm9kZXMgJiYgIWluc2lkZUxpc3QgJiZcbiAgICAoYWN0aXZlUHJvcGVydHkgPT09IG51bGwgfHxcbiAgICAgIGV4cGFuZGVkQWN0aXZlUHJvcGVydHkgPT09ICdAZ3JhcGgnIHx8XG4gICAgICAoX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGNvbnRhaW5lcicpIHx8IFtdKVxuICAgICAgICAuaW5jbHVkZXMoJ0BncmFwaCcpXG4gICAgKSkge1xuICAgIC8vIGRyb3AgZW1wdHkgb2JqZWN0LCB0b3AtbGV2ZWwgQHZhbHVlL0BsaXN0LCBvciBvYmplY3Qgd2l0aCBvbmx5IEBpZFxuICAgIHJ2YWwgPSBfZHJvcFVuc2FmZU9iamVjdCh7dmFsdWU6IHJ2YWwsIGNvdW50LCBvcHRpb25zfSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5cbi8qKlxuICogRHJvcCBlbXB0eSBvYmplY3QsIHRvcC1sZXZlbCBAdmFsdWUvQGxpc3QsIG9yIG9iamVjdCB3aXRoIG9ubHkgQGlkXG4gKlxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIGNvdW50IE51bWJlciBvZiBwcm9wZXJ0aWVzIGluIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHBhbnNpb24gb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIG51bGwgaWYgZHJvcHBlZCwgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBfZHJvcFVuc2FmZU9iamVjdCh7XG4gIHZhbHVlLFxuICBjb3VudCxcbiAgb3B0aW9uc1xufSkge1xuICBpZihjb3VudCA9PT0gMCB8fCAnQHZhbHVlJyBpbiB2YWx1ZSB8fCAnQGxpc3QnIGluIHZhbHVlIHx8XG4gICAgKGNvdW50ID09PSAxICYmICdAaWQnIGluIHZhbHVlKSkge1xuICAgIC8vIEZJWE1FXG4gICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgIC8vIEZJWE1FOiBvbmUgZXZlbnQgb3IgZGlmZiBldmVudCBmb3IgZW1wdHksIEB2L0BsLCB7QGlkfT9cbiAgICAgIGxldCBjb2RlO1xuICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICBpZihjb3VudCA9PT0gMCkge1xuICAgICAgICBjb2RlID0gJ2VtcHR5IG9iamVjdCc7XG4gICAgICAgIG1lc3NhZ2UgPSAnRHJvcHBpbmcgZW1wdHkgb2JqZWN0Lic7XG4gICAgICB9IGVsc2UgaWYoJ0B2YWx1ZScgaW4gdmFsdWUpIHtcbiAgICAgICAgY29kZSA9ICdvYmplY3Qgd2l0aCBvbmx5IEB2YWx1ZSc7XG4gICAgICAgIG1lc3NhZ2UgPSAnRHJvcHBpbmcgb2JqZWN0IHdpdGggb25seSBAdmFsdWUuJztcbiAgICAgIH0gZWxzZSBpZignQGxpc3QnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvZGUgPSAnb2JqZWN0IHdpdGggb25seSBAbGlzdCc7XG4gICAgICAgIG1lc3NhZ2UgPSAnRHJvcHBpbmcgb2JqZWN0IHdpdGggb25seSBAbGlzdC4nO1xuICAgICAgfSBlbHNlIGlmKGNvdW50ID09PSAxICYmICdAaWQnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvZGUgPSAnb2JqZWN0IHdpdGggb25seSBAaWQnO1xuICAgICAgICBtZXNzYWdlID0gJ0Ryb3BwaW5nIG9iamVjdCB3aXRoIG9ubHkgQGlkLic7XG4gICAgICB9XG4gICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICBldmVudDoge1xuICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBFeHBhbmQgZWFjaCBrZXkgYW5kIHZhbHVlIG9mIGVsZW1lbnQgYWRkaW5nIHRvIHJlc3VsdFxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGFjdGl2ZVByb3BlcnR5IHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0gZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSB0aGUgZXhwYW5zaW9uIG9mIGFjdGl2ZVByb3BlcnR5XG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBleHBhbmQuXG4gKiBAcGFyYW0gZXhwYW5kZWRQYXJlbnQgdGhlIGV4cGFuZGVkIHJlc3VsdCBpbnRvIHdoaWNoIHRvIGFkZCB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZXhwYW5zaW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gaW5zaWRlTGlzdCB0cnVlIGlmIHRoZSBlbGVtZW50IGlzIGEgbGlzdCwgZmFsc2UgaWYgbm90LlxuICogQHBhcmFtIHR5cGVLZXkgZmlyc3Qga2V5IGZvdW5kIGV4cGFuZGluZyB0byBAdHlwZS5cbiAqIEBwYXJhbSB0eXBlU2NvcGVkQ29udGV4dCB0aGUgY29udGV4dCBiZWZvcmUgcmV2ZXJ0aW5nLlxuICovXG5hc3luYyBmdW5jdGlvbiBfZXhwYW5kT2JqZWN0KHtcbiAgYWN0aXZlQ3R4LFxuICBhY3RpdmVQcm9wZXJ0eSxcbiAgZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSxcbiAgZWxlbWVudCxcbiAgZXhwYW5kZWRQYXJlbnQsXG4gIG9wdGlvbnMgPSB7fSxcbiAgaW5zaWRlTGlzdCxcbiAgdHlwZUtleSxcbiAgdHlwZVNjb3BlZENvbnRleHRcbn0pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQpLnNvcnQoKTtcbiAgY29uc3QgbmVzdHMgPSBbXTtcbiAgbGV0IHVuZXhwYW5kZWRWYWx1ZTtcblxuICAvLyBGaWd1cmUgb3V0IGlmIHRoaXMgaXMgdGhlIHR5cGUgZm9yIGEgSlNPTiBsaXRlcmFsXG4gIGNvbnN0IGlzSnNvblR5cGUgPSBlbGVtZW50W3R5cGVLZXldICYmXG4gICAgX2V4cGFuZElyaShhY3RpdmVDdHgsXG4gICAgICAoX2lzQXJyYXkoZWxlbWVudFt0eXBlS2V5XSkgPyBlbGVtZW50W3R5cGVLZXldWzBdIDogZWxlbWVudFt0eXBlS2V5XSksXG4gICAgICB7dm9jYWI6IHRydWV9LCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHR5cGVFeHBhbnNpb246IHRydWVcbiAgICAgIH0pID09PSAnQGpzb24nO1xuXG4gIGZvcihjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGxldCB2YWx1ZSA9IGVsZW1lbnRba2V5XTtcbiAgICBsZXQgZXhwYW5kZWRWYWx1ZTtcblxuICAgIC8vIHNraXAgQGNvbnRleHRcbiAgICBpZihrZXkgPT09ICdAY29udGV4dCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBwcm9wZXJ0eVxuICAgIGNvbnN0IGV4cGFuZGVkUHJvcGVydHkgPSBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwga2V5LCB7dm9jYWI6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIC8vIGRyb3Agbm9uLWFic29sdXRlIElSSSBrZXlzIHRoYXQgYXJlbid0IGtleXdvcmRzXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gbnVsbCB8fFxuICAgICAgIShfaXNBYnNvbHV0ZUlyaShleHBhbmRlZFByb3BlcnR5KSB8fCBfaXNLZXl3b3JkKGV4cGFuZGVkUHJvcGVydHkpKSkge1xuICAgICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgICAgX2hhbmRsZUV2ZW50KHtcbiAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgICAgY29kZTogJ2ludmFsaWQgcHJvcGVydHknLFxuICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdEcm9wcGluZyBwcm9wZXJ0eSB0aGF0IGRpZCBub3QgZXhwYW5kIGludG8gYW4gJyArXG4gICAgICAgICAgICAgICdhYnNvbHV0ZSBJUkkgb3Iga2V5d29yZC4nLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBwcm9wZXJ0eToga2V5LFxuICAgICAgICAgICAgICBleHBhbmRlZFByb3BlcnR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYoX2lzS2V5d29yZChleHBhbmRlZFByb3BlcnR5KSkge1xuICAgICAgaWYoZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSA9PT0gJ0ByZXZlcnNlJykge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGEga2V5d29yZCBjYW5ub3QgYmUgdXNlZCBhcyBhIEByZXZlcnNlICcgK1xuICAgICAgICAgICdwcm9wZXJ0eS4nLCAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgcmV2ZXJzZSBwcm9wZXJ0eSBtYXAnLCB2YWx1ZX0pO1xuICAgICAgfVxuICAgICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSBpbiBleHBhbmRlZFBhcmVudCAmJlxuICAgICAgICAgZXhwYW5kZWRQcm9wZXJ0eSAhPT0gJ0BpbmNsdWRlZCcgJiZcbiAgICAgICAgIGV4cGFuZGVkUHJvcGVydHkgIT09ICdAdHlwZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBjb2xsaWRpbmcga2V5d29yZHMgZGV0ZWN0ZWQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2NvbGxpZGluZyBrZXl3b3JkcycsIGtleXdvcmQ6IGV4cGFuZGVkUHJvcGVydHl9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzeW50YXggZXJyb3IgaWYgQGlkIGlzIG5vdCBhIHN0cmluZ1xuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaWQnKSB7XG4gICAgICBpZighX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZighb3B0aW9ucy5pc0ZyYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGlkXCIgdmFsdWUgbXVzdCBhIHN0cmluZy4nLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAaWQgdmFsdWUnLCB2YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmKF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyBlbXB0eSBvYmplY3QgaXMgYSB3aWxkY2FyZFxuICAgICAgICAgIGlmKCFfaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGlkXCIgdmFsdWUgYW4gZW1wdHkgb2JqZWN0IG9yIGFycmF5ICcgK1xuICAgICAgICAgICAgICAnb2Ygc3RyaW5ncywgaWYgZnJhbWluZycsXG4gICAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGlkIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihfaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZighdmFsdWUuZXZlcnkodiA9PiBfaXNTdHJpbmcodikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBpZFwiIHZhbHVlIGFuIGVtcHR5IG9iamVjdCBvciBhcnJheSAnICtcbiAgICAgICAgICAgICAgJ29mIHN0cmluZ3MsIGlmIGZyYW1pbmcnLFxuICAgICAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBpZCB2YWx1ZScsIHZhbHVlfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBpZFwiIHZhbHVlIGFuIGVtcHR5IG9iamVjdCBvciBhcnJheSAnICtcbiAgICAgICAgICAgICdvZiBzdHJpbmdzLCBpZiBmcmFtaW5nJyxcbiAgICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGlkIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfYWRkVmFsdWUoXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LCAnQGlkJyxcbiAgICAgICAgX2FzQXJyYXkodmFsdWUpLm1hcCh2ID0+IHtcbiAgICAgICAgICBpZihfaXNTdHJpbmcodikpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIHYsIHtiYXNlOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICBpZih2ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHNwZWMgZWRnZSBjYXNlXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93M2MvanNvbi1sZC1hcGkvaXNzdWVzLzQ4MFxuICAgICAgICAgICAgICAgIGlmKHYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgICAgICAgICAgICAgIGNvZGU6ICdudWxsIEBpZCB2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTnVsbCBAaWQgZm91bmQuJyxcbiAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG1hdGNoZWQgS0VZV09SRCByZWdleFxuICAgICAgICAgICAgICAgICAgX2hhbmRsZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgY29kZTogJ3Jlc2VydmVkIEBpZCB2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVzZXJ2ZWQgQGlkIGZvdW5kLicsXG4gICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHZcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmKCFfaXNBYnNvbHV0ZUlyaSh2ZSkpIHtcbiAgICAgICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiAncmVsYXRpdmUgQGlkIHJlZmVyZW5jZScsXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWxhdGl2ZSBAaWQgcmVmZXJlbmNlIGZvdW5kLicsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdixcbiAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZElkOiB2ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KSxcbiAgICAgICAge3Byb3BlcnR5SXNBcnJheTogb3B0aW9ucy5pc0ZyYW1lfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQHR5cGUnKSB7XG4gICAgICAvLyBpZiBmcmFtaW5nLCBjYW4gYmUgYSBkZWZhdWx0IG9iamVjdCwgYnV0IG5lZWQgdG8gZXhwYW5kXG4gICAgICAvLyBrZXkgdG8gZGV0ZXJtaW5lIHRoYXRcbiAgICAgIGlmKF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2ssIHZdKSA9PiBbXG4gICAgICAgICAgX2V4cGFuZElyaSh0eXBlU2NvcGVkQ29udGV4dCwgaywge3ZvY2FiOiB0cnVlfSksXG4gICAgICAgICAgX2FzQXJyYXkodikubWFwKHZ2ID0+XG4gICAgICAgICAgICBfZXhwYW5kSXJpKHR5cGVTY29wZWRDb250ZXh0LCB2diwge2Jhc2U6IHRydWUsIHZvY2FiOiB0cnVlfSxcbiAgICAgICAgICAgICAgey4uLm9wdGlvbnMsIHR5cGVFeHBhbnNpb246IHRydWV9KVxuICAgICAgICAgIClcbiAgICAgICAgXSkpO1xuICAgICAgfVxuICAgICAgX3ZhbGlkYXRlVHlwZVZhbHVlKHZhbHVlLCBvcHRpb25zLmlzRnJhbWUpO1xuICAgICAgX2FkZFZhbHVlKFxuICAgICAgICBleHBhbmRlZFBhcmVudCwgJ0B0eXBlJyxcbiAgICAgICAgX2FzQXJyYXkodmFsdWUpLm1hcCh2ID0+IHtcbiAgICAgICAgICBpZihfaXNTdHJpbmcodikpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlID0gX2V4cGFuZElyaSh0eXBlU2NvcGVkQ29udGV4dCwgdixcbiAgICAgICAgICAgICAge2Jhc2U6IHRydWUsIHZvY2FiOiB0cnVlfSxcbiAgICAgICAgICAgICAgey4uLm9wdGlvbnMsIHR5cGVFeHBhbnNpb246IHRydWV9KTtcbiAgICAgICAgICAgIGlmKHZlICE9PSAnQGpzb24nICYmICFfaXNBYnNvbHV0ZUlyaSh2ZSkpIHtcbiAgICAgICAgICAgICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiAncmVsYXRpdmUgQHR5cGUgcmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlbGF0aXZlIEB0eXBlIHJlZmVyZW5jZSBmb3VuZC4nLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogdlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KSxcbiAgICAgICAge3Byb3BlcnR5SXNBcnJheTogISFvcHRpb25zLmlzRnJhbWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEluY2x1ZGVkIGJsb2NrcyBhcmUgdHJlYXRlZCBhcyBhbiBhcnJheSBvZiBzZXBhcmF0ZSBvYmplY3Qgbm9kZXMgc2hhcmluZ1xuICAgIC8vIHRoZSBzYW1lIHJlZmVyZW5jaW5nIGFjdGl2ZV9wcm9wZXJ0eS5cbiAgICAvLyBGb3IgMS4wLCBpdCBpcyBza2lwcGVkIGFzIGFyZSBvdGhlciB1bmtub3duIGtleXdvcmRzXG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BpbmNsdWRlZCcgJiYgX3Byb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSkge1xuICAgICAgY29uc3QgaW5jbHVkZWRSZXN1bHQgPSBfYXNBcnJheShhd2FpdCBhcGkuZXhwYW5kKHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogdmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRXhwYW5kZWQgdmFsdWVzIG11c3QgYmUgbm9kZSBvYmplY3RzXG4gICAgICBpZighaW5jbHVkZWRSZXN1bHQuZXZlcnkodiA9PiBfaXNTdWJqZWN0KHYpKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7ICcgK1xuICAgICAgICAgICd2YWx1ZXMgb2YgQGluY2x1ZGVkIG11c3QgZXhwYW5kIHRvIG5vZGUgb2JqZWN0cy4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGluY2x1ZGVkIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgIH1cblxuICAgICAgX2FkZFZhbHVlKFxuICAgICAgICBleHBhbmRlZFBhcmVudCwgJ0BpbmNsdWRlZCcsIGluY2x1ZGVkUmVzdWx0LCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBAZ3JhcGggbXVzdCBiZSBhbiBhcnJheSBvciBhbiBvYmplY3RcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGdyYXBoJyAmJlxuICAgICAgIShfaXNPYmplY3QodmFsdWUpIHx8IF9pc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGdyYXBoXCIgdmFsdWUgbXVzdCBub3QgYmUgYW4gJyArXG4gICAgICAgICdvYmplY3Qgb3IgYW4gYXJyYXkuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBAZ3JhcGggdmFsdWUnLCB2YWx1ZX0pO1xuICAgIH1cblxuICAgIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdmFsdWUnKSB7XG4gICAgICAvLyBjYXB0dXJlIHZhbHVlIGZvciBsYXRlclxuICAgICAgLy8gXCJjb2xsaWRpbmcga2V5d29yZHNcIiBjaGVjayBwcmV2ZW50cyB0aGlzIGZyb20gYmVpbmcgc2V0IHR3aWNlXG4gICAgICB1bmV4cGFuZGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmKGlzSnNvblR5cGUgJiYgX3Byb2Nlc3NpbmdNb2RlKGFjdGl2ZUN0eCwgMS4xKSkge1xuICAgICAgICAvLyBubyBjb2VyY2lvbiB0byBhcnJheSwgYW5kIHJldGFpbiBhbGwgdmFsdWVzXG4gICAgICAgIGV4cGFuZGVkUGFyZW50WydAdmFsdWUnXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgIGV4cGFuZGVkUGFyZW50LCAnQHZhbHVlJywgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IG9wdGlvbnMuaXNGcmFtZX0pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQGxhbmd1YWdlIG11c3QgYmUgYSBzdHJpbmdcbiAgICAvLyBpdCBzaG91bGQgbWF0Y2ggQkNQNDdcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGxhbmd1YWdlJykge1xuICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gZHJvcCBudWxsIEBsYW5ndWFnZSB2YWx1ZXMsIHRoZXkgZXhwYW5kIGFzIGlmIHRoZXkgZGlkbid0IGV4aXN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYoIV9pc1N0cmluZyh2YWx1ZSkgJiYgIW9wdGlvbnMuaXNGcmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQGxhbmd1YWdlXCIgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBsYW5ndWFnZS10YWdnZWQgc3RyaW5nJywgdmFsdWV9KTtcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBsYW5ndWFnZSB2YWx1ZSBpcyBsb3dlcmNhc2VcbiAgICAgIHZhbHVlID0gX2FzQXJyYXkodmFsdWUpLm1hcCh2ID0+IF9pc1N0cmluZyh2KSA/IHYudG9Mb3dlckNhc2UoKSA6IHYpO1xuXG4gICAgICAvLyBlbnN1cmUgbGFuZ3VhZ2UgdGFnIG1hdGNoZXMgQkNQNDdcbiAgICAgIGZvcihjb25zdCBsYW5ndWFnZSBvZiB2YWx1ZSkge1xuICAgICAgICBpZihfaXNTdHJpbmcobGFuZ3VhZ2UpICYmICFsYW5ndWFnZS5tYXRjaChSRUdFWF9CQ1A0NykpIHtcbiAgICAgICAgICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgX2hhbmRsZUV2ZW50KHtcbiAgICAgICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICAgICAgY29kZTogJ2ludmFsaWQgQGxhbmd1YWdlIHZhbHVlJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdAbGFuZ3VhZ2UgdmFsdWUgbXVzdCBiZSB2YWxpZCBCQ1A0Ny4nLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgIGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2FkZFZhbHVlKFxuICAgICAgICBleHBhbmRlZFBhcmVudCwgJ0BsYW5ndWFnZScsIHZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiBvcHRpb25zLmlzRnJhbWV9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEBkaXJlY3Rpb24gbXVzdCBiZSBcImx0clwiIG9yIFwicnRsXCJcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGRpcmVjdGlvbicpIHtcbiAgICAgIGlmKCFfaXNTdHJpbmcodmFsdWUpICYmICFvcHRpb25zLmlzRnJhbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBkaXJlY3Rpb25cIiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIGJhc2UgZGlyZWN0aW9uJywgdmFsdWV9KTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBfYXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgIC8vIGVuc3VyZSBkaXJlY3Rpb24gaXMgXCJsdHJcIiBvciBcInJ0bFwiXG4gICAgICBmb3IoY29uc3QgZGlyIG9mIHZhbHVlKSB7XG4gICAgICAgIGlmKF9pc1N0cmluZyhkaXIpICYmIGRpciAhPT0gJ2x0cicgJiYgZGlyICE9PSAncnRsJykge1xuICAgICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBkaXJlY3Rpb25cIiBtdXN0IGJlIFwibHRyXCIgb3IgXCJydGxcIi4nLFxuICAgICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgYmFzZSBkaXJlY3Rpb24nLCB2YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9hZGRWYWx1ZShcbiAgICAgICAgZXhwYW5kZWRQYXJlbnQsICdAZGlyZWN0aW9uJywgdmFsdWUsXG4gICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IG9wdGlvbnMuaXNGcmFtZX0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gQGluZGV4IG11c3QgYmUgYSBzdHJpbmdcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQGluZGV4Jykge1xuICAgICAgaWYoIV9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkBpbmRleFwiIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgQGluZGV4IHZhbHVlJywgdmFsdWV9KTtcbiAgICAgIH1cbiAgICAgIF9hZGRWYWx1ZShleHBhbmRlZFBhcmVudCwgJ0BpbmRleCcsIHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEByZXZlcnNlIG11c3QgYmUgYW4gb2JqZWN0XG4gICAgaWYoZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0ByZXZlcnNlJykge1xuICAgICAgaWYoIV9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkByZXZlcnNlXCIgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEByZXZlcnNlIHZhbHVlJywgdmFsdWV9KTtcbiAgICAgIH1cblxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5OiAnQHJldmVyc2UnLFxuICAgICAgICBlbGVtZW50OiB2YWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgICAvLyBwcm9wZXJ0aWVzIGRvdWJsZS1yZXZlcnNlZFxuICAgICAgaWYoJ0ByZXZlcnNlJyBpbiBleHBhbmRlZFZhbHVlKSB7XG4gICAgICAgIGZvcihjb25zdCBwcm9wZXJ0eSBpbiBleHBhbmRlZFZhbHVlWydAcmV2ZXJzZSddKSB7XG4gICAgICAgICAgX2FkZFZhbHVlKFxuICAgICAgICAgICAgZXhwYW5kZWRQYXJlbnQsIHByb3BlcnR5LCBleHBhbmRlZFZhbHVlWydAcmV2ZXJzZSddW3Byb3BlcnR5XSxcbiAgICAgICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRTogY2FuIHRoaXMgYmUgbWVyZ2VkIHdpdGggY29kZSBiZWxvdyB0byBzaW1wbGlmeT9cbiAgICAgIC8vIG1lcmdlIGluIGFsbCByZXZlcnNlZCBwcm9wZXJ0aWVzXG4gICAgICBsZXQgcmV2ZXJzZU1hcCA9IGV4cGFuZGVkUGFyZW50WydAcmV2ZXJzZSddIHx8IG51bGw7XG4gICAgICBmb3IoY29uc3QgcHJvcGVydHkgaW4gZXhwYW5kZWRWYWx1ZSkge1xuICAgICAgICBpZihwcm9wZXJ0eSA9PT0gJ0ByZXZlcnNlJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHJldmVyc2VNYXAgPT09IG51bGwpIHtcbiAgICAgICAgICByZXZlcnNlTWFwID0gZXhwYW5kZWRQYXJlbnRbJ0ByZXZlcnNlJ10gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkVmFsdWUocmV2ZXJzZU1hcCwgcHJvcGVydHksIFtdLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZXhwYW5kZWRWYWx1ZVtwcm9wZXJ0eV07XG4gICAgICAgIGZvcihsZXQgaWkgPSAwOyBpaSA8IGl0ZW1zLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpaV07XG4gICAgICAgICAgaWYoX2lzVmFsdWUoaXRlbSkgfHwgX2lzTGlzdChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAcmV2ZXJzZVwiIHZhbHVlIG11c3Qgbm90IGJlIGEgJyArXG4gICAgICAgICAgICAgICdAdmFsdWUgb3IgYW4gQGxpc3QuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCByZXZlcnNlIHByb3BlcnR5IHZhbHVlJywgdmFsdWU6IGV4cGFuZGVkVmFsdWV9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2FkZFZhbHVlKHJldmVyc2VNYXAsIHByb3BlcnR5LCBpdGVtLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbmVzdGVkIGtleXNcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ID09PSAnQG5lc3QnKSB7XG4gICAgICBuZXN0cy5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB1c2UgcG90ZW50aWFsIHNjb3BlZCBjb250ZXh0IGZvciBrZXlcbiAgICBsZXQgdGVybUN0eCA9IGFjdGl2ZUN0eDtcbiAgICBjb25zdCBjdHggPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwga2V5LCAnQGNvbnRleHQnKTtcbiAgICBpZighX2lzVW5kZWZpbmVkKGN0eCkpIHtcbiAgICAgIHRlcm1DdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICBhY3RpdmVDdHgsXG4gICAgICAgIGxvY2FsQ3R4OiBjdHgsXG4gICAgICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICAgICAgb3ZlcnJpZGVQcm90ZWN0ZWQ6IHRydWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRDb250ZXh0VmFsdWUoYWN0aXZlQ3R4LCBrZXksICdAY29udGFpbmVyJykgfHwgW107XG5cbiAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BsYW5ndWFnZScpICYmIF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IF9nZXRDb250ZXh0VmFsdWUodGVybUN0eCwga2V5LCAnQGRpcmVjdGlvbicpO1xuICAgICAgLy8gaGFuZGxlIGxhbmd1YWdlIG1hcCBjb250YWluZXIgKHNraXAgaWYgdmFsdWUgaXMgbm90IGFuIG9iamVjdClcbiAgICAgIGV4cGFuZGVkVmFsdWUgPSBfZXhwYW5kTGFuZ3VhZ2VNYXAodGVybUN0eCwgdmFsdWUsIGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGluZGV4JykgJiYgX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gaGFuZGxlIGluZGV4IGNvbnRhaW5lciAoc2tpcCBpZiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0KVxuICAgICAgY29uc3QgYXNHcmFwaCA9IGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJyk7XG4gICAgICBjb25zdCBpbmRleEtleSA9IF9nZXRDb250ZXh0VmFsdWUodGVybUN0eCwga2V5LCAnQGluZGV4JykgfHwgJ0BpbmRleCc7XG4gICAgICBjb25zdCBwcm9wZXJ0eUluZGV4ID0gaW5kZXhLZXkgIT09ICdAaW5kZXgnICYmXG4gICAgICAgIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBpbmRleEtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG5cbiAgICAgIGV4cGFuZGVkVmFsdWUgPSBhd2FpdCBfZXhwYW5kSW5kZXhNYXAoe1xuICAgICAgICBhY3RpdmVDdHg6IHRlcm1DdHgsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGFjdGl2ZVByb3BlcnR5OiBrZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBhc0dyYXBoLFxuICAgICAgICBpbmRleEtleSxcbiAgICAgICAgcHJvcGVydHlJbmRleFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmKGNvbnRhaW5lci5pbmNsdWRlcygnQGlkJykgJiYgX2lzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgLy8gaGFuZGxlIGlkIGNvbnRhaW5lciAoc2tpcCBpZiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0KVxuICAgICAgY29uc3QgYXNHcmFwaCA9IGNvbnRhaW5lci5pbmNsdWRlcygnQGdyYXBoJyk7XG4gICAgICBleHBhbmRlZFZhbHVlID0gYXdhaXQgX2V4cGFuZEluZGV4TWFwKHtcbiAgICAgICAgYWN0aXZlQ3R4OiB0ZXJtQ3R4LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eToga2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYXNHcmFwaCxcbiAgICAgICAgaW5kZXhLZXk6ICdAaWQnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYoY29udGFpbmVyLmluY2x1ZGVzKCdAdHlwZScpICYmIF9pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIC8vIGhhbmRsZSB0eXBlIGNvbnRhaW5lciAoc2tpcCBpZiB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0KVxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IF9leHBhbmRJbmRleE1hcCh7XG4gICAgICAgIC8vIHNpbmNlIGNvbnRhaW5lciBpcyBgQHR5cGVgLCByZXZlcnQgdHlwZSBzY29wZWQgY29udGV4dCB3aGVuIGV4cGFuZGluZ1xuICAgICAgICBhY3RpdmVDdHg6IHRlcm1DdHgucmV2ZXJ0VG9QcmV2aW91c0NvbnRleHQoKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYWN0aXZlUHJvcGVydHk6IGtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGFzR3JhcGg6IGZhbHNlLFxuICAgICAgICBpbmRleEtleTogJ0B0eXBlJ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlY3Vyc2UgaW50byBAbGlzdCBvciBAc2V0XG4gICAgICBjb25zdCBpc0xpc3QgPSBleHBhbmRlZFByb3BlcnR5ID09PSAnQGxpc3QnO1xuICAgICAgaWYoaXNMaXN0IHx8IGV4cGFuZGVkUHJvcGVydHkgPT09ICdAc2V0Jykge1xuICAgICAgICBsZXQgbmV4dEFjdGl2ZVByb3BlcnR5ID0gYWN0aXZlUHJvcGVydHk7XG4gICAgICAgIGlmKGlzTGlzdCAmJiBleHBhbmRlZEFjdGl2ZVByb3BlcnR5ID09PSAnQGdyYXBoJykge1xuICAgICAgICAgIG5leHRBY3RpdmVQcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXhwYW5kZWRWYWx1ZSA9IGF3YWl0IGFwaS5leHBhbmQoe1xuICAgICAgICAgIGFjdGl2ZUN0eDogdGVybUN0eCxcbiAgICAgICAgICBhY3RpdmVQcm9wZXJ0eTogbmV4dEFjdGl2ZVByb3BlcnR5LFxuICAgICAgICAgIGVsZW1lbnQ6IHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgaW5zaWRlTGlzdDogaXNMaXN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwga2V5LCAnQHR5cGUnKSA9PT0gJ0Bqc29uJykge1xuICAgICAgICBleHBhbmRlZFZhbHVlID0ge1xuICAgICAgICAgICdAdHlwZSc6ICdAanNvbicsXG4gICAgICAgICAgJ0B2YWx1ZSc6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNpdmVseSBleHBhbmQgdmFsdWUgd2l0aCBrZXkgYXMgbmV3IGFjdGl2ZSBwcm9wZXJ0eVxuICAgICAgICBleHBhbmRlZFZhbHVlID0gYXdhaXQgYXBpLmV4cGFuZCh7XG4gICAgICAgICAgYWN0aXZlQ3R4OiB0ZXJtQ3R4LFxuICAgICAgICAgIGFjdGl2ZVByb3BlcnR5OiBrZXksXG4gICAgICAgICAgZWxlbWVudDogdmFsdWUsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbnNpZGVMaXN0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkcm9wIG51bGwgdmFsdWVzIGlmIHByb3BlcnR5IGlzIG5vdCBAdmFsdWVcbiAgICBpZihleHBhbmRlZFZhbHVlID09PSBudWxsICYmIGV4cGFuZGVkUHJvcGVydHkgIT09ICdAdmFsdWUnKSB7XG4gICAgICAvLyBGSVhNRTogZXZlbnQ/XG4gICAgICAvL3VubWFwcGVkVmFsdWU6IHZhbHVlLFxuICAgICAgLy9leHBhbmRlZFByb3BlcnR5LFxuICAgICAgLy9rZXksXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGV4cGFuZGVkIHZhbHVlIHRvIEBsaXN0IGlmIGNvbnRhaW5lciBzcGVjaWZpZXMgaXRcbiAgICBpZihleHBhbmRlZFByb3BlcnR5ICE9PSAnQGxpc3QnICYmICFfaXNMaXN0KGV4cGFuZGVkVmFsdWUpICYmXG4gICAgICBjb250YWluZXIuaW5jbHVkZXMoJ0BsaXN0JykpIHtcbiAgICAgIC8vIGVuc3VyZSBleHBhbmRlZCB2YWx1ZSBpbiBAbGlzdCBpcyBhbiBhcnJheVxuICAgICAgZXhwYW5kZWRWYWx1ZSA9IHsnQGxpc3QnOiBfYXNBcnJheShleHBhbmRlZFZhbHVlKX07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBleHBhbmRlZCB2YWx1ZSB0byBAZ3JhcGggaWYgY29udGFpbmVyIHNwZWNpZmllcyBpdFxuICAgIC8vIGFuZCB2YWx1ZSBpcyBub3QsIGl0c2VsZiwgYSBncmFwaFxuICAgIC8vIGluZGV4IGNhc2VzIGhhbmRsZWQgYWJvdmVcbiAgICBpZihjb250YWluZXIuaW5jbHVkZXMoJ0BncmFwaCcpICYmXG4gICAgICAhY29udGFpbmVyLnNvbWUoa2V5ID0+IGtleSA9PT0gJ0BpZCcgfHwga2V5ID09PSAnQGluZGV4JykpIHtcbiAgICAgIC8vIGVuc3VyZSBleHBhbmRlZCB2YWx1ZXMgYXJlIGluIGFuIGFycmF5XG4gICAgICBleHBhbmRlZFZhbHVlID0gX2FzQXJyYXkoZXhwYW5kZWRWYWx1ZSk7XG4gICAgICBpZighb3B0aW9ucy5pc0ZyYW1lKSB7XG4gICAgICAgIC8vIGRyb3AgaXRlbXMgaWYgbmVlZGVkXG4gICAgICAgIGV4cGFuZGVkVmFsdWUgPSBleHBhbmRlZFZhbHVlLmZpbHRlcih2ID0+IHtcbiAgICAgICAgICBjb25zdCBjb3VudCA9IE9iamVjdC5rZXlzKHYpLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX2Ryb3BVbnNhZmVPYmplY3Qoe3ZhbHVlOiB2LCBjb3VudCwgb3B0aW9uc30pICE9PSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmKGV4cGFuZGVkVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGFsbCBpdGVtcyBkcm9wcGVkLCBza2lwIGFkZGluZyBhbmQgY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IHRvIGdyYXBoXG4gICAgICBleHBhbmRlZFZhbHVlID0gZXhwYW5kZWRWYWx1ZS5tYXAodiA9PiAoeydAZ3JhcGgnOiBfYXNBcnJheSh2KX0pKTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogY2FuIHRoaXMgYmUgbWVyZ2VkIHdpdGggY29kZSBhYm92ZSB0byBzaW1wbGlmeT9cbiAgICAvLyBtZXJnZSBpbiByZXZlcnNlIHByb3BlcnRpZXNcbiAgICBpZih0ZXJtQ3R4Lm1hcHBpbmdzLmhhcyhrZXkpICYmIHRlcm1DdHgubWFwcGluZ3MuZ2V0KGtleSkucmV2ZXJzZSkge1xuICAgICAgY29uc3QgcmV2ZXJzZU1hcCA9XG4gICAgICAgIGV4cGFuZGVkUGFyZW50WydAcmV2ZXJzZSddID0gZXhwYW5kZWRQYXJlbnRbJ0ByZXZlcnNlJ10gfHwge307XG4gICAgICBleHBhbmRlZFZhbHVlID0gX2FzQXJyYXkoZXhwYW5kZWRWYWx1ZSk7XG4gICAgICBmb3IobGV0IGlpID0gMDsgaWkgPCBleHBhbmRlZFZhbHVlLmxlbmd0aDsgKytpaSkge1xuICAgICAgICBjb25zdCBpdGVtID0gZXhwYW5kZWRWYWx1ZVtpaV07XG4gICAgICAgIGlmKF9pc1ZhbHVlKGl0ZW0pIHx8IF9pc0xpc3QoaXRlbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgXCJAcmV2ZXJzZVwiIHZhbHVlIG11c3Qgbm90IGJlIGEgJyArXG4gICAgICAgICAgICAnQHZhbHVlIG9yIGFuIEBsaXN0LicsICdqc29ubGQuU3ludGF4RXJyb3InLFxuICAgICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHJldmVyc2UgcHJvcGVydHkgdmFsdWUnLCB2YWx1ZTogZXhwYW5kZWRWYWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRWYWx1ZShyZXZlcnNlTWFwLCBleHBhbmRlZFByb3BlcnR5LCBpdGVtLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdmFsdWUgZm9yIHByb3BlcnR5XG4gICAgLy8gc3BlY2lhbCBrZXl3b3JkcyBoYW5kbGVkIGFib3ZlXG4gICAgX2FkZFZhbHVlKGV4cGFuZGVkUGFyZW50LCBleHBhbmRlZFByb3BlcnR5LCBleHBhbmRlZFZhbHVlLCB7XG4gICAgICBwcm9wZXJ0eUlzQXJyYXk6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEB2YWx1ZSBtdXN0IG5vdCBiZSBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgKHVubGVzcyBmcmFtaW5nKSBvciBpZiBAdHlwZSBpc1xuICAvLyBAanNvblxuICBpZignQHZhbHVlJyBpbiBleHBhbmRlZFBhcmVudCkge1xuICAgIGlmKGV4cGFuZGVkUGFyZW50WydAdHlwZSddID09PSAnQGpzb24nICYmIF9wcm9jZXNzaW5nTW9kZShhY3RpdmVDdHgsIDEuMSkpIHtcbiAgICAgIC8vIGFsbG93IGFueSB2YWx1ZSwgdG8gYmUgdmVyaWZpZWQgd2hlbiB0aGUgb2JqZWN0IGlzIGZ1bGx5IGV4cGFuZGVkIGFuZFxuICAgICAgLy8gdGhlIEB0eXBlIGlzIEBqc29uLlxuICAgIH0gZWxzZSBpZigoX2lzT2JqZWN0KHVuZXhwYW5kZWRWYWx1ZSkgfHwgX2lzQXJyYXkodW5leHBhbmRlZFZhbHVlKSkgJiZcbiAgICAgICFvcHRpb25zLmlzRnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IFwiQHZhbHVlXCIgdmFsdWUgbXVzdCBub3QgYmUgYW4gJyArXG4gICAgICAgICdvYmplY3Qgb3IgYW4gYXJyYXkuJyxcbiAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgIHtjb2RlOiAnaW52YWxpZCB2YWx1ZSBvYmplY3QgdmFsdWUnLCB2YWx1ZTogdW5leHBhbmRlZFZhbHVlfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwYW5kIGVhY2ggbmVzdGVkIGtleVxuICBmb3IoY29uc3Qga2V5IG9mIG5lc3RzKSB7XG4gICAgY29uc3QgbmVzdGVkVmFsdWVzID0gX2lzQXJyYXkoZWxlbWVudFtrZXldKSA/IGVsZW1lbnRba2V5XSA6IFtlbGVtZW50W2tleV1dO1xuICAgIGZvcihjb25zdCBudiBvZiBuZXN0ZWRWYWx1ZXMpIHtcbiAgICAgIGlmKCFfaXNPYmplY3QobnYpIHx8IE9iamVjdC5rZXlzKG52KS5zb21lKGsgPT5cbiAgICAgICAgX2V4cGFuZElyaShhY3RpdmVDdHgsIGssIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpID09PSAnQHZhbHVlJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBuZXN0ZWQgdmFsdWUgbXVzdCBiZSBhIG5vZGUgb2JqZWN0LicsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIEBuZXN0IHZhbHVlJywgdmFsdWU6IG52fSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBfZXhwYW5kT2JqZWN0KHtcbiAgICAgICAgYWN0aXZlQ3R4LFxuICAgICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZXhwYW5kZWRBY3RpdmVQcm9wZXJ0eSxcbiAgICAgICAgZWxlbWVudDogbnYsXG4gICAgICAgIGV4cGFuZGVkUGFyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbnNpZGVMaXN0LFxuICAgICAgICB0eXBlU2NvcGVkQ29udGV4dCxcbiAgICAgICAgdHlwZUtleVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhwYW5kcyB0aGUgZ2l2ZW4gdmFsdWUgYnkgdXNpbmcgdGhlIGNvZXJjaW9uIGFuZCBrZXl3b3JkIHJ1bGVzIGluIHRoZVxuICogZ2l2ZW4gY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gYWN0aXZlQ3R4IHRoZSBhY3RpdmUgY29udGV4dCB0byB1c2UuXG4gKiBAcGFyYW0gYWN0aXZlUHJvcGVydHkgdGhlIGFjdGl2ZSBwcm9wZXJ0eSB0aGUgdmFsdWUgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBleHBhbmQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gcHJvY2Vzc2luZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGV4cGFuZGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kVmFsdWUoe2FjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksIHZhbHVlLCBvcHRpb25zfSkge1xuICAvLyBub3RoaW5nIHRvIGV4cGFuZFxuICBpZih2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzcGVjaWFsLWNhc2UgZXhwYW5kIEBpZCBhbmQgQHR5cGUgKHNraXBzICdAaWQnIGV4cGFuc2lvbilcbiAgY29uc3QgZXhwYW5kZWRQcm9wZXJ0eSA9IF9leHBhbmRJcmkoXG4gICAgYWN0aXZlQ3R4LCBhY3RpdmVQcm9wZXJ0eSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAaWQnKSB7XG4gICAgcmV0dXJuIF9leHBhbmRJcmkoYWN0aXZlQ3R4LCB2YWx1ZSwge2Jhc2U6IHRydWV9LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmKGV4cGFuZGVkUHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICByZXR1cm4gX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCB7dm9jYWI6IHRydWUsIGJhc2U6IHRydWV9LFxuICAgICAgey4uLm9wdGlvbnMsIHR5cGVFeHBhbnNpb246IHRydWV9KTtcbiAgfVxuXG4gIC8vIGdldCB0eXBlIGRlZmluaXRpb24gZnJvbSBjb250ZXh0XG4gIGNvbnN0IHR5cGUgPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAdHlwZScpO1xuXG4gIC8vIGRvIEBpZCBleHBhbnNpb24gKGF1dG9tYXRpYyBmb3IgQGdyYXBoKVxuICBpZigodHlwZSA9PT0gJ0BpZCcgfHwgZXhwYW5kZWRQcm9wZXJ0eSA9PT0gJ0BncmFwaCcpICYmIF9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICBjb25zdCBleHBhbmRlZFZhbHVlID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIHZhbHVlLCB7YmFzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIC8vIE5PVEU6IGhhbmRsZSBzcGVjIGVkZ2UgY2FzZSBhbmQgYXZvaWQgaW52YWxpZCB7XCJAaWRcIjogbnVsbH1cbiAgICBpZihleHBhbmRlZFZhbHVlID09PSBudWxsICYmIHZhbHVlLm1hdGNoKFJFR0VYX0tFWVdPUkQpKSB7XG4gICAgICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICBjb2RlOiAncmVzZXJ2ZWQgQGlkIHZhbHVlJyxcbiAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnUmVzZXJ2ZWQgQGlkIGZvdW5kLicsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIGlkOiBhY3RpdmVQcm9wZXJ0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsnQGlkJzogZXhwYW5kZWRWYWx1ZX07XG4gIH1cbiAgLy8gZG8gQGlkIGV4cGFuc2lvbiB3L3ZvY2FiXG4gIGlmKHR5cGUgPT09ICdAdm9jYWInICYmIF9pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ0BpZCc6IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCB2YWx1ZSwge3ZvY2FiOiB0cnVlLCBiYXNlOiB0cnVlfSwgb3B0aW9ucylcbiAgICB9O1xuICB9XG5cbiAgLy8gZG8gbm90IGV4cGFuZCBrZXl3b3JkIHZhbHVlc1xuICBpZihfaXNLZXl3b3JkKGV4cGFuZGVkUHJvcGVydHkpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgcnZhbCA9IHt9O1xuXG4gIGlmKHR5cGUgJiYgIVsnQGlkJywgJ0B2b2NhYicsICdAbm9uZSddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgLy8gb3RoZXIgdHlwZVxuICAgIHJ2YWxbJ0B0eXBlJ10gPSB0eXBlO1xuICB9IGVsc2UgaWYoX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgIC8vIGNoZWNrIGZvciBsYW5ndWFnZSB0YWdnaW5nIGZvciBzdHJpbmdzXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwgYWN0aXZlUHJvcGVydHksICdAbGFuZ3VhZ2UnKTtcbiAgICBpZihsYW5ndWFnZSAhPT0gbnVsbCkge1xuICAgICAgcnZhbFsnQGxhbmd1YWdlJ10gPSBsYW5ndWFnZTtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gX2dldENvbnRleHRWYWx1ZShhY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5LCAnQGRpcmVjdGlvbicpO1xuICAgIGlmKGRpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcnZhbFsnQGRpcmVjdGlvbiddID0gZGlyZWN0aW9uO1xuICAgIH1cbiAgfVxuICAvLyBkbyBjb252ZXJzaW9uIG9mIHZhbHVlcyB0aGF0IGFyZW4ndCBiYXNpYyBKU09OIHR5cGVzIHRvIHN0cmluZ3NcbiAgaWYoIVsnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBydmFsWydAdmFsdWUnXSA9IHZhbHVlO1xuXG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIEV4cGFuZHMgYSBsYW5ndWFnZSBtYXAuXG4gKlxuICogQHBhcmFtIGFjdGl2ZUN0eCB0aGUgYWN0aXZlIGNvbnRleHQgdG8gdXNlLlxuICogQHBhcmFtIGxhbmd1YWdlTWFwIHRoZSBsYW5ndWFnZSBtYXAgdG8gZXhwYW5kLlxuICogQHBhcmFtIGRpcmVjdGlvbiB0aGUgZGlyZWN0aW9uIHRvIGFwcGx5IHRvIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBwcm9jZXNzaW5nIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgZXhwYW5kZWQgbGFuZ3VhZ2UgbWFwLlxuICovXG5mdW5jdGlvbiBfZXhwYW5kTGFuZ3VhZ2VNYXAoYWN0aXZlQ3R4LCBsYW5ndWFnZU1hcCwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGxhbmd1YWdlTWFwKS5zb3J0KCk7XG4gIGZvcihjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGV4cGFuZGVkS2V5ID0gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge3ZvY2FiOiB0cnVlfSwgb3B0aW9ucyk7XG4gICAgbGV0IHZhbCA9IGxhbmd1YWdlTWFwW2tleV07XG4gICAgaWYoIV9pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbCA9IFt2YWxdO1xuICAgIH1cbiAgICBmb3IoY29uc3QgaXRlbSBvZiB2YWwpIHtcbiAgICAgIGlmKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCB2YWx1ZXMgYXJlIGFsbG93ZWQgKDguNSkgYnV0IGlnbm9yZWQgKDMuMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZighX2lzU3RyaW5nKGl0ZW0pKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgbGFuZ3VhZ2UgbWFwIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2ludmFsaWQgbGFuZ3VhZ2UgbWFwIHZhbHVlJywgbGFuZ3VhZ2VNYXB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbCA9IHsnQHZhbHVlJzogaXRlbX07XG4gICAgICBpZihleHBhbmRlZEtleSAhPT0gJ0Bub25lJykge1xuICAgICAgICBpZigha2V5Lm1hdGNoKFJFR0VYX0JDUDQ3KSkge1xuICAgICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZCBAbGFuZ3VhZ2UgdmFsdWUnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0BsYW5ndWFnZSB2YWx1ZSBtdXN0IGJlIHZhbGlkIEJDUDQ3LicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGtleVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbFsnQGxhbmd1YWdlJ10gPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmKGRpcmVjdGlvbikge1xuICAgICAgICB2YWxbJ0BkaXJlY3Rpb24nXSA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIHJ2YWwucHVzaCh2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX2V4cGFuZEluZGV4TWFwKHtcbiAgYWN0aXZlQ3R4LCBvcHRpb25zLCBhY3RpdmVQcm9wZXJ0eSwgdmFsdWUsIGFzR3JhcGgsIGluZGV4S2V5LCBwcm9wZXJ0eUluZGV4XG59KSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCk7XG4gIGNvbnN0IGlzVHlwZUluZGV4ID0gaW5kZXhLZXkgPT09ICdAdHlwZSc7XG4gIGZvcihsZXQga2V5IG9mIGtleXMpIHtcbiAgICAvLyBpZiBpbmRleEtleSBpcyBAdHlwZSwgdGhlcmUgbWF5IGJlIGEgY29udGV4dCBkZWZpbmVkIGZvciBpdFxuICAgIGlmKGlzVHlwZUluZGV4KSB7XG4gICAgICBjb25zdCBjdHggPSBfZ2V0Q29udGV4dFZhbHVlKGFjdGl2ZUN0eCwga2V5LCAnQGNvbnRleHQnKTtcbiAgICAgIGlmKCFfaXNVbmRlZmluZWQoY3R4KSkge1xuICAgICAgICBhY3RpdmVDdHggPSBhd2FpdCBfcHJvY2Vzc0NvbnRleHQoe1xuICAgICAgICAgIGFjdGl2ZUN0eCxcbiAgICAgICAgICBsb2NhbEN0eDogY3R4LFxuICAgICAgICAgIHByb3BhZ2F0ZTogZmFsc2UsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdmFsID0gdmFsdWVba2V5XTtcbiAgICBpZighX2lzQXJyYXkodmFsKSkge1xuICAgICAgdmFsID0gW3ZhbF07XG4gICAgfVxuXG4gICAgdmFsID0gYXdhaXQgYXBpLmV4cGFuZCh7XG4gICAgICBhY3RpdmVDdHgsXG4gICAgICBhY3RpdmVQcm9wZXJ0eSxcbiAgICAgIGVsZW1lbnQ6IHZhbCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBpbnNpZGVMaXN0OiBmYWxzZSxcbiAgICAgIGluc2lkZUluZGV4OiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBleHBhbmQgZm9yIEB0eXBlLCBidXQgYWxzbyBmb3IgQG5vbmVcbiAgICBsZXQgZXhwYW5kZWRLZXk7XG4gICAgaWYocHJvcGVydHlJbmRleCkge1xuICAgICAgaWYoa2V5ID09PSAnQG5vbmUnKSB7XG4gICAgICAgIGV4cGFuZGVkS2V5ID0gJ0Bub25lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cGFuZGVkS2V5ID0gX2V4cGFuZFZhbHVlKFxuICAgICAgICAgIHthY3RpdmVDdHgsIGFjdGl2ZVByb3BlcnR5OiBpbmRleEtleSwgdmFsdWU6IGtleSwgb3B0aW9uc30pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRlZEtleSA9IF9leHBhbmRJcmkoYWN0aXZlQ3R4LCBrZXksIHt2b2NhYjogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmKGluZGV4S2V5ID09PSAnQGlkJykge1xuICAgICAgLy8gZXhwYW5kIGRvY3VtZW50IHJlbGF0aXZlXG4gICAgICBrZXkgPSBfZXhwYW5kSXJpKGFjdGl2ZUN0eCwga2V5LCB7YmFzZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZihpc1R5cGVJbmRleCkge1xuICAgICAga2V5ID0gZXhwYW5kZWRLZXk7XG4gICAgfVxuXG4gICAgZm9yKGxldCBpdGVtIG9mIHZhbCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhbHNvIGEgQGdyYXBoIGNvbnRhaW5lciwgdHVybiBpdGVtcyBpbnRvIGdyYXBoc1xuICAgICAgaWYoYXNHcmFwaCAmJiAhX2lzR3JhcGgoaXRlbSkpIHtcbiAgICAgICAgaXRlbSA9IHsnQGdyYXBoJzogW2l0ZW1dfTtcbiAgICAgIH1cbiAgICAgIGlmKGluZGV4S2V5ID09PSAnQHR5cGUnKSB7XG4gICAgICAgIGlmKGV4cGFuZGVkS2V5ID09PSAnQG5vbmUnKSB7XG4gICAgICAgICAgLy8gaWdub3JlIEBub25lXG4gICAgICAgIH0gZWxzZSBpZihpdGVtWydAdHlwZSddKSB7XG4gICAgICAgICAgaXRlbVsnQHR5cGUnXSA9IFtrZXldLmNvbmNhdChpdGVtWydAdHlwZSddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWydAdHlwZSddID0gW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZihfaXNWYWx1ZShpdGVtKSAmJlxuICAgICAgICAhWydAbGFuZ3VhZ2UnLCAnQHR5cGUnLCAnQGluZGV4J10uaW5jbHVkZXMoaW5kZXhLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgQXR0ZW1wdCB0byBhZGQgaWxsZWdhbCBrZXkgdG8gdmFsdWUgJyArXG4gICAgICAgICAgYG9iamVjdDogXCIke2luZGV4S2V5fVwiLmAsXG4gICAgICAgICAgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAgICAgICAge2NvZGU6ICdpbnZhbGlkIHZhbHVlIG9iamVjdCcsIHZhbHVlOiBpdGVtfSk7XG4gICAgICB9IGVsc2UgaWYocHJvcGVydHlJbmRleCkge1xuICAgICAgICAvLyBpbmRleCBpcyBhIHByb3BlcnR5IHRvIGJlIGV4cGFuZGVkLCBhbmQgdmFsdWVzIGludGVycHJldGVkIGZvciB0aGF0XG4gICAgICAgIC8vIHByb3BlcnR5XG4gICAgICAgIGlmKGV4cGFuZGVkS2V5ICE9PSAnQG5vbmUnKSB7XG4gICAgICAgICAgLy8gZXhwYW5kIGtleSBhcyBhIHZhbHVlXG4gICAgICAgICAgX2FkZFZhbHVlKGl0ZW0sIHByb3BlcnR5SW5kZXgsIGV4cGFuZGVkS2V5LCB7XG4gICAgICAgICAgICBwcm9wZXJ0eUlzQXJyYXk6IHRydWUsXG4gICAgICAgICAgICBwcmVwZW5kVmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKGV4cGFuZGVkS2V5ICE9PSAnQG5vbmUnICYmICEoaW5kZXhLZXkgaW4gaXRlbSkpIHtcbiAgICAgICAgaXRlbVtpbmRleEtleV0gPSBrZXk7XG4gICAgICB9XG4gICAgICBydmFsLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/expand.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/flatten.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/flatten.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  isSubjectReference: _isSubjectReference\n} = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  createMergedNodeMap: _createMergedNodeMap\n} = __webpack_require__(/*! ./nodeMap */ \"(ssr)/./node_modules/jsonld/lib/nodeMap.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the expanded JSON-LD to flatten.\n *\n * @return the flattened output.\n */\napi.flatten = input => {\n  const defaultGraph = _createMergedNodeMap(input);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n  return flattened;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mbGF0dGVuLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtRUFBYzs7QUFFMUI7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDZEQUFXOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mbGF0dGVuLmpzPzQ0YjQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgaXNTdWJqZWN0UmVmZXJlbmNlOiBfaXNTdWJqZWN0UmVmZXJlbmNlXG59ID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5cbmNvbnN0IHtcbiAgY3JlYXRlTWVyZ2VkTm9kZU1hcDogX2NyZWF0ZU1lcmdlZE5vZGVNYXBcbn0gPSByZXF1aXJlKCcuL25vZGVNYXAnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGZsYXR0ZW5pbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBleHBhbmRlZCBKU09OLUxEIHRvIGZsYXR0ZW4uXG4gKlxuICogQHJldHVybiB0aGUgZmxhdHRlbmVkIG91dHB1dC5cbiAqL1xuYXBpLmZsYXR0ZW4gPSBpbnB1dCA9PiB7XG4gIGNvbnN0IGRlZmF1bHRHcmFwaCA9IF9jcmVhdGVNZXJnZWROb2RlTWFwKGlucHV0KTtcblxuICAvLyBwcm9kdWNlIGZsYXR0ZW5lZCBvdXRwdXRcbiAgY29uc3QgZmxhdHRlbmVkID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0R3JhcGgpLnNvcnQoKTtcbiAgZm9yKGxldCBraSA9IDA7IGtpIDwga2V5cy5sZW5ndGg7ICsra2kpIHtcbiAgICBjb25zdCBub2RlID0gZGVmYXVsdEdyYXBoW2tleXNba2ldXTtcbiAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzIHRvIHRvcC1sZXZlbFxuICAgIGlmKCFfaXNTdWJqZWN0UmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICBmbGF0dGVuZWQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW5lZDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/flatten.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/frame.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/frame.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\nconst url = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\nconst {\n  createNodeMap: _createNodeMap,\n  mergeNodeMapGraphs: _mergeNodeMapGraphs\n} = __webpack_require__(/*! ./nodeMap */ \"(ssr)/./node_modules/jsonld/lib/nodeMap.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Performs JSON-LD `merged` framing.\n *\n * @param input the expanded JSON-LD to frame.\n * @param frame the expanded JSON-LD frame to use.\n * @param options the framing options.\n *\n * @return the framed output.\n */\napi.frameMergedOrDefault = (input, frame, options) => {\n  // create framing state\n  const state = {\n    options,\n    embedded: false,\n    graph: '@default',\n    graphMap: {'@default': {}},\n    subjectStack: [],\n    link: {},\n    bnodeMap: {}\n  };\n\n  // produce a map of all graphs and name each bnode\n  // FIXME: currently uses subjects from @merged graph only\n  const issuer = new util.IdentifierIssuer('_:b');\n  _createNodeMap(input, state.graphMap, '@default', issuer);\n  if(options.merged) {\n    state.graphMap['@merged'] = _mergeNodeMapGraphs(state.graphMap);\n    state.graph = '@merged';\n  }\n  state.subjects = state.graphMap[state.graph];\n\n  // frame the subjects\n  const framed = [];\n  api.frame(state, Object.keys(state.subjects).sort(), frame, framed);\n\n  // If pruning blank nodes, find those to prune\n  if(options.pruneBlankNodeIdentifiers) {\n    // remove all blank nodes appearing only once, done in compaction\n    options.bnodesToClear =\n      Object.keys(state.bnodeMap).filter(id => state.bnodeMap[id].length === 1);\n  }\n\n  // remove @preserve from results\n  options.link = {};\n  return _cleanupPreserve(framed, options);\n};\n\n/**\n * Frames subjects according to the given frame.\n *\n * @param state the current framing state.\n * @param subjects the subjects to filter.\n * @param frame the frame.\n * @param parent the parent subject or top-level array.\n * @param property the parent property, initialized to null.\n */\napi.frame = (state, subjects, frame, parent, property = null) => {\n  // validate the frame\n  _validateFrame(frame);\n  frame = frame[0];\n\n  // get flags for current frame\n  const options = state.options;\n  const flags = {\n    embed: _getFrameFlag(frame, options, 'embed'),\n    explicit: _getFrameFlag(frame, options, 'explicit'),\n    requireAll: _getFrameFlag(frame, options, 'requireAll')\n  };\n\n  // get link for current graph\n  if(!state.link.hasOwnProperty(state.graph)) {\n    state.link[state.graph] = {};\n  }\n  const link = state.link[state.graph];\n\n  // filter out subjects that match the frame\n  const matches = _filterSubjects(state, subjects, frame, flags);\n\n  // add matches to output\n  const ids = Object.keys(matches).sort();\n  for(const id of ids) {\n    const subject = matches[id];\n\n    /* Note: In order to treat each top-level match as a compartmentalized\n    result, clear the unique embedded subjects map when the property is null,\n    which only occurs at the top-level. */\n    if(property === null) {\n      state.uniqueEmbeds = {[state.graph]: {}};\n    } else {\n      state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};\n    }\n\n    if(flags.embed === '@link' && id in link) {\n      // TODO: may want to also match an existing linked subject against\n      // the current frame ... so different frames could produce different\n      // subjects that are only shared in-memory when the frames are the same\n\n      // add existing linked subject\n      _addFrameOutput(parent, property, link[id]);\n      continue;\n    }\n\n    // start output for subject\n    const output = {'@id': id};\n    if(id.indexOf('_:') === 0) {\n      util.addValue(state.bnodeMap, id, output, {propertyIsArray: true});\n    }\n    link[id] = output;\n\n    // validate @embed\n    if((flags.embed === '@first' || flags.embed === '@last') && state.is11) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; invalid value of @embed.',\n        'jsonld.SyntaxError', {code: 'invalid @embed value', frame});\n    }\n\n    if(!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {\n      // skip adding this node object to the top level, as it was\n      // already included in another node object\n      continue;\n    }\n\n    // if embed is @never or if a circular reference would be created by an\n    // embed, the subject cannot be embedded, just add the reference;\n    // note that a circular reference won't occur when the embed flag is\n    // `@link` as the above check will short-circuit before reaching this point\n    if(state.embedded &&\n      (flags.embed === '@never' ||\n      _createsCircularReference(subject, state.graph, state.subjectStack))) {\n      _addFrameOutput(parent, property, output);\n      continue;\n    }\n\n    // if only the first (or once) should be embedded\n    if(state.embedded &&\n       (flags.embed == '@first' || flags.embed == '@once') &&\n       state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {\n      _addFrameOutput(parent, property, output);\n      continue;\n    }\n\n    // if only the last match should be embedded\n    if(flags.embed === '@last') {\n      // remove any existing embed\n      if(id in state.uniqueEmbeds[state.graph]) {\n        _removeEmbed(state, id);\n      }\n    }\n\n    state.uniqueEmbeds[state.graph][id] = {parent, property};\n\n    // push matching subject onto stack to enable circular embed checks\n    state.subjectStack.push({subject, graph: state.graph});\n\n    // subject is also the name of a graph\n    if(id in state.graphMap) {\n      let recurse = false;\n      let subframe = null;\n      if(!('@graph' in frame)) {\n        recurse = state.graph !== '@merged';\n        subframe = {};\n      } else {\n        subframe = frame['@graph'][0];\n        recurse = !(id === '@merged' || id === '@default');\n        if(!types.isObject(subframe)) {\n          subframe = {};\n        }\n      }\n\n      if(recurse) {\n        // recurse into graph\n        api.frame(\n          {...state, graph: id, embedded: false},\n          Object.keys(state.graphMap[id]).sort(), [subframe], output, '@graph');\n      }\n    }\n\n    // if frame has @included, recurse over its sub-frame\n    if('@included' in frame) {\n      api.frame(\n        {...state, embedded: false},\n        subjects, frame['@included'], output, '@included');\n    }\n\n    // iterate over subject properties\n    for(const prop of Object.keys(subject).sort()) {\n      // copy keywords to output\n      if(isKeyword(prop)) {\n        output[prop] = util.clone(subject[prop]);\n\n        if(prop === '@type') {\n          // count bnode values of @type\n          for(const type of subject['@type']) {\n            if(type.indexOf('_:') === 0) {\n              util.addValue(\n                state.bnodeMap, type, output, {propertyIsArray: true});\n            }\n          }\n        }\n        continue;\n      }\n\n      // explicit is on and property isn't in the frame, skip processing\n      if(flags.explicit && !(prop in frame)) {\n        continue;\n      }\n\n      // add objects\n      for(const o of subject[prop]) {\n        const subframe = (prop in frame ?\n          frame[prop] : _createImplicitFrame(flags));\n\n        // recurse into list\n        if(graphTypes.isList(o)) {\n          const subframe =\n            (frame[prop] && frame[prop][0] && frame[prop][0]['@list']) ?\n              frame[prop][0]['@list'] :\n              _createImplicitFrame(flags);\n\n          // add empty list\n          const list = {'@list': []};\n          _addFrameOutput(output, prop, list);\n\n          // add list objects\n          const src = o['@list'];\n          for(const oo of src) {\n            if(graphTypes.isSubjectReference(oo)) {\n              // recurse into subject reference\n              api.frame(\n                {...state, embedded: true},\n                [oo['@id']], subframe, list, '@list');\n            } else {\n              // include other values automatically\n              _addFrameOutput(list, '@list', util.clone(oo));\n            }\n          }\n        } else if(graphTypes.isSubjectReference(o)) {\n          // recurse into subject reference\n          api.frame(\n            {...state, embedded: true},\n            [o['@id']], subframe, output, prop);\n        } else if(_valueMatch(subframe[0], o)) {\n          // include other values, if they match\n          _addFrameOutput(output, prop, util.clone(o));\n        }\n      }\n    }\n\n    // handle defaults\n    for(const prop of Object.keys(frame).sort()) {\n      // skip keywords\n      if(prop === '@type') {\n        if(!types.isObject(frame[prop][0]) ||\n           !('@default' in frame[prop][0])) {\n          continue;\n        }\n        // allow through default types\n      } else if(isKeyword(prop)) {\n        continue;\n      }\n\n      // if omit default is off, then include default values for properties\n      // that appear in the next frame but are not in the matching subject\n      const next = frame[prop][0] || {};\n      const omitDefaultOn = _getFrameFlag(next, options, 'omitDefault');\n      if(!omitDefaultOn && !(prop in output)) {\n        let preserve = '@null';\n        if('@default' in next) {\n          preserve = util.clone(next['@default']);\n        }\n        if(!types.isArray(preserve)) {\n          preserve = [preserve];\n        }\n        output[prop] = [{'@preserve': preserve}];\n      }\n    }\n\n    // if embed reverse values by finding nodes having this subject as a value\n    // of the associated property\n    for(const reverseProp of Object.keys(frame['@reverse'] || {}).sort()) {\n      const subframe = frame['@reverse'][reverseProp];\n      for(const subject of Object.keys(state.subjects)) {\n        const nodeValues =\n          util.getValues(state.subjects[subject], reverseProp);\n        if(nodeValues.some(v => v['@id'] === id)) {\n          // node has property referencing this subject, recurse\n          output['@reverse'] = output['@reverse'] || {};\n          util.addValue(\n            output['@reverse'], reverseProp, [], {propertyIsArray: true});\n          api.frame(\n            {...state, embedded: true},\n            [subject], subframe, output['@reverse'][reverseProp],\n            property);\n        }\n      }\n    }\n\n    // add output to parent\n    _addFrameOutput(parent, property, output);\n\n    // pop matching subject from circular ref-checking stack\n    state.subjectStack.pop();\n  }\n};\n\n/**\n * Replace `@null` with `null`, removing it from arrays.\n *\n * @param input the framed, compacted output.\n * @param options the framing options used.\n *\n * @return the resulting output.\n */\napi.cleanupNull = (input, options) => {\n  // recurse through arrays\n  if(types.isArray(input)) {\n    const noNulls = input.map(v => api.cleanupNull(v, options));\n    return noNulls.filter(v => v); // removes nulls from array\n  }\n\n  if(input === '@null') {\n    return null;\n  }\n\n  if(types.isObject(input)) {\n    // handle in-memory linked nodes\n    if('@id' in input) {\n      const id = input['@id'];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    for(const key in input) {\n      input[key] = api.cleanupNull(input[key], options);\n    }\n  }\n  return input;\n};\n\n/**\n * Creates an implicit frame when recursing through subject matches. If\n * a frame doesn't have an explicit frame for a particular property, then\n * a wildcard child frame will be created that uses the same flags that the\n * parent frame used.\n *\n * @param flags the current framing flags.\n *\n * @return the implicit frame.\n */\nfunction _createImplicitFrame(flags) {\n  const frame = {};\n  for(const key in flags) {\n    if(flags[key] !== undefined) {\n      frame['@' + key] = [flags[key]];\n    }\n  }\n  return [frame];\n}\n\n/**\n * Checks the current subject stack to see if embedding the given subject\n * would cause a circular reference.\n *\n * @param subjectToEmbed the subject to embed.\n * @param graph the graph the subject to embed is in.\n * @param subjectStack the current stack of subjects.\n *\n * @return true if a circular reference would be created, false if not.\n */\nfunction _createsCircularReference(subjectToEmbed, graph, subjectStack) {\n  for(let i = subjectStack.length - 1; i >= 0; --i) {\n    const subject = subjectStack[i];\n    if(subject.graph === graph &&\n      subject.subject['@id'] === subjectToEmbed['@id']) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Gets the frame flag value for the given flag name.\n *\n * @param frame the frame.\n * @param options the framing options.\n * @param name the flag name.\n *\n * @return the flag value.\n */\nfunction _getFrameFlag(frame, options, name) {\n  const flag = '@' + name;\n  let rval = (flag in frame ? frame[flag][0] : options[name]);\n  if(name === 'embed') {\n    // default is \"@last\"\n    // backwards-compatibility support for \"embed\" maps:\n    // true => \"@last\"\n    // false => \"@never\"\n    if(rval === true) {\n      rval = '@once';\n    } else if(rval === false) {\n      rval = '@never';\n    } else if(rval !== '@always' && rval !== '@never' && rval !== '@link' &&\n      rval !== '@first' && rval !== '@last' && rval !== '@once') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; invalid value of @embed.',\n        'jsonld.SyntaxError', {code: 'invalid @embed value', frame});\n    }\n  }\n  return rval;\n}\n\n/**\n * Validates a JSON-LD frame, throwing an exception if the frame is invalid.\n *\n * @param frame the frame to validate.\n */\nfunction _validateFrame(frame) {\n  if(!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a JSON-LD frame must be a single object.',\n      'jsonld.SyntaxError', {frame});\n  }\n\n  if('@id' in frame[0]) {\n    for(const id of util.asArray(frame[0]['@id'])) {\n      // @id must be wildcard or an IRI\n      if(!(types.isObject(id) || url.isAbsolute(id)) ||\n        (types.isString(id) && id.indexOf('_:') === 0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; invalid @id in frame.',\n          'jsonld.SyntaxError', {code: 'invalid frame', frame});\n      }\n    }\n  }\n\n  if('@type' in frame[0]) {\n    for(const type of util.asArray(frame[0]['@type'])) {\n      // @type must be wildcard, IRI, or @json\n      if(!(types.isObject(type) || url.isAbsolute(type) ||\n          (type === '@json')) ||\n        (types.isString(type) && type.indexOf('_:') === 0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; invalid @type in frame.',\n          'jsonld.SyntaxError', {code: 'invalid frame', frame});\n      }\n    }\n  }\n}\n\n/**\n * Returns a map of all of the subjects that match a parsed frame.\n *\n * @param state the current framing state.\n * @param subjects the set of subjects to filter.\n * @param frame the parsed frame.\n * @param flags the frame flags.\n *\n * @return all of the matched subjects.\n */\nfunction _filterSubjects(state, subjects, frame, flags) {\n  // filter subjects in @id order\n  const rval = {};\n  for(const id of subjects) {\n    const subject = state.graphMap[state.graph][id];\n    if(_filterSubject(state, subject, frame, flags)) {\n      rval[id] = subject;\n    }\n  }\n  return rval;\n}\n\n/**\n * Returns true if the given subject matches the given frame.\n *\n * Matches either based on explicit type inclusion where the node has any\n * type listed in the frame. If the frame has empty types defined matches\n * nodes not having a @type. If the frame has a type of {} defined matches\n * nodes having any type defined.\n *\n * Otherwise, does duck typing, where the node must have all of the\n * properties defined in the frame.\n *\n * @param state the current framing state.\n * @param subject the subject to check.\n * @param frame the frame to check.\n * @param flags the frame flags.\n *\n * @return true if the subject matches, false if not.\n */\nfunction _filterSubject(state, subject, frame, flags) {\n  // check ducktype\n  let wildcard = true;\n  let matchesSome = false;\n\n  for(const key in frame) {\n    let matchThis = false;\n    const nodeValues = util.getValues(subject, key);\n    const isEmpty = util.getValues(frame, key).length === 0;\n\n    if(key === '@id') {\n      // match on no @id or any matching @id, including wildcard\n      if(types.isEmptyObject(frame['@id'][0] || {})) {\n        matchThis = true;\n      } else if(frame['@id'].length >= 0) {\n        matchThis = frame['@id'].includes(nodeValues[0]);\n      }\n      if(!flags.requireAll) {\n        return matchThis;\n      }\n    } else if(key === '@type') {\n      // check @type (object value means 'any' type,\n      // fall through to ducktyping)\n      wildcard = false;\n      if(isEmpty) {\n        if(nodeValues.length > 0) {\n          // don't match on no @type\n          return false;\n        }\n        matchThis = true;\n      } else if(frame['@type'].length === 1 &&\n        types.isEmptyObject(frame['@type'][0])) {\n        // match on wildcard @type if there is a type\n        matchThis = nodeValues.length > 0;\n      } else {\n        // match on a specific @type\n        for(const type of frame['@type']) {\n          if(types.isObject(type) && '@default' in type) {\n            // match on default object\n            matchThis = true;\n          } else {\n            matchThis = matchThis || nodeValues.some(tt => tt === type);\n          }\n        }\n      }\n      if(!flags.requireAll) {\n        return matchThis;\n      }\n    } else if(isKeyword(key)) {\n      continue;\n    } else {\n      // Force a copy of this frame entry so it can be manipulated\n      const thisFrame = util.getValues(frame, key)[0];\n      let hasDefault = false;\n      if(thisFrame) {\n        _validateFrame([thisFrame]);\n        hasDefault = '@default' in thisFrame;\n      }\n\n      // no longer a wildcard pattern if frame has any non-keyword properties\n      wildcard = false;\n\n      // skip, but allow match if node has no value for property, and frame has\n      // a default value\n      if(nodeValues.length === 0 && hasDefault) {\n        continue;\n      }\n\n      // if frame value is empty, don't match if subject has any value\n      if(nodeValues.length > 0 && isEmpty) {\n        return false;\n      }\n\n      if(thisFrame === undefined) {\n        // node does not match if values is not empty and the value of property\n        // in frame is match none.\n        if(nodeValues.length > 0) {\n          return false;\n        }\n        matchThis = true;\n      } else {\n        if(graphTypes.isList(thisFrame)) {\n          const listValue = thisFrame['@list'][0];\n          if(graphTypes.isList(nodeValues[0])) {\n            const nodeListValues = nodeValues[0]['@list'];\n\n            if(graphTypes.isValue(listValue)) {\n              // match on any matching value\n              matchThis = nodeListValues.some(lv => _valueMatch(listValue, lv));\n            } else if(graphTypes.isSubject(listValue) ||\n              graphTypes.isSubjectReference(listValue)) {\n              matchThis = nodeListValues.some(lv => _nodeMatch(\n                state, listValue, lv, flags));\n            }\n          }\n        } else if(graphTypes.isValue(thisFrame)) {\n          matchThis = nodeValues.some(nv => _valueMatch(thisFrame, nv));\n        } else if(graphTypes.isSubjectReference(thisFrame)) {\n          matchThis =\n            nodeValues.some(nv => _nodeMatch(state, thisFrame, nv, flags));\n        } else if(types.isObject(thisFrame)) {\n          matchThis = nodeValues.length > 0;\n        } else {\n          matchThis = false;\n        }\n      }\n    }\n\n    // all non-defaulted values must match if requireAll is set\n    if(!matchThis && flags.requireAll) {\n      return false;\n    }\n\n    matchesSome = matchesSome || matchThis;\n  }\n\n  // return true if wildcard or subject matches some properties\n  return wildcard || matchesSome;\n}\n\n/**\n * Removes an existing embed.\n *\n * @param state the current framing state.\n * @param id the @id of the embed to remove.\n */\nfunction _removeEmbed(state, id) {\n  // get existing embed\n  const embeds = state.uniqueEmbeds[state.graph];\n  const embed = embeds[id];\n  const parent = embed.parent;\n  const property = embed.property;\n\n  // create reference to replace embed\n  const subject = {'@id': id};\n\n  // remove existing embed\n  if(types.isArray(parent)) {\n    // replace subject with reference\n    for(let i = 0; i < parent.length; ++i) {\n      if(util.compareValues(parent[i], subject)) {\n        parent[i] = subject;\n        break;\n      }\n    }\n  } else {\n    // replace subject with reference\n    const useArray = types.isArray(parent[property]);\n    util.removeValue(parent, property, subject, {propertyIsArray: useArray});\n    util.addValue(parent, property, subject, {propertyIsArray: useArray});\n  }\n\n  // recursively remove dependent dangling embeds\n  const removeDependents = id => {\n    // get embed keys as a separate array to enable deleting keys in map\n    const ids = Object.keys(embeds);\n    for(const next of ids) {\n      if(next in embeds && types.isObject(embeds[next].parent) &&\n        embeds[next].parent['@id'] === id) {\n        delete embeds[next];\n        removeDependents(next);\n      }\n    }\n  };\n  removeDependents(id);\n}\n\n/**\n * Removes the @preserve keywords from expanded result of framing.\n *\n * @param input the framed, framed output.\n * @param options the framing options used.\n *\n * @return the resulting output.\n */\nfunction _cleanupPreserve(input, options) {\n  // recurse through arrays\n  if(types.isArray(input)) {\n    return input.map(value => _cleanupPreserve(value, options));\n  }\n\n  if(types.isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      return input['@preserve'][0];\n    }\n\n    // skip @values\n    if(graphTypes.isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(graphTypes.isList(input)) {\n      input['@list'] = _cleanupPreserve(input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    if('@id' in input) {\n      const id = input['@id'];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === '@id' && options.bnodesToClear.includes(input[prop])) {\n        delete input['@id'];\n        continue;\n      }\n\n      input[prop] = _cleanupPreserve(input[prop], options);\n    }\n  }\n  return input;\n}\n\n/**\n * Adds framing output to the given parent.\n *\n * @param parent the parent to add to.\n * @param property the parent property.\n * @param output the output to add.\n */\nfunction _addFrameOutput(parent, property, output) {\n  if(types.isObject(parent)) {\n    util.addValue(parent, property, output, {propertyIsArray: true});\n  } else {\n    parent.push(output);\n  }\n}\n\n/**\n * Node matches if it is a node, and matches the pattern as a frame.\n *\n * @param state the current framing state.\n * @param pattern used to match value\n * @param value to check\n * @param flags the frame flags.\n */\nfunction _nodeMatch(state, pattern, value, flags) {\n  if(!('@id' in value)) {\n    return false;\n  }\n  const nodeObject = state.subjects[value['@id']];\n  return nodeObject && _filterSubject(state, nodeObject, pattern, flags);\n}\n\n/**\n * Value matches if it is a value and matches the value pattern\n *\n * * `pattern` is empty\n * * @values are the same, or `pattern[@value]` is a wildcard, and\n * * @types are the same or `value[@type]` is not null\n *   and `pattern[@type]` is `{}`, or `value[@type]` is null\n *   and `pattern[@type]` is null or `[]`, and\n * * @languages are the same or `value[@language]` is not null\n *   and `pattern[@language]` is `{}`, or `value[@language]` is null\n *   and `pattern[@language]` is null or `[]`.\n *\n * @param pattern used to match value\n * @param value to check\n */\nfunction _valueMatch(pattern, value) {\n  const v1 = value['@value'];\n  const t1 = value['@type'];\n  const l1 = value['@language'];\n  const v2 = pattern['@value'] ?\n    (types.isArray(pattern['@value']) ?\n      pattern['@value'] : [pattern['@value']]) :\n    [];\n  const t2 = pattern['@type'] ?\n    (types.isArray(pattern['@type']) ?\n      pattern['@type'] : [pattern['@type']]) :\n    [];\n  const l2 = pattern['@language'] ?\n    (types.isArray(pattern['@language']) ?\n      pattern['@language'] : [pattern['@language']]) :\n    [];\n\n  if(v2.length === 0 && t2.length === 0 && l2.length === 0) {\n    return true;\n  }\n  if(!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {\n    return false;\n  }\n  if(!(!t1 && t2.length === 0 || t2.includes(t1) || t1 &&\n    types.isEmptyObject(t2[0]))) {\n    return false;\n  }\n  if(!(!l1 && l2.length === 0 || l2.includes(l1) || l1 &&\n    types.isEmptyObject(l2[0]))) {\n    return false;\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mcmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixPQUFPLFdBQVcsRUFBRSxtQkFBTyxDQUFDLDZEQUFXO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLG1FQUFjO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyx5REFBUztBQUMvQixhQUFhLG1CQUFPLENBQUMsdURBQVE7QUFDN0IsWUFBWSxtQkFBTyxDQUFDLHFEQUFPO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLHFFQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDZEQUFXOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGlEQUFpRCxzQkFBc0I7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCLG9DQUFvQztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQSw2QkFBNkIsNEJBQTRCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQ0FBcUM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLCtCQUErQixvQ0FBb0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw2QkFBNkIsTUFBTTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUNBQWlDLDZCQUE2QjtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUNBQWlDLDZCQUE2QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFLDhDQUE4QywwQkFBMEI7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkUsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZnJhbWUuanM/YTU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qge2lzS2V5d29yZH0gPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcbmNvbnN0IGdyYXBoVHlwZXMgPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuY29uc3Qge1xuICBjcmVhdGVOb2RlTWFwOiBfY3JlYXRlTm9kZU1hcCxcbiAgbWVyZ2VOb2RlTWFwR3JhcGhzOiBfbWVyZ2VOb2RlTWFwR3JhcGhzXG59ID0gcmVxdWlyZSgnLi9ub2RlTWFwJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8qKlxuICogUGVyZm9ybXMgSlNPTi1MRCBgbWVyZ2VkYCBmcmFtaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgZXhwYW5kZWQgSlNPTi1MRCB0byBmcmFtZS5cbiAqIEBwYXJhbSBmcmFtZSB0aGUgZXhwYW5kZWQgSlNPTi1MRCBmcmFtZSB0byB1c2UuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgZnJhbWluZyBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIGZyYW1lZCBvdXRwdXQuXG4gKi9cbmFwaS5mcmFtZU1lcmdlZE9yRGVmYXVsdCA9IChpbnB1dCwgZnJhbWUsIG9wdGlvbnMpID0+IHtcbiAgLy8gY3JlYXRlIGZyYW1pbmcgc3RhdGVcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgb3B0aW9ucyxcbiAgICBlbWJlZGRlZDogZmFsc2UsXG4gICAgZ3JhcGg6ICdAZGVmYXVsdCcsXG4gICAgZ3JhcGhNYXA6IHsnQGRlZmF1bHQnOiB7fX0sXG4gICAgc3ViamVjdFN0YWNrOiBbXSxcbiAgICBsaW5rOiB7fSxcbiAgICBibm9kZU1hcDoge31cbiAgfTtcblxuICAvLyBwcm9kdWNlIGEgbWFwIG9mIGFsbCBncmFwaHMgYW5kIG5hbWUgZWFjaCBibm9kZVxuICAvLyBGSVhNRTogY3VycmVudGx5IHVzZXMgc3ViamVjdHMgZnJvbSBAbWVyZ2VkIGdyYXBoIG9ubHlcbiAgY29uc3QgaXNzdWVyID0gbmV3IHV0aWwuSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG4gIF9jcmVhdGVOb2RlTWFwKGlucHV0LCBzdGF0ZS5ncmFwaE1hcCwgJ0BkZWZhdWx0JywgaXNzdWVyKTtcbiAgaWYob3B0aW9ucy5tZXJnZWQpIHtcbiAgICBzdGF0ZS5ncmFwaE1hcFsnQG1lcmdlZCddID0gX21lcmdlTm9kZU1hcEdyYXBocyhzdGF0ZS5ncmFwaE1hcCk7XG4gICAgc3RhdGUuZ3JhcGggPSAnQG1lcmdlZCc7XG4gIH1cbiAgc3RhdGUuc3ViamVjdHMgPSBzdGF0ZS5ncmFwaE1hcFtzdGF0ZS5ncmFwaF07XG5cbiAgLy8gZnJhbWUgdGhlIHN1YmplY3RzXG4gIGNvbnN0IGZyYW1lZCA9IFtdO1xuICBhcGkuZnJhbWUoc3RhdGUsIE9iamVjdC5rZXlzKHN0YXRlLnN1YmplY3RzKS5zb3J0KCksIGZyYW1lLCBmcmFtZWQpO1xuXG4gIC8vIElmIHBydW5pbmcgYmxhbmsgbm9kZXMsIGZpbmQgdGhvc2UgdG8gcHJ1bmVcbiAgaWYob3B0aW9ucy5wcnVuZUJsYW5rTm9kZUlkZW50aWZpZXJzKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCBibGFuayBub2RlcyBhcHBlYXJpbmcgb25seSBvbmNlLCBkb25lIGluIGNvbXBhY3Rpb25cbiAgICBvcHRpb25zLmJub2Rlc1RvQ2xlYXIgPVxuICAgICAgT2JqZWN0LmtleXMoc3RhdGUuYm5vZGVNYXApLmZpbHRlcihpZCA9PiBzdGF0ZS5ibm9kZU1hcFtpZF0ubGVuZ3RoID09PSAxKTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBAcHJlc2VydmUgZnJvbSByZXN1bHRzXG4gIG9wdGlvbnMubGluayA9IHt9O1xuICByZXR1cm4gX2NsZWFudXBQcmVzZXJ2ZShmcmFtZWQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBGcmFtZXMgc3ViamVjdHMgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBzdWJqZWN0cyB0aGUgc3ViamVjdHMgdG8gZmlsdGVyLlxuICogQHBhcmFtIGZyYW1lIHRoZSBmcmFtZS5cbiAqIEBwYXJhbSBwYXJlbnQgdGhlIHBhcmVudCBzdWJqZWN0IG9yIHRvcC1sZXZlbCBhcnJheS5cbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUgcGFyZW50IHByb3BlcnR5LCBpbml0aWFsaXplZCB0byBudWxsLlxuICovXG5hcGkuZnJhbWUgPSAoc3RhdGUsIHN1YmplY3RzLCBmcmFtZSwgcGFyZW50LCBwcm9wZXJ0eSA9IG51bGwpID0+IHtcbiAgLy8gdmFsaWRhdGUgdGhlIGZyYW1lXG4gIF92YWxpZGF0ZUZyYW1lKGZyYW1lKTtcbiAgZnJhbWUgPSBmcmFtZVswXTtcblxuICAvLyBnZXQgZmxhZ3MgZm9yIGN1cnJlbnQgZnJhbWVcbiAgY29uc3Qgb3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gIGNvbnN0IGZsYWdzID0ge1xuICAgIGVtYmVkOiBfZ2V0RnJhbWVGbGFnKGZyYW1lLCBvcHRpb25zLCAnZW1iZWQnKSxcbiAgICBleHBsaWNpdDogX2dldEZyYW1lRmxhZyhmcmFtZSwgb3B0aW9ucywgJ2V4cGxpY2l0JyksXG4gICAgcmVxdWlyZUFsbDogX2dldEZyYW1lRmxhZyhmcmFtZSwgb3B0aW9ucywgJ3JlcXVpcmVBbGwnKVxuICB9O1xuXG4gIC8vIGdldCBsaW5rIGZvciBjdXJyZW50IGdyYXBoXG4gIGlmKCFzdGF0ZS5saW5rLmhhc093blByb3BlcnR5KHN0YXRlLmdyYXBoKSkge1xuICAgIHN0YXRlLmxpbmtbc3RhdGUuZ3JhcGhdID0ge307XG4gIH1cbiAgY29uc3QgbGluayA9IHN0YXRlLmxpbmtbc3RhdGUuZ3JhcGhdO1xuXG4gIC8vIGZpbHRlciBvdXQgc3ViamVjdHMgdGhhdCBtYXRjaCB0aGUgZnJhbWVcbiAgY29uc3QgbWF0Y2hlcyA9IF9maWx0ZXJTdWJqZWN0cyhzdGF0ZSwgc3ViamVjdHMsIGZyYW1lLCBmbGFncyk7XG5cbiAgLy8gYWRkIG1hdGNoZXMgdG8gb3V0cHV0XG4gIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKG1hdGNoZXMpLnNvcnQoKTtcbiAgZm9yKGNvbnN0IGlkIG9mIGlkcykge1xuICAgIGNvbnN0IHN1YmplY3QgPSBtYXRjaGVzW2lkXTtcblxuICAgIC8qIE5vdGU6IEluIG9yZGVyIHRvIHRyZWF0IGVhY2ggdG9wLWxldmVsIG1hdGNoIGFzIGEgY29tcGFydG1lbnRhbGl6ZWRcbiAgICByZXN1bHQsIGNsZWFyIHRoZSB1bmlxdWUgZW1iZWRkZWQgc3ViamVjdHMgbWFwIHdoZW4gdGhlIHByb3BlcnR5IGlzIG51bGwsXG4gICAgd2hpY2ggb25seSBvY2N1cnMgYXQgdGhlIHRvcC1sZXZlbC4gKi9cbiAgICBpZihwcm9wZXJ0eSA9PT0gbnVsbCkge1xuICAgICAgc3RhdGUudW5pcXVlRW1iZWRzID0ge1tzdGF0ZS5ncmFwaF06IHt9fTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUudW5pcXVlRW1iZWRzW3N0YXRlLmdyYXBoXSA9IHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF0gfHwge307XG4gICAgfVxuXG4gICAgaWYoZmxhZ3MuZW1iZWQgPT09ICdAbGluaycgJiYgaWQgaW4gbGluaykge1xuICAgICAgLy8gVE9ETzogbWF5IHdhbnQgdG8gYWxzbyBtYXRjaCBhbiBleGlzdGluZyBsaW5rZWQgc3ViamVjdCBhZ2FpbnN0XG4gICAgICAvLyB0aGUgY3VycmVudCBmcmFtZSAuLi4gc28gZGlmZmVyZW50IGZyYW1lcyBjb3VsZCBwcm9kdWNlIGRpZmZlcmVudFxuICAgICAgLy8gc3ViamVjdHMgdGhhdCBhcmUgb25seSBzaGFyZWQgaW4tbWVtb3J5IHdoZW4gdGhlIGZyYW1lcyBhcmUgdGhlIHNhbWVcblxuICAgICAgLy8gYWRkIGV4aXN0aW5nIGxpbmtlZCBzdWJqZWN0XG4gICAgICBfYWRkRnJhbWVPdXRwdXQocGFyZW50LCBwcm9wZXJ0eSwgbGlua1tpZF0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQgb3V0cHV0IGZvciBzdWJqZWN0XG4gICAgY29uc3Qgb3V0cHV0ID0geydAaWQnOiBpZH07XG4gICAgaWYoaWQuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgdXRpbC5hZGRWYWx1ZShzdGF0ZS5ibm9kZU1hcCwgaWQsIG91dHB1dCwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgIH1cbiAgICBsaW5rW2lkXSA9IG91dHB1dDtcblxuICAgIC8vIHZhbGlkYXRlIEBlbWJlZFxuICAgIGlmKChmbGFncy5lbWJlZCA9PT0gJ0BmaXJzdCcgfHwgZmxhZ3MuZW1iZWQgPT09ICdAbGFzdCcpICYmIHN0YXRlLmlzMTEpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGludmFsaWQgdmFsdWUgb2YgQGVtYmVkLicsXG4gICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgQGVtYmVkIHZhbHVlJywgZnJhbWV9KTtcbiAgICB9XG5cbiAgICBpZighc3RhdGUuZW1iZWRkZWQgJiYgc3RhdGUudW5pcXVlRW1iZWRzW3N0YXRlLmdyYXBoXS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIC8vIHNraXAgYWRkaW5nIHRoaXMgbm9kZSBvYmplY3QgdG8gdGhlIHRvcCBsZXZlbCwgYXMgaXQgd2FzXG4gICAgICAvLyBhbHJlYWR5IGluY2x1ZGVkIGluIGFub3RoZXIgbm9kZSBvYmplY3RcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGVtYmVkIGlzIEBuZXZlciBvciBpZiBhIGNpcmN1bGFyIHJlZmVyZW5jZSB3b3VsZCBiZSBjcmVhdGVkIGJ5IGFuXG4gICAgLy8gZW1iZWQsIHRoZSBzdWJqZWN0IGNhbm5vdCBiZSBlbWJlZGRlZCwganVzdCBhZGQgdGhlIHJlZmVyZW5jZTtcbiAgICAvLyBub3RlIHRoYXQgYSBjaXJjdWxhciByZWZlcmVuY2Ugd29uJ3Qgb2NjdXIgd2hlbiB0aGUgZW1iZWQgZmxhZyBpc1xuICAgIC8vIGBAbGlua2AgYXMgdGhlIGFib3ZlIGNoZWNrIHdpbGwgc2hvcnQtY2lyY3VpdCBiZWZvcmUgcmVhY2hpbmcgdGhpcyBwb2ludFxuICAgIGlmKHN0YXRlLmVtYmVkZGVkICYmXG4gICAgICAoZmxhZ3MuZW1iZWQgPT09ICdAbmV2ZXInIHx8XG4gICAgICBfY3JlYXRlc0NpcmN1bGFyUmVmZXJlbmNlKHN1YmplY3QsIHN0YXRlLmdyYXBoLCBzdGF0ZS5zdWJqZWN0U3RhY2spKSkge1xuICAgICAgX2FkZEZyYW1lT3V0cHV0KHBhcmVudCwgcHJvcGVydHksIG91dHB1dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBvbmx5IHRoZSBmaXJzdCAob3Igb25jZSkgc2hvdWxkIGJlIGVtYmVkZGVkXG4gICAgaWYoc3RhdGUuZW1iZWRkZWQgJiZcbiAgICAgICAoZmxhZ3MuZW1iZWQgPT0gJ0BmaXJzdCcgfHwgZmxhZ3MuZW1iZWQgPT0gJ0BvbmNlJykgJiZcbiAgICAgICBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgX2FkZEZyYW1lT3V0cHV0KHBhcmVudCwgcHJvcGVydHksIG91dHB1dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBvbmx5IHRoZSBsYXN0IG1hdGNoIHNob3VsZCBiZSBlbWJlZGRlZFxuICAgIGlmKGZsYWdzLmVtYmVkID09PSAnQGxhc3QnKSB7XG4gICAgICAvLyByZW1vdmUgYW55IGV4aXN0aW5nIGVtYmVkXG4gICAgICBpZihpZCBpbiBzdGF0ZS51bmlxdWVFbWJlZHNbc3RhdGUuZ3JhcGhdKSB7XG4gICAgICAgIF9yZW1vdmVFbWJlZChzdGF0ZSwgaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF1baWRdID0ge3BhcmVudCwgcHJvcGVydHl9O1xuXG4gICAgLy8gcHVzaCBtYXRjaGluZyBzdWJqZWN0IG9udG8gc3RhY2sgdG8gZW5hYmxlIGNpcmN1bGFyIGVtYmVkIGNoZWNrc1xuICAgIHN0YXRlLnN1YmplY3RTdGFjay5wdXNoKHtzdWJqZWN0LCBncmFwaDogc3RhdGUuZ3JhcGh9KTtcblxuICAgIC8vIHN1YmplY3QgaXMgYWxzbyB0aGUgbmFtZSBvZiBhIGdyYXBoXG4gICAgaWYoaWQgaW4gc3RhdGUuZ3JhcGhNYXApIHtcbiAgICAgIGxldCByZWN1cnNlID0gZmFsc2U7XG4gICAgICBsZXQgc3ViZnJhbWUgPSBudWxsO1xuICAgICAgaWYoISgnQGdyYXBoJyBpbiBmcmFtZSkpIHtcbiAgICAgICAgcmVjdXJzZSA9IHN0YXRlLmdyYXBoICE9PSAnQG1lcmdlZCc7XG4gICAgICAgIHN1YmZyYW1lID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJmcmFtZSA9IGZyYW1lWydAZ3JhcGgnXVswXTtcbiAgICAgICAgcmVjdXJzZSA9ICEoaWQgPT09ICdAbWVyZ2VkJyB8fCBpZCA9PT0gJ0BkZWZhdWx0Jyk7XG4gICAgICAgIGlmKCF0eXBlcy5pc09iamVjdChzdWJmcmFtZSkpIHtcbiAgICAgICAgICBzdWJmcmFtZSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHJlY3Vyc2UpIHtcbiAgICAgICAgLy8gcmVjdXJzZSBpbnRvIGdyYXBoXG4gICAgICAgIGFwaS5mcmFtZShcbiAgICAgICAgICB7Li4uc3RhdGUsIGdyYXBoOiBpZCwgZW1iZWRkZWQ6IGZhbHNlfSxcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZS5ncmFwaE1hcFtpZF0pLnNvcnQoKSwgW3N1YmZyYW1lXSwgb3V0cHV0LCAnQGdyYXBoJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgZnJhbWUgaGFzIEBpbmNsdWRlZCwgcmVjdXJzZSBvdmVyIGl0cyBzdWItZnJhbWVcbiAgICBpZignQGluY2x1ZGVkJyBpbiBmcmFtZSkge1xuICAgICAgYXBpLmZyYW1lKFxuICAgICAgICB7Li4uc3RhdGUsIGVtYmVkZGVkOiBmYWxzZX0sXG4gICAgICAgIHN1YmplY3RzLCBmcmFtZVsnQGluY2x1ZGVkJ10sIG91dHB1dCwgJ0BpbmNsdWRlZCcpO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBzdWJqZWN0IHByb3BlcnRpZXNcbiAgICBmb3IoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyhzdWJqZWN0KS5zb3J0KCkpIHtcbiAgICAgIC8vIGNvcHkga2V5d29yZHMgdG8gb3V0cHV0XG4gICAgICBpZihpc0tleXdvcmQocHJvcCkpIHtcbiAgICAgICAgb3V0cHV0W3Byb3BdID0gdXRpbC5jbG9uZShzdWJqZWN0W3Byb3BdKTtcblxuICAgICAgICBpZihwcm9wID09PSAnQHR5cGUnKSB7XG4gICAgICAgICAgLy8gY291bnQgYm5vZGUgdmFsdWVzIG9mIEB0eXBlXG4gICAgICAgICAgZm9yKGNvbnN0IHR5cGUgb2Ygc3ViamVjdFsnQHR5cGUnXSkge1xuICAgICAgICAgICAgaWYodHlwZS5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICAgICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgICAgICAgc3RhdGUuYm5vZGVNYXAsIHR5cGUsIG91dHB1dCwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZXhwbGljaXQgaXMgb24gYW5kIHByb3BlcnR5IGlzbid0IGluIHRoZSBmcmFtZSwgc2tpcCBwcm9jZXNzaW5nXG4gICAgICBpZihmbGFncy5leHBsaWNpdCAmJiAhKHByb3AgaW4gZnJhbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgb2JqZWN0c1xuICAgICAgZm9yKGNvbnN0IG8gb2Ygc3ViamVjdFtwcm9wXSkge1xuICAgICAgICBjb25zdCBzdWJmcmFtZSA9IChwcm9wIGluIGZyYW1lID9cbiAgICAgICAgICBmcmFtZVtwcm9wXSA6IF9jcmVhdGVJbXBsaWNpdEZyYW1lKGZsYWdzKSk7XG5cbiAgICAgICAgLy8gcmVjdXJzZSBpbnRvIGxpc3RcbiAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc0xpc3QobykpIHtcbiAgICAgICAgICBjb25zdCBzdWJmcmFtZSA9XG4gICAgICAgICAgICAoZnJhbWVbcHJvcF0gJiYgZnJhbWVbcHJvcF1bMF0gJiYgZnJhbWVbcHJvcF1bMF1bJ0BsaXN0J10pID9cbiAgICAgICAgICAgICAgZnJhbWVbcHJvcF1bMF1bJ0BsaXN0J10gOlxuICAgICAgICAgICAgICBfY3JlYXRlSW1wbGljaXRGcmFtZShmbGFncyk7XG5cbiAgICAgICAgICAvLyBhZGQgZW1wdHkgbGlzdFxuICAgICAgICAgIGNvbnN0IGxpc3QgPSB7J0BsaXN0JzogW119O1xuICAgICAgICAgIF9hZGRGcmFtZU91dHB1dChvdXRwdXQsIHByb3AsIGxpc3QpO1xuXG4gICAgICAgICAgLy8gYWRkIGxpc3Qgb2JqZWN0c1xuICAgICAgICAgIGNvbnN0IHNyYyA9IG9bJ0BsaXN0J107XG4gICAgICAgICAgZm9yKGNvbnN0IG9vIG9mIHNyYykge1xuICAgICAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2Uob28pKSB7XG4gICAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBzdWJqZWN0IHJlZmVyZW5jZVxuICAgICAgICAgICAgICBhcGkuZnJhbWUoXG4gICAgICAgICAgICAgICAgey4uLnN0YXRlLCBlbWJlZGRlZDogdHJ1ZX0sXG4gICAgICAgICAgICAgICAgW29vWydAaWQnXV0sIHN1YmZyYW1lLCBsaXN0LCAnQGxpc3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGluY2x1ZGUgb3RoZXIgdmFsdWVzIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgX2FkZEZyYW1lT3V0cHV0KGxpc3QsICdAbGlzdCcsIHV0aWwuY2xvbmUob28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihncmFwaFR5cGVzLmlzU3ViamVjdFJlZmVyZW5jZShvKSkge1xuICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBzdWJqZWN0IHJlZmVyZW5jZVxuICAgICAgICAgIGFwaS5mcmFtZShcbiAgICAgICAgICAgIHsuLi5zdGF0ZSwgZW1iZWRkZWQ6IHRydWV9LFxuICAgICAgICAgICAgW29bJ0BpZCddXSwgc3ViZnJhbWUsIG91dHB1dCwgcHJvcCk7XG4gICAgICAgIH0gZWxzZSBpZihfdmFsdWVNYXRjaChzdWJmcmFtZVswXSwgbykpIHtcbiAgICAgICAgICAvLyBpbmNsdWRlIG90aGVyIHZhbHVlcywgaWYgdGhleSBtYXRjaFxuICAgICAgICAgIF9hZGRGcmFtZU91dHB1dChvdXRwdXQsIHByb3AsIHV0aWwuY2xvbmUobykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGRlZmF1bHRzXG4gICAgZm9yKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMoZnJhbWUpLnNvcnQoKSkge1xuICAgICAgLy8gc2tpcCBrZXl3b3Jkc1xuICAgICAgaWYocHJvcCA9PT0gJ0B0eXBlJykge1xuICAgICAgICBpZighdHlwZXMuaXNPYmplY3QoZnJhbWVbcHJvcF1bMF0pIHx8XG4gICAgICAgICAgICEoJ0BkZWZhdWx0JyBpbiBmcmFtZVtwcm9wXVswXSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyB0aHJvdWdoIGRlZmF1bHQgdHlwZXNcbiAgICAgIH0gZWxzZSBpZihpc0tleXdvcmQocHJvcCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIG9taXQgZGVmYXVsdCBpcyBvZmYsIHRoZW4gaW5jbHVkZSBkZWZhdWx0IHZhbHVlcyBmb3IgcHJvcGVydGllc1xuICAgICAgLy8gdGhhdCBhcHBlYXIgaW4gdGhlIG5leHQgZnJhbWUgYnV0IGFyZSBub3QgaW4gdGhlIG1hdGNoaW5nIHN1YmplY3RcbiAgICAgIGNvbnN0IG5leHQgPSBmcmFtZVtwcm9wXVswXSB8fCB7fTtcbiAgICAgIGNvbnN0IG9taXREZWZhdWx0T24gPSBfZ2V0RnJhbWVGbGFnKG5leHQsIG9wdGlvbnMsICdvbWl0RGVmYXVsdCcpO1xuICAgICAgaWYoIW9taXREZWZhdWx0T24gJiYgIShwcm9wIGluIG91dHB1dCkpIHtcbiAgICAgICAgbGV0IHByZXNlcnZlID0gJ0BudWxsJztcbiAgICAgICAgaWYoJ0BkZWZhdWx0JyBpbiBuZXh0KSB7XG4gICAgICAgICAgcHJlc2VydmUgPSB1dGlsLmNsb25lKG5leHRbJ0BkZWZhdWx0J10pO1xuICAgICAgICB9XG4gICAgICAgIGlmKCF0eXBlcy5pc0FycmF5KHByZXNlcnZlKSkge1xuICAgICAgICAgIHByZXNlcnZlID0gW3ByZXNlcnZlXTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRbcHJvcF0gPSBbeydAcHJlc2VydmUnOiBwcmVzZXJ2ZX1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGVtYmVkIHJldmVyc2UgdmFsdWVzIGJ5IGZpbmRpbmcgbm9kZXMgaGF2aW5nIHRoaXMgc3ViamVjdCBhcyBhIHZhbHVlXG4gICAgLy8gb2YgdGhlIGFzc29jaWF0ZWQgcHJvcGVydHlcbiAgICBmb3IoY29uc3QgcmV2ZXJzZVByb3Agb2YgT2JqZWN0LmtleXMoZnJhbWVbJ0ByZXZlcnNlJ10gfHwge30pLnNvcnQoKSkge1xuICAgICAgY29uc3Qgc3ViZnJhbWUgPSBmcmFtZVsnQHJldmVyc2UnXVtyZXZlcnNlUHJvcF07XG4gICAgICBmb3IoY29uc3Qgc3ViamVjdCBvZiBPYmplY3Qua2V5cyhzdGF0ZS5zdWJqZWN0cykpIHtcbiAgICAgICAgY29uc3Qgbm9kZVZhbHVlcyA9XG4gICAgICAgICAgdXRpbC5nZXRWYWx1ZXMoc3RhdGUuc3ViamVjdHNbc3ViamVjdF0sIHJldmVyc2VQcm9wKTtcbiAgICAgICAgaWYobm9kZVZhbHVlcy5zb21lKHYgPT4gdlsnQGlkJ10gPT09IGlkKSkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIHByb3BlcnR5IHJlZmVyZW5jaW5nIHRoaXMgc3ViamVjdCwgcmVjdXJzZVxuICAgICAgICAgIG91dHB1dFsnQHJldmVyc2UnXSA9IG91dHB1dFsnQHJldmVyc2UnXSB8fCB7fTtcbiAgICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgICAgb3V0cHV0WydAcmV2ZXJzZSddLCByZXZlcnNlUHJvcCwgW10sIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgICAgICAgICBhcGkuZnJhbWUoXG4gICAgICAgICAgICB7Li4uc3RhdGUsIGVtYmVkZGVkOiB0cnVlfSxcbiAgICAgICAgICAgIFtzdWJqZWN0XSwgc3ViZnJhbWUsIG91dHB1dFsnQHJldmVyc2UnXVtyZXZlcnNlUHJvcF0sXG4gICAgICAgICAgICBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgb3V0cHV0IHRvIHBhcmVudFxuICAgIF9hZGRGcmFtZU91dHB1dChwYXJlbnQsIHByb3BlcnR5LCBvdXRwdXQpO1xuXG4gICAgLy8gcG9wIG1hdGNoaW5nIHN1YmplY3QgZnJvbSBjaXJjdWxhciByZWYtY2hlY2tpbmcgc3RhY2tcbiAgICBzdGF0ZS5zdWJqZWN0U3RhY2sucG9wKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSBgQG51bGxgIHdpdGggYG51bGxgLCByZW1vdmluZyBpdCBmcm9tIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGZyYW1lZCwgY29tcGFjdGVkIG91dHB1dC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBmcmFtaW5nIG9wdGlvbnMgdXNlZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgb3V0cHV0LlxuICovXG5hcGkuY2xlYW51cE51bGwgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgLy8gcmVjdXJzZSB0aHJvdWdoIGFycmF5c1xuICBpZih0eXBlcy5pc0FycmF5KGlucHV0KSkge1xuICAgIGNvbnN0IG5vTnVsbHMgPSBpbnB1dC5tYXAodiA9PiBhcGkuY2xlYW51cE51bGwodiwgb3B0aW9ucykpO1xuICAgIHJldHVybiBub051bGxzLmZpbHRlcih2ID0+IHYpOyAvLyByZW1vdmVzIG51bGxzIGZyb20gYXJyYXlcbiAgfVxuXG4gIGlmKGlucHV0ID09PSAnQG51bGwnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZih0eXBlcy5pc09iamVjdChpbnB1dCkpIHtcbiAgICAvLyBoYW5kbGUgaW4tbWVtb3J5IGxpbmtlZCBub2Rlc1xuICAgIGlmKCdAaWQnIGluIGlucHV0KSB7XG4gICAgICBjb25zdCBpZCA9IGlucHV0WydAaWQnXTtcbiAgICAgIGlmKG9wdGlvbnMubGluay5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gb3B0aW9ucy5saW5rW2lkXS5pbmRleE9mKGlucHV0KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIGFscmVhZHkgdmlzaXRlZFxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmxpbmtbaWRdW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBjaXJjdWxhciB2aXNpdGF0aW9uXG4gICAgICAgIG9wdGlvbnMubGlua1tpZF0ucHVzaChpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwcmV2ZW50IGNpcmN1bGFyIHZpc2l0YXRpb25cbiAgICAgICAgb3B0aW9ucy5saW5rW2lkXSA9IFtpbnB1dF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgaW5wdXRba2V5XSA9IGFwaS5jbGVhbnVwTnVsbChpbnB1dFtrZXldLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGltcGxpY2l0IGZyYW1lIHdoZW4gcmVjdXJzaW5nIHRocm91Z2ggc3ViamVjdCBtYXRjaGVzLiBJZlxuICogYSBmcmFtZSBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQgZnJhbWUgZm9yIGEgcGFydGljdWxhciBwcm9wZXJ0eSwgdGhlblxuICogYSB3aWxkY2FyZCBjaGlsZCBmcmFtZSB3aWxsIGJlIGNyZWF0ZWQgdGhhdCB1c2VzIHRoZSBzYW1lIGZsYWdzIHRoYXQgdGhlXG4gKiBwYXJlbnQgZnJhbWUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gZmxhZ3MgdGhlIGN1cnJlbnQgZnJhbWluZyBmbGFncy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBpbXBsaWNpdCBmcmFtZS5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUltcGxpY2l0RnJhbWUoZmxhZ3MpIHtcbiAgY29uc3QgZnJhbWUgPSB7fTtcbiAgZm9yKGNvbnN0IGtleSBpbiBmbGFncykge1xuICAgIGlmKGZsYWdzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJhbWVbJ0AnICsga2V5XSA9IFtmbGFnc1trZXldXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtmcmFtZV07XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBjdXJyZW50IHN1YmplY3Qgc3RhY2sgdG8gc2VlIGlmIGVtYmVkZGluZyB0aGUgZ2l2ZW4gc3ViamVjdFxuICogd291bGQgY2F1c2UgYSBjaXJjdWxhciByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIHN1YmplY3RUb0VtYmVkIHRoZSBzdWJqZWN0IHRvIGVtYmVkLlxuICogQHBhcmFtIGdyYXBoIHRoZSBncmFwaCB0aGUgc3ViamVjdCB0byBlbWJlZCBpcyBpbi5cbiAqIEBwYXJhbSBzdWJqZWN0U3RhY2sgdGhlIGN1cnJlbnQgc3RhY2sgb2Ygc3ViamVjdHMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGEgY2lyY3VsYXIgcmVmZXJlbmNlIHdvdWxkIGJlIGNyZWF0ZWQsIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZXNDaXJjdWxhclJlZmVyZW5jZShzdWJqZWN0VG9FbWJlZCwgZ3JhcGgsIHN1YmplY3RTdGFjaykge1xuICBmb3IobGV0IGkgPSBzdWJqZWN0U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gc3ViamVjdFN0YWNrW2ldO1xuICAgIGlmKHN1YmplY3QuZ3JhcGggPT09IGdyYXBoICYmXG4gICAgICBzdWJqZWN0LnN1YmplY3RbJ0BpZCddID09PSBzdWJqZWN0VG9FbWJlZFsnQGlkJ10pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZnJhbWUgZmxhZyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGZsYWcgbmFtZS5cbiAqXG4gKiBAcGFyYW0gZnJhbWUgdGhlIGZyYW1lLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIGZyYW1pbmcgb3B0aW9ucy5cbiAqIEBwYXJhbSBuYW1lIHRoZSBmbGFnIG5hbWUuXG4gKlxuICogQHJldHVybiB0aGUgZmxhZyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gX2dldEZyYW1lRmxhZyhmcmFtZSwgb3B0aW9ucywgbmFtZSkge1xuICBjb25zdCBmbGFnID0gJ0AnICsgbmFtZTtcbiAgbGV0IHJ2YWwgPSAoZmxhZyBpbiBmcmFtZSA/IGZyYW1lW2ZsYWddWzBdIDogb3B0aW9uc1tuYW1lXSk7XG4gIGlmKG5hbWUgPT09ICdlbWJlZCcpIHtcbiAgICAvLyBkZWZhdWx0IGlzIFwiQGxhc3RcIlxuICAgIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHN1cHBvcnQgZm9yIFwiZW1iZWRcIiBtYXBzOlxuICAgIC8vIHRydWUgPT4gXCJAbGFzdFwiXG4gICAgLy8gZmFsc2UgPT4gXCJAbmV2ZXJcIlxuICAgIGlmKHJ2YWwgPT09IHRydWUpIHtcbiAgICAgIHJ2YWwgPSAnQG9uY2UnO1xuICAgIH0gZWxzZSBpZihydmFsID09PSBmYWxzZSkge1xuICAgICAgcnZhbCA9ICdAbmV2ZXInO1xuICAgIH0gZWxzZSBpZihydmFsICE9PSAnQGFsd2F5cycgJiYgcnZhbCAhPT0gJ0BuZXZlcicgJiYgcnZhbCAhPT0gJ0BsaW5rJyAmJlxuICAgICAgcnZhbCAhPT0gJ0BmaXJzdCcgJiYgcnZhbCAhPT0gJ0BsYXN0JyAmJiBydmFsICE9PSAnQG9uY2UnKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpbnZhbGlkIHZhbHVlIG9mIEBlbWJlZC4nLFxuICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIEBlbWJlZCB2YWx1ZScsIGZyYW1lfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhIEpTT04tTEQgZnJhbWUsIHRocm93aW5nIGFuIGV4Y2VwdGlvbiBpZiB0aGUgZnJhbWUgaXMgaW52YWxpZC5cbiAqXG4gKiBAcGFyYW0gZnJhbWUgdGhlIGZyYW1lIHRvIHZhbGlkYXRlLlxuICovXG5mdW5jdGlvbiBfdmFsaWRhdGVGcmFtZShmcmFtZSkge1xuICBpZighdHlwZXMuaXNBcnJheShmcmFtZSkgfHwgZnJhbWUubGVuZ3RoICE9PSAxIHx8ICF0eXBlcy5pc09iamVjdChmcmFtZVswXSkpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnSW52YWxpZCBKU09OLUxEIHN5bnRheDsgYSBKU09OLUxEIGZyYW1lIG11c3QgYmUgYSBzaW5nbGUgb2JqZWN0LicsXG4gICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2ZyYW1lfSk7XG4gIH1cblxuICBpZignQGlkJyBpbiBmcmFtZVswXSkge1xuICAgIGZvcihjb25zdCBpZCBvZiB1dGlsLmFzQXJyYXkoZnJhbWVbMF1bJ0BpZCddKSkge1xuICAgICAgLy8gQGlkIG11c3QgYmUgd2lsZGNhcmQgb3IgYW4gSVJJXG4gICAgICBpZighKHR5cGVzLmlzT2JqZWN0KGlkKSB8fCB1cmwuaXNBYnNvbHV0ZShpZCkpIHx8XG4gICAgICAgICh0eXBlcy5pc1N0cmluZyhpZCkgJiYgaWQuaW5kZXhPZignXzonKSA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBpbnZhbGlkIEBpZCBpbiBmcmFtZS4nLFxuICAgICAgICAgICdqc29ubGQuU3ludGF4RXJyb3InLCB7Y29kZTogJ2ludmFsaWQgZnJhbWUnLCBmcmFtZX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmKCdAdHlwZScgaW4gZnJhbWVbMF0pIHtcbiAgICBmb3IoY29uc3QgdHlwZSBvZiB1dGlsLmFzQXJyYXkoZnJhbWVbMF1bJ0B0eXBlJ10pKSB7XG4gICAgICAvLyBAdHlwZSBtdXN0IGJlIHdpbGRjYXJkLCBJUkksIG9yIEBqc29uXG4gICAgICBpZighKHR5cGVzLmlzT2JqZWN0KHR5cGUpIHx8IHVybC5pc0Fic29sdXRlKHR5cGUpIHx8XG4gICAgICAgICAgKHR5cGUgPT09ICdAanNvbicpKSB8fFxuICAgICAgICAodHlwZXMuaXNTdHJpbmcodHlwZSkgJiYgdHlwZS5pbmRleE9mKCdfOicpID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgSlNPTi1MRCBzeW50YXg7IGludmFsaWQgQHR5cGUgaW4gZnJhbWUuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJywge2NvZGU6ICdpbnZhbGlkIGZyYW1lJywgZnJhbWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbWFwIG9mIGFsbCBvZiB0aGUgc3ViamVjdHMgdGhhdCBtYXRjaCBhIHBhcnNlZCBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBzdWJqZWN0cyB0aGUgc2V0IG9mIHN1YmplY3RzIHRvIGZpbHRlci5cbiAqIEBwYXJhbSBmcmFtZSB0aGUgcGFyc2VkIGZyYW1lLlxuICogQHBhcmFtIGZsYWdzIHRoZSBmcmFtZSBmbGFncy5cbiAqXG4gKiBAcmV0dXJuIGFsbCBvZiB0aGUgbWF0Y2hlZCBzdWJqZWN0cy5cbiAqL1xuZnVuY3Rpb24gX2ZpbHRlclN1YmplY3RzKHN0YXRlLCBzdWJqZWN0cywgZnJhbWUsIGZsYWdzKSB7XG4gIC8vIGZpbHRlciBzdWJqZWN0cyBpbiBAaWQgb3JkZXJcbiAgY29uc3QgcnZhbCA9IHt9O1xuICBmb3IoY29uc3QgaWQgb2Ygc3ViamVjdHMpIHtcbiAgICBjb25zdCBzdWJqZWN0ID0gc3RhdGUuZ3JhcGhNYXBbc3RhdGUuZ3JhcGhdW2lkXTtcbiAgICBpZihfZmlsdGVyU3ViamVjdChzdGF0ZSwgc3ViamVjdCwgZnJhbWUsIGZsYWdzKSkge1xuICAgICAgcnZhbFtpZF0gPSBzdWJqZWN0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN1YmplY3QgbWF0Y2hlcyB0aGUgZ2l2ZW4gZnJhbWUuXG4gKlxuICogTWF0Y2hlcyBlaXRoZXIgYmFzZWQgb24gZXhwbGljaXQgdHlwZSBpbmNsdXNpb24gd2hlcmUgdGhlIG5vZGUgaGFzIGFueVxuICogdHlwZSBsaXN0ZWQgaW4gdGhlIGZyYW1lLiBJZiB0aGUgZnJhbWUgaGFzIGVtcHR5IHR5cGVzIGRlZmluZWQgbWF0Y2hlc1xuICogbm9kZXMgbm90IGhhdmluZyBhIEB0eXBlLiBJZiB0aGUgZnJhbWUgaGFzIGEgdHlwZSBvZiB7fSBkZWZpbmVkIG1hdGNoZXNcbiAqIG5vZGVzIGhhdmluZyBhbnkgdHlwZSBkZWZpbmVkLlxuICpcbiAqIE90aGVyd2lzZSwgZG9lcyBkdWNrIHR5cGluZywgd2hlcmUgdGhlIG5vZGUgbXVzdCBoYXZlIGFsbCBvZiB0aGVcbiAqIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgZnJhbWUuXG4gKlxuICogQHBhcmFtIHN0YXRlIHRoZSBjdXJyZW50IGZyYW1pbmcgc3RhdGUuXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBmcmFtZSB0aGUgZnJhbWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gZmxhZ3MgdGhlIGZyYW1lIGZsYWdzLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgc3ViamVjdCBtYXRjaGVzLCBmYWxzZSBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIF9maWx0ZXJTdWJqZWN0KHN0YXRlLCBzdWJqZWN0LCBmcmFtZSwgZmxhZ3MpIHtcbiAgLy8gY2hlY2sgZHVja3R5cGVcbiAgbGV0IHdpbGRjYXJkID0gdHJ1ZTtcbiAgbGV0IG1hdGNoZXNTb21lID0gZmFsc2U7XG5cbiAgZm9yKGNvbnN0IGtleSBpbiBmcmFtZSkge1xuICAgIGxldCBtYXRjaFRoaXMgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlVmFsdWVzID0gdXRpbC5nZXRWYWx1ZXMoc3ViamVjdCwga2V5KTtcbiAgICBjb25zdCBpc0VtcHR5ID0gdXRpbC5nZXRWYWx1ZXMoZnJhbWUsIGtleSkubGVuZ3RoID09PSAwO1xuXG4gICAgaWYoa2V5ID09PSAnQGlkJykge1xuICAgICAgLy8gbWF0Y2ggb24gbm8gQGlkIG9yIGFueSBtYXRjaGluZyBAaWQsIGluY2x1ZGluZyB3aWxkY2FyZFxuICAgICAgaWYodHlwZXMuaXNFbXB0eU9iamVjdChmcmFtZVsnQGlkJ11bMF0gfHwge30pKSB7XG4gICAgICAgIG1hdGNoVGhpcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYoZnJhbWVbJ0BpZCddLmxlbmd0aCA+PSAwKSB7XG4gICAgICAgIG1hdGNoVGhpcyA9IGZyYW1lWydAaWQnXS5pbmNsdWRlcyhub2RlVmFsdWVzWzBdKTtcbiAgICAgIH1cbiAgICAgIGlmKCFmbGFncy5yZXF1aXJlQWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFRoaXM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGtleSA9PT0gJ0B0eXBlJykge1xuICAgICAgLy8gY2hlY2sgQHR5cGUgKG9iamVjdCB2YWx1ZSBtZWFucyAnYW55JyB0eXBlLFxuICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIGR1Y2t0eXBpbmcpXG4gICAgICB3aWxkY2FyZCA9IGZhbHNlO1xuICAgICAgaWYoaXNFbXB0eSkge1xuICAgICAgICBpZihub2RlVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBkb24ndCBtYXRjaCBvbiBubyBAdHlwZVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaFRoaXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmKGZyYW1lWydAdHlwZSddLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0eXBlcy5pc0VtcHR5T2JqZWN0KGZyYW1lWydAdHlwZSddWzBdKSkge1xuICAgICAgICAvLyBtYXRjaCBvbiB3aWxkY2FyZCBAdHlwZSBpZiB0aGVyZSBpcyBhIHR5cGVcbiAgICAgICAgbWF0Y2hUaGlzID0gbm9kZVZhbHVlcy5sZW5ndGggPiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWF0Y2ggb24gYSBzcGVjaWZpYyBAdHlwZVxuICAgICAgICBmb3IoY29uc3QgdHlwZSBvZiBmcmFtZVsnQHR5cGUnXSkge1xuICAgICAgICAgIGlmKHR5cGVzLmlzT2JqZWN0KHR5cGUpICYmICdAZGVmYXVsdCcgaW4gdHlwZSkge1xuICAgICAgICAgICAgLy8gbWF0Y2ggb24gZGVmYXVsdCBvYmplY3RcbiAgICAgICAgICAgIG1hdGNoVGhpcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoVGhpcyA9IG1hdGNoVGhpcyB8fCBub2RlVmFsdWVzLnNvbWUodHQgPT4gdHQgPT09IHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoIWZsYWdzLnJlcXVpcmVBbGwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoVGhpcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoaXNLZXl3b3JkKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JjZSBhIGNvcHkgb2YgdGhpcyBmcmFtZSBlbnRyeSBzbyBpdCBjYW4gYmUgbWFuaXB1bGF0ZWRcbiAgICAgIGNvbnN0IHRoaXNGcmFtZSA9IHV0aWwuZ2V0VmFsdWVzKGZyYW1lLCBrZXkpWzBdO1xuICAgICAgbGV0IGhhc0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgIGlmKHRoaXNGcmFtZSkge1xuICAgICAgICBfdmFsaWRhdGVGcmFtZShbdGhpc0ZyYW1lXSk7XG4gICAgICAgIGhhc0RlZmF1bHQgPSAnQGRlZmF1bHQnIGluIHRoaXNGcmFtZTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbG9uZ2VyIGEgd2lsZGNhcmQgcGF0dGVybiBpZiBmcmFtZSBoYXMgYW55IG5vbi1rZXl3b3JkIHByb3BlcnRpZXNcbiAgICAgIHdpbGRjYXJkID0gZmFsc2U7XG5cbiAgICAgIC8vIHNraXAsIGJ1dCBhbGxvdyBtYXRjaCBpZiBub2RlIGhhcyBubyB2YWx1ZSBmb3IgcHJvcGVydHksIGFuZCBmcmFtZSBoYXNcbiAgICAgIC8vIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAgaWYobm9kZVZhbHVlcy5sZW5ndGggPT09IDAgJiYgaGFzRGVmYXVsdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgZnJhbWUgdmFsdWUgaXMgZW1wdHksIGRvbid0IG1hdGNoIGlmIHN1YmplY3QgaGFzIGFueSB2YWx1ZVxuICAgICAgaWYobm9kZVZhbHVlcy5sZW5ndGggPiAwICYmIGlzRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZih0aGlzRnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBub2RlIGRvZXMgbm90IG1hdGNoIGlmIHZhbHVlcyBpcyBub3QgZW1wdHkgYW5kIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eVxuICAgICAgICAvLyBpbiBmcmFtZSBpcyBtYXRjaCBub25lLlxuICAgICAgICBpZihub2RlVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hUaGlzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKGdyYXBoVHlwZXMuaXNMaXN0KHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBsaXN0VmFsdWUgPSB0aGlzRnJhbWVbJ0BsaXN0J11bMF07XG4gICAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc0xpc3Qobm9kZVZhbHVlc1swXSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVMaXN0VmFsdWVzID0gbm9kZVZhbHVlc1swXVsnQGxpc3QnXTtcblxuICAgICAgICAgICAgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKGxpc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgLy8gbWF0Y2ggb24gYW55IG1hdGNoaW5nIHZhbHVlXG4gICAgICAgICAgICAgIG1hdGNoVGhpcyA9IG5vZGVMaXN0VmFsdWVzLnNvbWUobHYgPT4gX3ZhbHVlTWF0Y2gobGlzdFZhbHVlLCBsdikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0KGxpc3RWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2UobGlzdFZhbHVlKSkge1xuICAgICAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlTGlzdFZhbHVlcy5zb21lKGx2ID0+IF9ub2RlTWF0Y2goXG4gICAgICAgICAgICAgICAgc3RhdGUsIGxpc3RWYWx1ZSwgbHYsIGZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlVmFsdWVzLnNvbWUobnYgPT4gX3ZhbHVlTWF0Y2godGhpc0ZyYW1lLCBudikpO1xuICAgICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2UodGhpc0ZyYW1lKSkge1xuICAgICAgICAgIG1hdGNoVGhpcyA9XG4gICAgICAgICAgICBub2RlVmFsdWVzLnNvbWUobnYgPT4gX25vZGVNYXRjaChzdGF0ZSwgdGhpc0ZyYW1lLCBudiwgZmxhZ3MpKTtcbiAgICAgICAgfSBlbHNlIGlmKHR5cGVzLmlzT2JqZWN0KHRoaXNGcmFtZSkpIHtcbiAgICAgICAgICBtYXRjaFRoaXMgPSBub2RlVmFsdWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hUaGlzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbm9uLWRlZmF1bHRlZCB2YWx1ZXMgbXVzdCBtYXRjaCBpZiByZXF1aXJlQWxsIGlzIHNldFxuICAgIGlmKCFtYXRjaFRoaXMgJiYgZmxhZ3MucmVxdWlyZUFsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1hdGNoZXNTb21lID0gbWF0Y2hlc1NvbWUgfHwgbWF0Y2hUaGlzO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRydWUgaWYgd2lsZGNhcmQgb3Igc3ViamVjdCBtYXRjaGVzIHNvbWUgcHJvcGVydGllc1xuICByZXR1cm4gd2lsZGNhcmQgfHwgbWF0Y2hlc1NvbWU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBleGlzdGluZyBlbWJlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBpZCB0aGUgQGlkIG9mIHRoZSBlbWJlZCB0byByZW1vdmUuXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVFbWJlZChzdGF0ZSwgaWQpIHtcbiAgLy8gZ2V0IGV4aXN0aW5nIGVtYmVkXG4gIGNvbnN0IGVtYmVkcyA9IHN0YXRlLnVuaXF1ZUVtYmVkc1tzdGF0ZS5ncmFwaF07XG4gIGNvbnN0IGVtYmVkID0gZW1iZWRzW2lkXTtcbiAgY29uc3QgcGFyZW50ID0gZW1iZWQucGFyZW50O1xuICBjb25zdCBwcm9wZXJ0eSA9IGVtYmVkLnByb3BlcnR5O1xuXG4gIC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gcmVwbGFjZSBlbWJlZFxuICBjb25zdCBzdWJqZWN0ID0geydAaWQnOiBpZH07XG5cbiAgLy8gcmVtb3ZlIGV4aXN0aW5nIGVtYmVkXG4gIGlmKHR5cGVzLmlzQXJyYXkocGFyZW50KSkge1xuICAgIC8vIHJlcGxhY2Ugc3ViamVjdCB3aXRoIHJlZmVyZW5jZVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmKHV0aWwuY29tcGFyZVZhbHVlcyhwYXJlbnRbaV0sIHN1YmplY3QpKSB7XG4gICAgICAgIHBhcmVudFtpXSA9IHN1YmplY3Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyByZXBsYWNlIHN1YmplY3Qgd2l0aCByZWZlcmVuY2VcbiAgICBjb25zdCB1c2VBcnJheSA9IHR5cGVzLmlzQXJyYXkocGFyZW50W3Byb3BlcnR5XSk7XG4gICAgdXRpbC5yZW1vdmVWYWx1ZShwYXJlbnQsIHByb3BlcnR5LCBzdWJqZWN0LCB7cHJvcGVydHlJc0FycmF5OiB1c2VBcnJheX0pO1xuICAgIHV0aWwuYWRkVmFsdWUocGFyZW50LCBwcm9wZXJ0eSwgc3ViamVjdCwge3Byb3BlcnR5SXNBcnJheTogdXNlQXJyYXl9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IHJlbW92ZSBkZXBlbmRlbnQgZGFuZ2xpbmcgZW1iZWRzXG4gIGNvbnN0IHJlbW92ZURlcGVuZGVudHMgPSBpZCA9PiB7XG4gICAgLy8gZ2V0IGVtYmVkIGtleXMgYXMgYSBzZXBhcmF0ZSBhcnJheSB0byBlbmFibGUgZGVsZXRpbmcga2V5cyBpbiBtYXBcbiAgICBjb25zdCBpZHMgPSBPYmplY3Qua2V5cyhlbWJlZHMpO1xuICAgIGZvcihjb25zdCBuZXh0IG9mIGlkcykge1xuICAgICAgaWYobmV4dCBpbiBlbWJlZHMgJiYgdHlwZXMuaXNPYmplY3QoZW1iZWRzW25leHRdLnBhcmVudCkgJiZcbiAgICAgICAgZW1iZWRzW25leHRdLnBhcmVudFsnQGlkJ10gPT09IGlkKSB7XG4gICAgICAgIGRlbGV0ZSBlbWJlZHNbbmV4dF07XG4gICAgICAgIHJlbW92ZURlcGVuZGVudHMobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZW1vdmVEZXBlbmRlbnRzKGlkKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBAcHJlc2VydmUga2V5d29yZHMgZnJvbSBleHBhbmRlZCByZXN1bHQgb2YgZnJhbWluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGZyYW1lZCwgZnJhbWVkIG91dHB1dC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBmcmFtaW5nIG9wdGlvbnMgdXNlZC5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZXN1bHRpbmcgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBfY2xlYW51cFByZXNlcnZlKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIHJlY3Vyc2UgdGhyb3VnaCBhcnJheXNcbiAgaWYodHlwZXMuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKHZhbHVlID0+IF9jbGVhbnVwUHJlc2VydmUodmFsdWUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGlmKHR5cGVzLmlzT2JqZWN0KGlucHV0KSkge1xuICAgIC8vIHJlbW92ZSBAcHJlc2VydmVcbiAgICBpZignQHByZXNlcnZlJyBpbiBpbnB1dCkge1xuICAgICAgcmV0dXJuIGlucHV0WydAcHJlc2VydmUnXVswXTtcbiAgICB9XG5cbiAgICAvLyBza2lwIEB2YWx1ZXNcbiAgICBpZihncmFwaFR5cGVzLmlzVmFsdWUoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSB0aHJvdWdoIEBsaXN0c1xuICAgIGlmKGdyYXBoVHlwZXMuaXNMaXN0KGlucHV0KSkge1xuICAgICAgaW5wdXRbJ0BsaXN0J10gPSBfY2xlYW51cFByZXNlcnZlKGlucHV0WydAbGlzdCddLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgaW4tbWVtb3J5IGxpbmtlZCBub2Rlc1xuICAgIGlmKCdAaWQnIGluIGlucHV0KSB7XG4gICAgICBjb25zdCBpZCA9IGlucHV0WydAaWQnXTtcbiAgICAgIGlmKG9wdGlvbnMubGluay5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gb3B0aW9ucy5saW5rW2lkXS5pbmRleE9mKGlucHV0KTtcbiAgICAgICAgaWYoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIC8vIGFscmVhZHkgdmlzaXRlZFxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmxpbmtbaWRdW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBjaXJjdWxhciB2aXNpdGF0aW9uXG4gICAgICAgIG9wdGlvbnMubGlua1tpZF0ucHVzaChpbnB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwcmV2ZW50IGNpcmN1bGFyIHZpc2l0YXRpb25cbiAgICAgICAgb3B0aW9ucy5saW5rW2lkXSA9IFtpbnB1dF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSB0aHJvdWdoIHByb3BlcnRpZXNcbiAgICBmb3IoY29uc3QgcHJvcCBpbiBpbnB1dCkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgcmVtb3ZlIHRoZSBpZCwgaWYgaXQgaXMgYW4gdW5yZWZlcmVuY2UgYm5vZGVcbiAgICAgIGlmKHByb3AgPT09ICdAaWQnICYmIG9wdGlvbnMuYm5vZGVzVG9DbGVhci5pbmNsdWRlcyhpbnB1dFtwcm9wXSkpIHtcbiAgICAgICAgZGVsZXRlIGlucHV0WydAaWQnXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlucHV0W3Byb3BdID0gX2NsZWFudXBQcmVzZXJ2ZShpbnB1dFtwcm9wXSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBBZGRzIGZyYW1pbmcgb3V0cHV0IHRvIHRoZSBnaXZlbiBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHBhcmVudCB0aGUgcGFyZW50IHRvIGFkZCB0by5cbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUgcGFyZW50IHByb3BlcnR5LlxuICogQHBhcmFtIG91dHB1dCB0aGUgb3V0cHV0IHRvIGFkZC5cbiAqL1xuZnVuY3Rpb24gX2FkZEZyYW1lT3V0cHV0KHBhcmVudCwgcHJvcGVydHksIG91dHB1dCkge1xuICBpZih0eXBlcy5pc09iamVjdChwYXJlbnQpKSB7XG4gICAgdXRpbC5hZGRWYWx1ZShwYXJlbnQsIHByb3BlcnR5LCBvdXRwdXQsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQucHVzaChvdXRwdXQpO1xuICB9XG59XG5cbi8qKlxuICogTm9kZSBtYXRjaGVzIGlmIGl0IGlzIGEgbm9kZSwgYW5kIG1hdGNoZXMgdGhlIHBhdHRlcm4gYXMgYSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgdGhlIGN1cnJlbnQgZnJhbWluZyBzdGF0ZS5cbiAqIEBwYXJhbSBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2ggdmFsdWVcbiAqIEBwYXJhbSB2YWx1ZSB0byBjaGVja1xuICogQHBhcmFtIGZsYWdzIHRoZSBmcmFtZSBmbGFncy5cbiAqL1xuZnVuY3Rpb24gX25vZGVNYXRjaChzdGF0ZSwgcGF0dGVybiwgdmFsdWUsIGZsYWdzKSB7XG4gIGlmKCEoJ0BpZCcgaW4gdmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5vZGVPYmplY3QgPSBzdGF0ZS5zdWJqZWN0c1t2YWx1ZVsnQGlkJ11dO1xuICByZXR1cm4gbm9kZU9iamVjdCAmJiBfZmlsdGVyU3ViamVjdChzdGF0ZSwgbm9kZU9iamVjdCwgcGF0dGVybiwgZmxhZ3MpO1xufVxuXG4vKipcbiAqIFZhbHVlIG1hdGNoZXMgaWYgaXQgaXMgYSB2YWx1ZSBhbmQgbWF0Y2hlcyB0aGUgdmFsdWUgcGF0dGVyblxuICpcbiAqICogYHBhdHRlcm5gIGlzIGVtcHR5XG4gKiAqIEB2YWx1ZXMgYXJlIHRoZSBzYW1lLCBvciBgcGF0dGVybltAdmFsdWVdYCBpcyBhIHdpbGRjYXJkLCBhbmRcbiAqICogQHR5cGVzIGFyZSB0aGUgc2FtZSBvciBgdmFsdWVbQHR5cGVdYCBpcyBub3QgbnVsbFxuICogICBhbmQgYHBhdHRlcm5bQHR5cGVdYCBpcyBge31gLCBvciBgdmFsdWVbQHR5cGVdYCBpcyBudWxsXG4gKiAgIGFuZCBgcGF0dGVybltAdHlwZV1gIGlzIG51bGwgb3IgYFtdYCwgYW5kXG4gKiAqIEBsYW5ndWFnZXMgYXJlIHRoZSBzYW1lIG9yIGB2YWx1ZVtAbGFuZ3VhZ2VdYCBpcyBub3QgbnVsbFxuICogICBhbmQgYHBhdHRlcm5bQGxhbmd1YWdlXWAgaXMgYHt9YCwgb3IgYHZhbHVlW0BsYW5ndWFnZV1gIGlzIG51bGxcbiAqICAgYW5kIGBwYXR0ZXJuW0BsYW5ndWFnZV1gIGlzIG51bGwgb3IgYFtdYC5cbiAqXG4gKiBAcGFyYW0gcGF0dGVybiB1c2VkIHRvIG1hdGNoIHZhbHVlXG4gKiBAcGFyYW0gdmFsdWUgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gX3ZhbHVlTWF0Y2gocGF0dGVybiwgdmFsdWUpIHtcbiAgY29uc3QgdjEgPSB2YWx1ZVsnQHZhbHVlJ107XG4gIGNvbnN0IHQxID0gdmFsdWVbJ0B0eXBlJ107XG4gIGNvbnN0IGwxID0gdmFsdWVbJ0BsYW5ndWFnZSddO1xuICBjb25zdCB2MiA9IHBhdHRlcm5bJ0B2YWx1ZSddID9cbiAgICAodHlwZXMuaXNBcnJheShwYXR0ZXJuWydAdmFsdWUnXSkgP1xuICAgICAgcGF0dGVyblsnQHZhbHVlJ10gOiBbcGF0dGVyblsnQHZhbHVlJ11dKSA6XG4gICAgW107XG4gIGNvbnN0IHQyID0gcGF0dGVyblsnQHR5cGUnXSA/XG4gICAgKHR5cGVzLmlzQXJyYXkocGF0dGVyblsnQHR5cGUnXSkgP1xuICAgICAgcGF0dGVyblsnQHR5cGUnXSA6IFtwYXR0ZXJuWydAdHlwZSddXSkgOlxuICAgIFtdO1xuICBjb25zdCBsMiA9IHBhdHRlcm5bJ0BsYW5ndWFnZSddID9cbiAgICAodHlwZXMuaXNBcnJheShwYXR0ZXJuWydAbGFuZ3VhZ2UnXSkgP1xuICAgICAgcGF0dGVyblsnQGxhbmd1YWdlJ10gOiBbcGF0dGVyblsnQGxhbmd1YWdlJ11dKSA6XG4gICAgW107XG5cbiAgaWYodjIubGVuZ3RoID09PSAwICYmIHQyLmxlbmd0aCA9PT0gMCAmJiBsMi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZighKHYyLmluY2x1ZGVzKHYxKSB8fCB0eXBlcy5pc0VtcHR5T2JqZWN0KHYyWzBdKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYoISghdDEgJiYgdDIubGVuZ3RoID09PSAwIHx8IHQyLmluY2x1ZGVzKHQxKSB8fCB0MSAmJlxuICAgIHR5cGVzLmlzRW1wdHlPYmplY3QodDJbMF0pKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZighKCFsMSAmJiBsMi5sZW5ndGggPT09IDAgfHwgbDIuaW5jbHVkZXMobDEpIHx8IGwxICYmXG4gICAgdHlwZXMuaXNFbXB0eU9iamVjdChsMlswXSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/frame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/fromRdf.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/fromRdf.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst {\n  REGEX_BCP47,\n  addValue: _addValue\n} = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/jsonld/lib/events.js\");\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/jsonld/lib/constants.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset,\n  options\n) => {\n  const {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  } = options;\n  // FIXME: use Maps?\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n  if(rdfDirection) {\n    if(rdfDirection === 'compound-literal') {\n      throw new JsonLdError(\n        'Unsupported rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    } else if(rdfDirection !== 'i18n-datatype') {\n      throw new JsonLdError(\n        'Unknown rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    }\n  }\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      _addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection, options);\n    _addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        _addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      _addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n * @param rdfDirection text direction mode [null, i18n-datatype]\n * @param options top level API options\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection, options) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    if(!o.language.match(REGEX_BCP47)) {\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'invalid @language value',\n            level: 'warning',\n            message: '@language value must be valid BCP47.',\n            details: {\n              language: o.language\n            }\n          },\n          options\n        });\n      }\n    }\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(rdfDirection === 'i18n-datatype' &&\n      type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if(language.length > 0) {\n        rval['@language'] = language;\n        if(!language.match(REGEX_BCP47)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'invalid @language value',\n                level: 'warning',\n                message: '@language value must be valid BCP47.',\n                details: {\n                  language\n                }\n              },\n              options\n            });\n          }\n        }\n      }\n      rval['@direction'] = direction;\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mcm9tUmRmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHFFQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLG1FQUFjO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyx5REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdURBQVE7O0FBRXBCO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyREFBVTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFhOztBQUV6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQkFBb0I7QUFDN0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLHNCQUFzQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQThEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9mcm9tUmRmLmpzPzRkMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDIzIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5jb25zdCBncmFwaFR5cGVzID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3Qge1xuICBSRUdFWF9CQ1A0NyxcbiAgYWRkVmFsdWU6IF9hZGRWYWx1ZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCB7XG4gIGhhbmRsZUV2ZW50OiBfaGFuZGxlRXZlbnRcbn0gPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuXG4vLyBjb25zdGFudHNcbmNvbnN0IHtcbiAgLy8gUkRGLFxuICBSREZfTElTVCxcbiAgUkRGX0ZJUlNULFxuICBSREZfUkVTVCxcbiAgUkRGX05JTCxcbiAgUkRGX1RZUEUsXG4gIC8vIFJERl9QTEFJTl9MSVRFUkFMLFxuICAvLyBSREZfWE1MX0xJVEVSQUwsXG4gIFJERl9KU09OX0xJVEVSQUwsXG4gIC8vIFJERl9PQkpFQ1QsXG4gIC8vIFJERl9MQU5HU1RSSU5HLFxuXG4gIC8vIFhTRCxcbiAgWFNEX0JPT0xFQU4sXG4gIFhTRF9ET1VCTEUsXG4gIFhTRF9JTlRFR0VSLFxuICBYU0RfU1RSSU5HLFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8qKlxuICogQ29udmVydHMgYW4gUkRGIGRhdGFzZXQgdG8gSlNPTi1MRC5cbiAqXG4gKiBAcGFyYW0gZGF0YXNldCB0aGUgUkRGIGRhdGFzZXQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgUkRGIHNlcmlhbGl6YXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBKU09OLUxEIG91dHB1dC5cbiAqL1xuYXBpLmZyb21SREYgPSBhc3luYyAoXG4gIGRhdGFzZXQsXG4gIG9wdGlvbnNcbikgPT4ge1xuICBjb25zdCB7XG4gICAgdXNlUmRmVHlwZSA9IGZhbHNlLFxuICAgIHVzZU5hdGl2ZVR5cGVzID0gZmFsc2UsXG4gICAgcmRmRGlyZWN0aW9uID0gbnVsbFxuICB9ID0gb3B0aW9ucztcbiAgLy8gRklYTUU6IHVzZSBNYXBzP1xuICBjb25zdCBkZWZhdWx0R3JhcGggPSB7fTtcbiAgY29uc3QgZ3JhcGhNYXAgPSB7J0BkZWZhdWx0JzogZGVmYXVsdEdyYXBofTtcbiAgY29uc3QgcmVmZXJlbmNlZE9uY2UgPSB7fTtcbiAgaWYocmRmRGlyZWN0aW9uKSB7XG4gICAgaWYocmRmRGlyZWN0aW9uID09PSAnY29tcG91bmQtbGl0ZXJhbCcpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIHJkZkRpcmVjdGlvbiB2YWx1ZS4nLFxuICAgICAgICAnanNvbmxkLkludmFsaWRSZGZEaXJlY3Rpb24nLFxuICAgICAgICB7dmFsdWU6IHJkZkRpcmVjdGlvbn0pO1xuICAgIH0gZWxzZSBpZihyZGZEaXJlY3Rpb24gIT09ICdpMThuLWRhdGF0eXBlJykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVW5rbm93biByZGZEaXJlY3Rpb24gdmFsdWUuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkUmRmRGlyZWN0aW9uJyxcbiAgICAgICAge3ZhbHVlOiByZGZEaXJlY3Rpb259KTtcbiAgICB9XG4gIH1cblxuICBmb3IoY29uc3QgcXVhZCBvZiBkYXRhc2V0KSB7XG4gICAgLy8gVE9ETzogY2hhbmdlICduYW1lJyB0byAnZ3JhcGgnXG4gICAgY29uc3QgbmFtZSA9IChxdWFkLmdyYXBoLnRlcm1UeXBlID09PSAnRGVmYXVsdEdyYXBoJykgP1xuICAgICAgJ0BkZWZhdWx0JyA6IHF1YWQuZ3JhcGgudmFsdWU7XG4gICAgaWYoIShuYW1lIGluIGdyYXBoTWFwKSkge1xuICAgICAgZ3JhcGhNYXBbbmFtZV0gPSB7fTtcbiAgICB9XG4gICAgaWYobmFtZSAhPT0gJ0BkZWZhdWx0JyAmJiAhKG5hbWUgaW4gZGVmYXVsdEdyYXBoKSkge1xuICAgICAgZGVmYXVsdEdyYXBoW25hbWVdID0geydAaWQnOiBuYW1lfTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlTWFwID0gZ3JhcGhNYXBbbmFtZV07XG5cbiAgICAvLyBnZXQgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3RcbiAgICBjb25zdCBzID0gcXVhZC5zdWJqZWN0LnZhbHVlO1xuICAgIGNvbnN0IHAgPSBxdWFkLnByZWRpY2F0ZS52YWx1ZTtcbiAgICBjb25zdCBvID0gcXVhZC5vYmplY3Q7XG5cbiAgICBpZighKHMgaW4gbm9kZU1hcCkpIHtcbiAgICAgIG5vZGVNYXBbc10gPSB7J0BpZCc6IHN9O1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gbm9kZU1hcFtzXTtcblxuICAgIGNvbnN0IG9iamVjdElzTm9kZSA9IG8udGVybVR5cGUuZW5kc1dpdGgoJ05vZGUnKTtcbiAgICBpZihvYmplY3RJc05vZGUgJiYgIShvLnZhbHVlIGluIG5vZGVNYXApKSB7XG4gICAgICBub2RlTWFwW28udmFsdWVdID0geydAaWQnOiBvLnZhbHVlfTtcbiAgICB9XG5cbiAgICBpZihwID09PSBSREZfVFlQRSAmJiAhdXNlUmRmVHlwZSAmJiBvYmplY3RJc05vZGUpIHtcbiAgICAgIF9hZGRWYWx1ZShub2RlLCAnQHR5cGUnLCBvLnZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IF9SREZUb09iamVjdChvLCB1c2VOYXRpdmVUeXBlcywgcmRmRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICBfYWRkVmFsdWUobm9kZSwgcCwgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcblxuICAgIC8vIG9iamVjdCBtYXkgYmUgYW4gUkRGIGxpc3QvcGFydGlhbCBsaXN0IG5vZGUgYnV0IHdlIGNhbid0IGtub3cgZWFzaWx5XG4gICAgLy8gdW50aWwgYWxsIHRyaXBsZXMgYXJlIHJlYWRcbiAgICBpZihvYmplY3RJc05vZGUpIHtcbiAgICAgIGlmKG8udmFsdWUgPT09IFJERl9OSUwpIHtcbiAgICAgICAgLy8gdHJhY2sgcmRmOm5pbCB1bmlxdWVseSBwZXIgZ3JhcGhcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gbm9kZU1hcFtvLnZhbHVlXTtcbiAgICAgICAgaWYoISgndXNhZ2VzJyBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgb2JqZWN0LnVzYWdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC51c2FnZXMucHVzaCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZihvLnZhbHVlIGluIHJlZmVyZW5jZWRPbmNlKSB7XG4gICAgICAgIC8vIG9iamVjdCByZWZlcmVuY2VkIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIHJlZmVyZW5jZWRPbmNlW28udmFsdWVdID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIHNpbmdsZSByZWZlcmVuY2VcbiAgICAgICAgcmVmZXJlbmNlZE9uY2Vbby52YWx1ZV0gPSB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwcm9wZXJ0eTogcCxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gIGZvcihsZXQgbmFtZSBpbiBkYXRhc2V0KSB7XG4gICAgY29uc3QgZ3JhcGggPSBkYXRhc2V0W25hbWVdO1xuICAgIGlmKCEobmFtZSBpbiBncmFwaE1hcCkpIHtcbiAgICAgIGdyYXBoTWFwW25hbWVdID0ge307XG4gICAgfVxuICAgIGlmKG5hbWUgIT09ICdAZGVmYXVsdCcgJiYgIShuYW1lIGluIGRlZmF1bHRHcmFwaCkpIHtcbiAgICAgIGRlZmF1bHRHcmFwaFtuYW1lXSA9IHsnQGlkJzogbmFtZX07XG4gICAgfVxuICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaE1hcFtuYW1lXTtcbiAgICBmb3IobGV0IHRpID0gMDsgdGkgPCBncmFwaC5sZW5ndGg7ICsrdGkpIHtcbiAgICAgIGNvbnN0IHRyaXBsZSA9IGdyYXBoW3RpXTtcblxuICAgICAgLy8gZ2V0IHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0XG4gICAgICBjb25zdCBzID0gdHJpcGxlLnN1YmplY3QudmFsdWU7XG4gICAgICBjb25zdCBwID0gdHJpcGxlLnByZWRpY2F0ZS52YWx1ZTtcbiAgICAgIGNvbnN0IG8gPSB0cmlwbGUub2JqZWN0O1xuXG4gICAgICBpZighKHMgaW4gbm9kZU1hcCkpIHtcbiAgICAgICAgbm9kZU1hcFtzXSA9IHsnQGlkJzogc307XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcFtzXTtcblxuICAgICAgY29uc3Qgb2JqZWN0SXNJZCA9IChvLnR5cGUgPT09ICdJUkknIHx8IG8udHlwZSA9PT0gJ2JsYW5rIG5vZGUnKTtcbiAgICAgIGlmKG9iamVjdElzSWQgJiYgIShvLnZhbHVlIGluIG5vZGVNYXApKSB7XG4gICAgICAgIG5vZGVNYXBbby52YWx1ZV0gPSB7J0BpZCc6IG8udmFsdWV9O1xuICAgICAgfVxuXG4gICAgICBpZihwID09PSBSREZfVFlQRSAmJiAhdXNlUmRmVHlwZSAmJiBvYmplY3RJc0lkKSB7XG4gICAgICAgIF9hZGRWYWx1ZShub2RlLCAnQHR5cGUnLCBvLnZhbHVlLCB7cHJvcGVydHlJc0FycmF5OiB0cnVlfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWx1ZSA9IF9SREZUb09iamVjdChvLCB1c2VOYXRpdmVUeXBlcyk7XG4gICAgICBfYWRkVmFsdWUobm9kZSwgcCwgdmFsdWUsIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWV9KTtcblxuICAgICAgLy8gb2JqZWN0IG1heSBiZSBhbiBSREYgbGlzdC9wYXJ0aWFsIGxpc3Qgbm9kZSBidXQgd2UgY2FuJ3Qga25vdyBlYXNpbHlcbiAgICAgIC8vIHVudGlsIGFsbCB0cmlwbGVzIGFyZSByZWFkXG4gICAgICBpZihvYmplY3RJc0lkKSB7XG4gICAgICAgIGlmKG8udmFsdWUgPT09IFJERl9OSUwpIHtcbiAgICAgICAgICAvLyB0cmFjayByZGY6bmlsIHVuaXF1ZWx5IHBlciBncmFwaFxuICAgICAgICAgIGNvbnN0IG9iamVjdCA9IG5vZGVNYXBbby52YWx1ZV07XG4gICAgICAgICAgaWYoISgndXNhZ2VzJyBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICBvYmplY3QudXNhZ2VzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdC51c2FnZXMucHVzaCh7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmKG8udmFsdWUgaW4gcmVmZXJlbmNlZE9uY2UpIHtcbiAgICAgICAgICAvLyBvYmplY3QgcmVmZXJlbmNlZCBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIHJlZmVyZW5jZWRPbmNlW28udmFsdWVdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBzaW5nbGUgcmVmZXJlbmNlXG4gICAgICAgICAgcmVmZXJlbmNlZE9uY2Vbby52YWx1ZV0gPSB7XG4gICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgcHJvcGVydHk6IHAsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9Ki9cblxuICAvLyBjb252ZXJ0IGxpbmtlZCBsaXN0cyB0byBAbGlzdCBhcnJheXNcbiAgZm9yKGNvbnN0IG5hbWUgaW4gZ3JhcGhNYXApIHtcbiAgICBjb25zdCBncmFwaE9iamVjdCA9IGdyYXBoTWFwW25hbWVdO1xuXG4gICAgLy8gbm8gQGxpc3RzIHRvIGJlIGNvbnZlcnRlZCwgY29udGludWVcbiAgICBpZighKFJERl9OSUwgaW4gZ3JhcGhPYmplY3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIGJhY2t3YXJkcyB0aHJvdWdoIGVhY2ggUkRGIGxpc3RcbiAgICBjb25zdCBuaWwgPSBncmFwaE9iamVjdFtSREZfTklMXTtcbiAgICBpZighbmlsLnVzYWdlcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvcihsZXQgdXNhZ2Ugb2YgbmlsLnVzYWdlcykge1xuICAgICAgbGV0IG5vZGUgPSB1c2FnZS5ub2RlO1xuICAgICAgbGV0IHByb3BlcnR5ID0gdXNhZ2UucHJvcGVydHk7XG4gICAgICBsZXQgaGVhZCA9IHVzYWdlLnZhbHVlO1xuICAgICAgY29uc3QgbGlzdCA9IFtdO1xuICAgICAgY29uc3QgbGlzdE5vZGVzID0gW107XG5cbiAgICAgIC8vIGVuc3VyZSBub2RlIGlzIGEgd2VsbC1mb3JtZWQgbGlzdCBub2RlOyBpdCBtdXN0OlxuICAgICAgLy8gMS4gQmUgcmVmZXJlbmNlZCBvbmx5IG9uY2UuXG4gICAgICAvLyAyLiBIYXZlIGFuIGFycmF5IGZvciByZGY6Zmlyc3QgdGhhdCBoYXMgMSBpdGVtLlxuICAgICAgLy8gMy4gSGF2ZSBhbiBhcnJheSBmb3IgcmRmOnJlc3QgdGhhdCBoYXMgMSBpdGVtLlxuICAgICAgLy8gNC4gSGF2ZSBubyBrZXlzIG90aGVyIHRoYW46IEBpZCwgcmRmOmZpcnN0LCByZGY6cmVzdCwgYW5kLFxuICAgICAgLy8gICBvcHRpb25hbGx5LCBAdHlwZSB3aGVyZSB0aGUgdmFsdWUgaXMgcmRmOkxpc3QuXG4gICAgICBsZXQgbm9kZUtleUNvdW50ID0gT2JqZWN0LmtleXMobm9kZSkubGVuZ3RoO1xuICAgICAgd2hpbGUocHJvcGVydHkgPT09IFJERl9SRVNUICYmXG4gICAgICAgIHR5cGVzLmlzT2JqZWN0KHJlZmVyZW5jZWRPbmNlW25vZGVbJ0BpZCddXSkgJiZcbiAgICAgICAgdHlwZXMuaXNBcnJheShub2RlW1JERl9GSVJTVF0pICYmIG5vZGVbUkRGX0ZJUlNUXS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgdHlwZXMuaXNBcnJheShub2RlW1JERl9SRVNUXSkgJiYgbm9kZVtSREZfUkVTVF0ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIChub2RlS2V5Q291bnQgPT09IDMgfHxcbiAgICAgICAgICAobm9kZUtleUNvdW50ID09PSA0ICYmIHR5cGVzLmlzQXJyYXkobm9kZVsnQHR5cGUnXSkgJiZcbiAgICAgICAgICBub2RlWydAdHlwZSddLmxlbmd0aCA9PT0gMSAmJiBub2RlWydAdHlwZSddWzBdID09PSBSREZfTElTVCkpKSB7XG4gICAgICAgIGxpc3QucHVzaChub2RlW1JERl9GSVJTVF1bMF0pO1xuICAgICAgICBsaXN0Tm9kZXMucHVzaChub2RlWydAaWQnXSk7XG5cbiAgICAgICAgLy8gZ2V0IG5leHQgbm9kZSwgbW92aW5nIGJhY2t3YXJkcyB0aHJvdWdoIGxpc3RcbiAgICAgICAgdXNhZ2UgPSByZWZlcmVuY2VkT25jZVtub2RlWydAaWQnXV07XG4gICAgICAgIG5vZGUgPSB1c2FnZS5ub2RlO1xuICAgICAgICBwcm9wZXJ0eSA9IHVzYWdlLnByb3BlcnR5O1xuICAgICAgICBoZWFkID0gdXNhZ2UudmFsdWU7XG4gICAgICAgIG5vZGVLZXlDb3VudCA9IE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aDtcblxuICAgICAgICAvLyBpZiBub2RlIGlzIG5vdCBhIGJsYW5rIG5vZGUsIHRoZW4gbGlzdCBoZWFkIGZvdW5kXG4gICAgICAgIGlmKCFncmFwaFR5cGVzLmlzQmxhbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJhbnNmb3JtIGxpc3QgaW50byBAbGlzdCBvYmplY3RcbiAgICAgIGRlbGV0ZSBoZWFkWydAaWQnXTtcbiAgICAgIGhlYWRbJ0BsaXN0J10gPSBsaXN0LnJldmVyc2UoKTtcbiAgICAgIGZvcihjb25zdCBsaXN0Tm9kZSBvZiBsaXN0Tm9kZXMpIHtcbiAgICAgICAgZGVsZXRlIGdyYXBoT2JqZWN0W2xpc3ROb2RlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWxldGUgbmlsLnVzYWdlcztcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdWJqZWN0cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRHcmFwaCkuc29ydCgpO1xuICBmb3IoY29uc3Qgc3ViamVjdCBvZiBzdWJqZWN0cykge1xuICAgIGNvbnN0IG5vZGUgPSBkZWZhdWx0R3JhcGhbc3ViamVjdF07XG4gICAgaWYoc3ViamVjdCBpbiBncmFwaE1hcCkge1xuICAgICAgY29uc3QgZ3JhcGggPSBub2RlWydAZ3JhcGgnXSA9IFtdO1xuICAgICAgY29uc3QgZ3JhcGhPYmplY3QgPSBncmFwaE1hcFtzdWJqZWN0XTtcbiAgICAgIGNvbnN0IGdyYXBoU3ViamVjdHMgPSBPYmplY3Qua2V5cyhncmFwaE9iamVjdCkuc29ydCgpO1xuICAgICAgZm9yKGNvbnN0IGdyYXBoU3ViamVjdCBvZiBncmFwaFN1YmplY3RzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBncmFwaE9iamVjdFtncmFwaFN1YmplY3RdO1xuICAgICAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzIHRvIHRvcC1sZXZlbFxuICAgICAgICBpZighZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgICAgICBncmFwaC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgYWRkIGZ1bGwgc3ViamVjdHMgdG8gdG9wLWxldmVsXG4gICAgaWYoIWdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBSREYgdHJpcGxlIG9iamVjdCB0byBhIEpTT04tTEQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvIHRoZSBSREYgdHJpcGxlIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHVzZU5hdGl2ZVR5cGVzIHRydWUgdG8gb3V0cHV0IG5hdGl2ZSB0eXBlcywgZmFsc2Ugbm90IHRvLlxuICogQHBhcmFtIHJkZkRpcmVjdGlvbiB0ZXh0IGRpcmVjdGlvbiBtb2RlIFtudWxsLCBpMThuLWRhdGF0eXBlXVxuICogQHBhcmFtIG9wdGlvbnMgdG9wIGxldmVsIEFQSSBvcHRpb25zXG4gKlxuICogQHJldHVybiB0aGUgSlNPTi1MRCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9SREZUb09iamVjdChvLCB1c2VOYXRpdmVUeXBlcywgcmRmRGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIC8vIGNvbnZlcnQgTmFtZWROb2RlL0JsYW5rTm9kZSBvYmplY3QgdG8gSlNPTi1MRFxuICBpZihvLnRlcm1UeXBlLmVuZHNXaXRoKCdOb2RlJykpIHtcbiAgICByZXR1cm4geydAaWQnOiBvLnZhbHVlfTtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgbGl0ZXJhbCB0byBKU09OLUxEXG4gIGNvbnN0IHJ2YWwgPSB7J0B2YWx1ZSc6IG8udmFsdWV9O1xuXG4gIC8vIGFkZCBsYW5ndWFnZVxuICBpZihvLmxhbmd1YWdlKSB7XG4gICAgaWYoIW8ubGFuZ3VhZ2UubWF0Y2goUkVHRVhfQkNQNDcpKSB7XG4gICAgICBpZihvcHRpb25zLmV2ZW50SGFuZGxlcikge1xuICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICBjb2RlOiAnaW52YWxpZCBAbGFuZ3VhZ2UgdmFsdWUnLFxuICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdAbGFuZ3VhZ2UgdmFsdWUgbXVzdCBiZSB2YWxpZCBCQ1A0Ny4nLFxuICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICBsYW5ndWFnZTogby5sYW5ndWFnZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcnZhbFsnQGxhbmd1YWdlJ10gPSBvLmxhbmd1YWdlO1xuICB9IGVsc2Uge1xuICAgIGxldCB0eXBlID0gby5kYXRhdHlwZS52YWx1ZTtcbiAgICBpZighdHlwZSkge1xuICAgICAgdHlwZSA9IFhTRF9TVFJJTkc7XG4gICAgfVxuICAgIGlmKHR5cGUgPT09IFJERl9KU09OX0xJVEVSQUwpIHtcbiAgICAgIHR5cGUgPSAnQGpzb24nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnZhbFsnQHZhbHVlJ10gPSBKU09OLnBhcnNlKHJ2YWxbJ0B2YWx1ZSddKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICAgJ0pTT04gbGl0ZXJhbCBjb3VsZCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgJ2pzb25sZC5JbnZhbGlkSnNvbkxpdGVyYWwnLFxuICAgICAgICAgIHtjb2RlOiAnaW52YWxpZCBKU09OIGxpdGVyYWwnLCB2YWx1ZTogcnZhbFsnQHZhbHVlJ10sIGNhdXNlOiBlfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZSBuYXRpdmUgdHlwZXMgZm9yIGNlcnRhaW4geHNkIHR5cGVzXG4gICAgaWYodXNlTmF0aXZlVHlwZXMpIHtcbiAgICAgIGlmKHR5cGUgPT09IFhTRF9CT09MRUFOKSB7XG4gICAgICAgIGlmKHJ2YWxbJ0B2YWx1ZSddID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBydmFsWydAdmFsdWUnXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZihydmFsWydAdmFsdWUnXSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHJ2YWxbJ0B2YWx1ZSddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZih0eXBlcy5pc051bWVyaWMocnZhbFsnQHZhbHVlJ10pKSB7XG4gICAgICAgIGlmKHR5cGUgPT09IFhTRF9JTlRFR0VSKSB7XG4gICAgICAgICAgY29uc3QgaSA9IHBhcnNlSW50KHJ2YWxbJ0B2YWx1ZSddLCAxMCk7XG4gICAgICAgICAgaWYoaS50b0ZpeGVkKDApID09PSBydmFsWydAdmFsdWUnXSkge1xuICAgICAgICAgICAgcnZhbFsnQHZhbHVlJ10gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHR5cGUgPT09IFhTRF9ET1VCTEUpIHtcbiAgICAgICAgICBydmFsWydAdmFsdWUnXSA9IHBhcnNlRmxvYXQocnZhbFsnQHZhbHVlJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBkbyBub3QgYWRkIG5hdGl2ZSB0eXBlXG4gICAgICBpZighW1hTRF9CT09MRUFOLCBYU0RfSU5URUdFUiwgWFNEX0RPVUJMRSwgWFNEX1NUUklOR10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgcnZhbFsnQHR5cGUnXSA9IHR5cGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHJkZkRpcmVjdGlvbiA9PT0gJ2kxOG4tZGF0YXR5cGUnICYmXG4gICAgICB0eXBlLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vd3d3LnczLm9yZy9ucy9pMThuIycpKSB7XG4gICAgICBjb25zdCBbLCBsYW5ndWFnZSwgZGlyZWN0aW9uXSA9IHR5cGUuc3BsaXQoL1sjX10vKTtcbiAgICAgIGlmKGxhbmd1YWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcnZhbFsnQGxhbmd1YWdlJ10gPSBsYW5ndWFnZTtcbiAgICAgICAgaWYoIWxhbmd1YWdlLm1hdGNoKFJFR0VYX0JDUDQ3KSkge1xuICAgICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgICAgICBjb2RlOiAnaW52YWxpZCBAbGFuZ3VhZ2UgdmFsdWUnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0BsYW5ndWFnZSB2YWx1ZSBtdXN0IGJlIHZhbGlkIEJDUDQ3LicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcnZhbFsnQGRpcmVjdGlvbiddID0gZGlyZWN0aW9uO1xuICAgIH0gZWxzZSBpZih0eXBlICE9PSBYU0RfU1RSSU5HKSB7XG4gICAgICBydmFsWydAdHlwZSddID0gdHlwZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/fromRdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/graphTypes.js":
/*!***********************************************!*\
  !*** ./node_modules/jsonld/lib/graphTypes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Returns true if the given value is a subject with properties.\n *\n * @param v the value to check.\n *\n * @return true if the value is a subject with properties, false if not.\n */\napi.isSubject = v => {\n  // Note: A value is a subject if all of these hold true:\n  // 1. It is an Object.\n  // 2. It is not a @value, @set, or @list.\n  // 3. It has more than 1 key OR any existing key is not @id.\n  if(types.isObject(v) &&\n    !(('@value' in v) || ('@set' in v) || ('@list' in v))) {\n    const keyCount = Object.keys(v).length;\n    return (keyCount > 1 || !('@id' in v));\n  }\n  return false;\n};\n\n/**\n * Returns true if the given value is a subject reference.\n *\n * @param v the value to check.\n *\n * @return true if the value is a subject reference, false if not.\n */\napi.isSubjectReference = v =>\n  // Note: A value is a subject reference if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has a single key: @id.\n  (types.isObject(v) && Object.keys(v).length === 1 && ('@id' in v));\n\n/**\n * Returns true if the given value is a @value.\n *\n * @param v the value to check.\n *\n * @return true if the value is a @value, false if not.\n */\napi.isValue = v =>\n  // Note: A value is a @value if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has the @value property.\n  types.isObject(v) && ('@value' in v);\n\n/**\n * Returns true if the given value is a @list.\n *\n * @param v the value to check.\n *\n * @return true if the value is a @list, false if not.\n */\napi.isList = v =>\n  // Note: A value is a @list if all of these hold true:\n  // 1. It is an Object.\n  // 2. It has the @list property.\n  types.isObject(v) && ('@list' in v);\n\n/**\n * Returns true if the given value is a @graph.\n *\n * @return true if the value is a @graph, false if not.\n */\napi.isGraph = v => {\n  // Note: A value is a graph if all of these hold true:\n  // 1. It is an object.\n  // 2. It has an `@graph` key.\n  // 3. It may have '@id' or '@index'\n  return types.isObject(v) &&\n    '@graph' in v &&\n    Object.keys(v)\n      .filter(key => key !== '@id' && key !== '@index').length === 1;\n};\n\n/**\n * Returns true if the given value is a simple @graph.\n *\n * @return true if the value is a simple @graph, false if not.\n */\napi.isSimpleGraph = v => {\n  // Note: A value is a simple graph if all of these hold true:\n  // 1. It is an object.\n  // 2. It has an `@graph` key.\n  // 3. It has only 1 key or 2 keys where one of them is `@index`.\n  return api.isGraph(v) && !('@id' in v);\n};\n\n/**\n * Returns true if the given value is a blank node.\n *\n * @param v the value to check.\n *\n * @return true if the value is a blank node, false if not.\n */\napi.isBlankNode = v => {\n  // Note: A value is a blank node if all of these hold true:\n  // 1. It is an Object.\n  // 2. If it has an @id key that is not a string OR begins with '_:'.\n  // 3. It has no keys OR is not a @value, @set, or @list.\n  if(types.isObject(v)) {\n    if('@id' in v) {\n      const id = v['@id'];\n      return !types.isString(id) || id.indexOf('_:') === 0;\n    }\n    return (Object.keys(v).length === 0 ||\n      !(('@value' in v) || ('@set' in v) || ('@list' in v)));\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9ncmFwaFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx5REFBUzs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC9saWIvZ3JhcGhUeXBlcy5qcz8xODhkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc3ViamVjdCB3aXRoIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBzdWJqZWN0IHdpdGggcHJvcGVydGllcywgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNTdWJqZWN0ID0gdiA9PiB7XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBzdWJqZWN0IGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIE9iamVjdC5cbiAgLy8gMi4gSXQgaXMgbm90IGEgQHZhbHVlLCBAc2V0LCBvciBAbGlzdC5cbiAgLy8gMy4gSXQgaGFzIG1vcmUgdGhhbiAxIGtleSBPUiBhbnkgZXhpc3Rpbmcga2V5IGlzIG5vdCBAaWQuXG4gIGlmKHR5cGVzLmlzT2JqZWN0KHYpICYmXG4gICAgISgoJ0B2YWx1ZScgaW4gdikgfHwgKCdAc2V0JyBpbiB2KSB8fCAoJ0BsaXN0JyBpbiB2KSkpIHtcbiAgICBjb25zdCBrZXlDb3VudCA9IE9iamVjdC5rZXlzKHYpLmxlbmd0aDtcbiAgICByZXR1cm4gKGtleUNvdW50ID4gMSB8fCAhKCdAaWQnIGluIHYpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdWJqZWN0IHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN1YmplY3QgcmVmZXJlbmNlLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1N1YmplY3RSZWZlcmVuY2UgPSB2ID0+XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBzdWJqZWN0IHJlZmVyZW5jZSBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBPYmplY3QuXG4gIC8vIDIuIEl0IGhhcyBhIHNpbmdsZSBrZXk6IEBpZC5cbiAgKHR5cGVzLmlzT2JqZWN0KHYpICYmIE9iamVjdC5rZXlzKHYpLmxlbmd0aCA9PT0gMSAmJiAoJ0BpZCcgaW4gdikpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBAdmFsdWUuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBAdmFsdWUsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzVmFsdWUgPSB2ID0+XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBAdmFsdWUgaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gT2JqZWN0LlxuICAvLyAyLiBJdCBoYXMgdGhlIEB2YWx1ZSBwcm9wZXJ0eS5cbiAgdHlwZXMuaXNPYmplY3QodikgJiYgKCdAdmFsdWUnIGluIHYpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBAbGlzdC5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEBsaXN0LCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0xpc3QgPSB2ID0+XG4gIC8vIE5vdGU6IEEgdmFsdWUgaXMgYSBAbGlzdCBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBPYmplY3QuXG4gIC8vIDIuIEl0IGhhcyB0aGUgQGxpc3QgcHJvcGVydHkuXG4gIHR5cGVzLmlzT2JqZWN0KHYpICYmICgnQGxpc3QnIGluIHYpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBAZ3JhcGguXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIEBncmFwaCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNHcmFwaCA9IHYgPT4ge1xuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgZ3JhcGggaWYgYWxsIG9mIHRoZXNlIGhvbGQgdHJ1ZTpcbiAgLy8gMS4gSXQgaXMgYW4gb2JqZWN0LlxuICAvLyAyLiBJdCBoYXMgYW4gYEBncmFwaGAga2V5LlxuICAvLyAzLiBJdCBtYXkgaGF2ZSAnQGlkJyBvciAnQGluZGV4J1xuICByZXR1cm4gdHlwZXMuaXNPYmplY3QodikgJiZcbiAgICAnQGdyYXBoJyBpbiB2ICYmXG4gICAgT2JqZWN0LmtleXModilcbiAgICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ0BpZCcgJiYga2V5ICE9PSAnQGluZGV4JykubGVuZ3RoID09PSAxO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc2ltcGxlIEBncmFwaC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgc2ltcGxlIEBncmFwaCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNTaW1wbGVHcmFwaCA9IHYgPT4ge1xuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgc2ltcGxlIGdyYXBoIGlmIGFsbCBvZiB0aGVzZSBob2xkIHRydWU6XG4gIC8vIDEuIEl0IGlzIGFuIG9iamVjdC5cbiAgLy8gMi4gSXQgaGFzIGFuIGBAZ3JhcGhgIGtleS5cbiAgLy8gMy4gSXQgaGFzIG9ubHkgMSBrZXkgb3IgMiBrZXlzIHdoZXJlIG9uZSBvZiB0aGVtIGlzIGBAaW5kZXhgLlxuICByZXR1cm4gYXBpLmlzR3JhcGgodikgJiYgISgnQGlkJyBpbiB2KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGJsYW5rIG5vZGUuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBibGFuayBub2RlLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0JsYW5rTm9kZSA9IHYgPT4ge1xuICAvLyBOb3RlOiBBIHZhbHVlIGlzIGEgYmxhbmsgbm9kZSBpZiBhbGwgb2YgdGhlc2UgaG9sZCB0cnVlOlxuICAvLyAxLiBJdCBpcyBhbiBPYmplY3QuXG4gIC8vIDIuIElmIGl0IGhhcyBhbiBAaWQga2V5IHRoYXQgaXMgbm90IGEgc3RyaW5nIE9SIGJlZ2lucyB3aXRoICdfOicuXG4gIC8vIDMuIEl0IGhhcyBubyBrZXlzIE9SIGlzIG5vdCBhIEB2YWx1ZSwgQHNldCwgb3IgQGxpc3QuXG4gIGlmKHR5cGVzLmlzT2JqZWN0KHYpKSB7XG4gICAgaWYoJ0BpZCcgaW4gdikge1xuICAgICAgY29uc3QgaWQgPSB2WydAaWQnXTtcbiAgICAgIHJldHVybiAhdHlwZXMuaXNTdHJpbmcoaWQpIHx8IGlkLmluZGV4T2YoJ186JykgPT09IDA7XG4gICAgfVxuICAgIHJldHVybiAoT2JqZWN0LmtleXModikubGVuZ3RoID09PSAwIHx8XG4gICAgICAhKCgnQHZhbHVlJyBpbiB2KSB8fCAoJ0BzZXQnIGluIHYpIHx8ICgnQGxpc3QnIGluIHYpKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/graphTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * jsonld.js library.\n *\n * @author Dave Longley\n *\n * Copyright 2010-2021 Digital Bazaar, Inc.\n */\nmodule.exports = __webpack_require__(/*! ./jsonld */ \"(ssr)/./node_modules/jsonld/lib/jsonld.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbGliL2luZGV4LmpzPzkyZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBqc29ubGQuanMgbGlicmFyeS5cbiAqXG4gKiBAYXV0aG9yIERhdmUgTG9uZ2xleVxuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMjEgRGlnaXRhbCBCYXphYXIsIEluYy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2pzb25sZCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/jsonld.js":
/*!*******************************************!*\
  !*** ./node_modules/jsonld/lib/jsonld.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2022 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = __webpack_require__(/*! rdf-canonize */ \"(ssr)/./node_modules/rdf-canonize/index.js\");\nconst platform = __webpack_require__(/*! ./platform */ \"(ssr)/./node_modules/jsonld/lib/platform.js\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\nconst ContextResolver = __webpack_require__(/*! ./ContextResolver */ \"(ssr)/./node_modules/jsonld/lib/ContextResolver.js\");\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\nconst LRU = __webpack_require__(/*! lru-cache */ \"(ssr)/./node_modules/jsonld/node_modules/lru-cache/index.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"(ssr)/./node_modules/jsonld/lib/NQuads.js\");\n\nconst {expand: _expand} = __webpack_require__(/*! ./expand */ \"(ssr)/./node_modules/jsonld/lib/expand.js\");\nconst {flatten: _flatten} = __webpack_require__(/*! ./flatten */ \"(ssr)/./node_modules/jsonld/lib/flatten.js\");\nconst {fromRDF: _fromRDF} = __webpack_require__(/*! ./fromRdf */ \"(ssr)/./node_modules/jsonld/lib/fromRdf.js\");\nconst {toRDF: _toRDF} = __webpack_require__(/*! ./toRdf */ \"(ssr)/./node_modules/jsonld/lib/toRdf.js\");\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = __webpack_require__(/*! ./frame */ \"(ssr)/./node_modules/jsonld/lib/frame.js\");\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\n\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\");\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = __webpack_require__(/*! ./compact */ \"(ssr)/./node_modules/jsonld/lib/compact.js\");\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = __webpack_require__(/*! ./nodeMap */ \"(ssr)/./node_modules/jsonld/lib/nodeMap.js\");\n\nconst {\n  logEventHandler: _logEventHandler,\n  logWarningEventHandler: _logWarningEventHandler,\n  safeEventHandler: _safeEventHandler,\n  setDefaultEventHandler: _setDefaultEventHandler,\n  setupEventHandler: _setupEventHandler,\n  strictEventHandler: _strictEventHandler,\n  unhandledEventHandler: _unhandledEventHandler\n} = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/jsonld/lib/events.js\");\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n// resolved context cache\n// TODO: consider basing max on context size rather than number\nconst RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\nconst _resolvedContextCache = new LRU({max: RESOLVED_CONTEXT_CACHE_MAX_SIZE});\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false. Some well-formed\n *            and safe-mode checks may be omitted.\n *          [documentLoader(url, options)] the document loader.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b'),\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = await _compact({\n    activeCtx,\n    element: expanded,\n    options\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  for(const localCtx of contextsToProcess) {\n    activeCtx = await _processContext({activeCtx, localCtx, options});\n  }\n\n  // expand resolved input\n  let expanded = await _expand({\n    activeCtx,\n    element: toResolve.input,\n    options\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n};\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@once',\n    explicit: false,\n    requireAll: false,\n    omitDefault: false,\n    bnodesToClear: [],\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), frameContext, options);\n\n  // mode specific defaults\n  if(!options.hasOwnProperty('omitGraph')) {\n    options.omitGraph = _processingMode(activeCtx, 1.1);\n  }\n  if(!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n    options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n  }\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = {...options};\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  const frameKeys = Object.keys(frame)\n    .map(key => _expandIri(activeCtx, key, {vocab: true}));\n  opts.merged = !frameKeys.includes('@graph');\n  opts.is11 = _processingMode(activeCtx, 1.1);\n\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  opts.graph = !options.omitGraph;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  let compacted = await jsonld.compact(framed, frameContext, opts);\n\n  // replace @null with null, compacting arrays\n  opts.link = {};\n  compacted = _cleanupNull(compacted, opts);\n\n  return compacted;\n};\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n};\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * Note: Canonicalization sets `safe` to `true` and `base` to `null` by\n * default in order to produce safe outputs and \"fail closed\" by default. This\n * is different from the other API transformations in this version which\n * allow unsafe defaults (for cryptographic usage) in order to comply with the\n * JSON-LD 1.1 specification.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use (default: `null`).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false. Some well-formed\n *            and safe-mode checks may be omitted.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, options)] the document loader.\n *          [useNative] true to use a native canonize algorithm\n *          [rdfDirection] null or 'i18n-datatype' to support RDF\n *             transformation of @direction (default: null).\n *          [safe] true to use safe mode. (default: true).\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : null,\n    algorithm: 'URDNA2015',\n    skipExpansion: false,\n    safe: true,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = {...options};\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n};\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n *          [rdfDirection] null or 'i18n-datatype' to support RDF\n *             transformation of @direction (default: null).\n *          [safe] true to use safe mode. (default: false)\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // rdfParser must be synchronous or return a promise, no callback support\n  const parsedDataset = await rdfParser(dataset);\n  return _fromRDF(parsedDataset, options);\n};\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false. Some well-formed\n *            and safe-mode checks may be omitted.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [rdfDirection] null or 'i18n-datatype' to support RDF\n *             transformation of @direction (default: null).\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n};\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n};\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = {...options};\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * The default document loader for external documents.\n *\n * @param url the URL to load.\n *\n * @return a promise that resolves to the remote document.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = v\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = options.documentLoader;\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n};\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, options)] the document loader.\n *          [safe] true to use safe mode. (default: false)\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n\n  return _processContext({activeCtx, localCtx, options});\n};\n\n// backwards compatibility\njsonld.getContextValue = (__webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\").getContextValue);\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n * a string of input. An RDF dataset parser can be synchronous or\n * asynchronous (by returning a promise).\n *\n * @param contentType the content-type for the parser.\n * @param parser(input) the parser function (takes a string as a parameter\n *          and either returns an RDF dataset or a Promise that resolves to one.\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n/* URL API */\njsonld.url = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\n\n/* Events API and handlers */\njsonld.logEventHandler = _logEventHandler;\njsonld.logWarningEventHandler = _logWarningEventHandler;\njsonld.safeEventHandler = _safeEventHandler;\njsonld.setDefaultEventHandler = _setDefaultEventHandler;\njsonld.strictEventHandler = _strictEventHandler;\njsonld.unhandledEventHandler = _unhandledEventHandler;\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = __webpack_require__(/*! ./RequestQueue */ \"(ssr)/./node_modules/jsonld/lib/RequestQueue.js\");\n\n/* WebIDL API */\njsonld.JsonLdProcessor = __webpack_require__(/*! ./JsonLdProcessor */ \"(ssr)/./node_modules/jsonld/lib/JsonLdProcessor.js\")(jsonld);\n\nplatform.setupGlobals(jsonld);\nplatform.setupDocumentLoaders(jsonld);\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  // fail if obsolete options present\n  if(options && 'compactionMap' in options) {\n    throw new JsonLdError(\n      '\"compactionMap\" not supported.',\n      'jsonld.OptionsError');\n  }\n  if(options && 'expansionMap' in options) {\n    throw new JsonLdError(\n      '\"expansionMap\" not supported.',\n      'jsonld.OptionsError');\n  }\n  return Object.assign(\n    {},\n    {documentLoader},\n    defaults,\n    options,\n    {eventHandler: _setupEventHandler({options})}\n  );\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9qc29ubGQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxnRUFBYztBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywrREFBWTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsdURBQVE7QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsNkVBQW1CO0FBQ25EO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMscUVBQWU7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLDhFQUFXO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQywyREFBVTs7QUFFakMsT0FBTyxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLDJEQUFVO0FBQzVDLE9BQU8sbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyw2REFBVztBQUMvQyxPQUFPLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsNkRBQVc7QUFDL0MsT0FBTyxlQUFlLEVBQUUsbUJBQU8sQ0FBQyx5REFBUzs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseURBQVM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseURBQVM7O0FBRXJCO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxtRUFBYzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDZEQUFXOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw2REFBVzs7QUFFdkI7QUFDQTtB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSwwQkFBMEIsNkJBQTZCO0FBQ3ZEOztBQUVBO0FBQ0EseUJBQXlCLG9HQUFvQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG1CQUFPLENBQUMscURBQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx1RUFBZ0I7O0FBRTlDO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsNkVBQW1COztBQUVwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSyxlQUFlO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLLGtDQUFrQyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC9saWIvanNvbmxkLmpzP2E5MGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIEpTT04tTEQgQVBJLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQGxpY2Vuc2UgQlNEIDMtQ2xhdXNlIExpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIyIERpZ2l0YWwgQmF6YWFyLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBEaWdpdGFsIEJhemFhciwgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbiAqIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTXG4gKiBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEFcbiAqIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEXG4gKiBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuY29uc3QgY2Fub25pemUgPSByZXF1aXJlKCdyZGYtY2Fub25pemUnKTtcbmNvbnN0IHBsYXRmb3JtID0gcmVxdWlyZSgnLi9wbGF0Zm9ybScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuY29uc3QgQ29udGV4dFJlc29sdmVyID0gcmVxdWlyZSgnLi9Db250ZXh0UmVzb2x2ZXInKTtcbmNvbnN0IElkZW50aWZpZXJJc3N1ZXIgPSB1dGlsLklkZW50aWZpZXJJc3N1ZXI7XG5jb25zdCBKc29uTGRFcnJvciA9IHJlcXVpcmUoJy4vSnNvbkxkRXJyb3InKTtcbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuY29uc3QgTlF1YWRzID0gcmVxdWlyZSgnLi9OUXVhZHMnKTtcblxuY29uc3Qge2V4cGFuZDogX2V4cGFuZH0gPSByZXF1aXJlKCcuL2V4cGFuZCcpO1xuY29uc3Qge2ZsYXR0ZW46IF9mbGF0dGVufSA9IHJlcXVpcmUoJy4vZmxhdHRlbicpO1xuY29uc3Qge2Zyb21SREY6IF9mcm9tUkRGfSA9IHJlcXVpcmUoJy4vZnJvbVJkZicpO1xuY29uc3Qge3RvUkRGOiBfdG9SREZ9ID0gcmVxdWlyZSgnLi90b1JkZicpO1xuXG5jb25zdCB7XG4gIGZyYW1lTWVyZ2VkT3JEZWZhdWx0OiBfZnJhbWVNZXJnZWRPckRlZmF1bHQsXG4gIGNsZWFudXBOdWxsOiBfY2xlYW51cE51bGxcbn0gPSByZXF1aXJlKCcuL2ZyYW1lJyk7XG5cbmNvbnN0IHtcbiAgaXNBcnJheTogX2lzQXJyYXksXG4gIGlzT2JqZWN0OiBfaXNPYmplY3QsXG4gIGlzU3RyaW5nOiBfaXNTdHJpbmdcbn0gPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IHtcbiAgaXNTdWJqZWN0UmVmZXJlbmNlOiBfaXNTdWJqZWN0UmVmZXJlbmNlLFxufSA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuXG5jb25zdCB7XG4gIGV4cGFuZElyaTogX2V4cGFuZElyaSxcbiAgZ2V0SW5pdGlhbENvbnRleHQ6IF9nZXRJbml0aWFsQ29udGV4dCxcbiAgcHJvY2VzczogX3Byb2Nlc3NDb250ZXh0LFxuICBwcm9jZXNzaW5nTW9kZTogX3Byb2Nlc3NpbmdNb2RlXG59ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5cbmNvbnN0IHtcbiAgY29tcGFjdDogX2NvbXBhY3QsXG4gIGNvbXBhY3RJcmk6IF9jb21wYWN0SXJpXG59ID0gcmVxdWlyZSgnLi9jb21wYWN0Jyk7XG5cbmNvbnN0IHtcbiAgY3JlYXRlTm9kZU1hcDogX2NyZWF0ZU5vZGVNYXAsXG4gIGNyZWF0ZU1lcmdlZE5vZGVNYXA6IF9jcmVhdGVNZXJnZWROb2RlTWFwLFxuICBtZXJnZU5vZGVNYXBzOiBfbWVyZ2VOb2RlTWFwc1xufSA9IHJlcXVpcmUoJy4vbm9kZU1hcCcpO1xuXG5jb25zdCB7XG4gIGxvZ0V2ZW50SGFuZGxlcjogX2xvZ0V2ZW50SGFuZGxlcixcbiAgbG9nV2FybmluZ0V2ZW50SGFuZGxlcjogX2xvZ1dhcm5pbmdFdmVudEhhbmRsZXIsXG4gIHNhZmVFdmVudEhhbmRsZXI6IF9zYWZlRXZlbnRIYW5kbGVyLFxuICBzZXREZWZhdWx0RXZlbnRIYW5kbGVyOiBfc2V0RGVmYXVsdEV2ZW50SGFuZGxlcixcbiAgc2V0dXBFdmVudEhhbmRsZXI6IF9zZXR1cEV2ZW50SGFuZGxlcixcbiAgc3RyaWN0RXZlbnRIYW5kbGVyOiBfc3RyaWN0RXZlbnRIYW5kbGVyLFxuICB1bmhhbmRsZWRFdmVudEhhbmRsZXI6IF91bmhhbmRsZWRFdmVudEhhbmRsZXJcbn0gPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cbi8vIGF0dGFjaGVzIGpzb25sZCBBUEkgdG8gdGhlIGdpdmVuIG9iamVjdFxuY29uc3Qgd3JhcHBlciA9IGZ1bmN0aW9uKGpzb25sZCkge1xuXG4vKiogUmVnaXN0ZXJlZCBSREYgZGF0YXNldCBwYXJzZXJzIGhhc2hlZCBieSBjb250ZW50LXR5cGUuICovXG5jb25zdCBfcmRmUGFyc2VycyA9IHt9O1xuXG4vLyByZXNvbHZlZCBjb250ZXh0IGNhY2hlXG4vLyBUT0RPOiBjb25zaWRlciBiYXNpbmcgbWF4IG9uIGNvbnRleHQgc2l6ZSByYXRoZXIgdGhhbiBudW1iZXJcbmNvbnN0IFJFU09MVkVEX0NPTlRFWFRfQ0FDSEVfTUFYX1NJWkUgPSAxMDA7XG5jb25zdCBfcmVzb2x2ZWRDb250ZXh0Q2FjaGUgPSBuZXcgTFJVKHttYXg6IFJFU09MVkVEX0NPTlRFWFRfQ0FDSEVfTUFYX1NJWkV9KTtcblxuLyogQ29yZSBBUEkgKi9cblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGNvbXBhY3Rpb24uXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0IHRvIGNvbXBhY3QuXG4gKiBAcGFyYW0gY3R4IHRoZSBjb250ZXh0IHRvIGNvbXBhY3Qgd2l0aC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtjb21wYWN0QXJyYXlzXSB0cnVlIHRvIGNvbXBhY3QgYXJyYXlzIHRvIHNpbmdsZSB2YWx1ZXMgd2hlblxuICogICAgICAgICAgICBhcHByb3ByaWF0ZSwgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiB0cnVlKS5cbiAqICAgICAgICAgIFtjb21wYWN0VG9SZWxhdGl2ZV0gdHJ1ZSB0byBjb21wYWN0IElSSXMgdG8gYmUgcmVsYXRpdmUgdG8gZG9jdW1lbnRcbiAqICAgICAgICAgICAgYmFzZSwgZmFsc2UgdG8ga2VlcCBhYnNvbHV0ZSAoZGVmYXVsdDogdHJ1ZSlcbiAqICAgICAgICAgIFtncmFwaF0gdHJ1ZSB0byBhbHdheXMgb3V0cHV0IGEgdG9wLWxldmVsIGdyYXBoIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW3NraXBFeHBhbnNpb25dIHRydWUgdG8gYXNzdW1lIHRoZSBpbnB1dCBpcyBleHBhbmRlZCBhbmQgc2tpcFxuICogICAgICAgICAgICBleHBhbnNpb24sIGZhbHNlIG5vdCB0bywgZGVmYXVsdHMgdG8gZmFsc2UuIFNvbWUgd2VsbC1mb3JtZWRcbiAqICAgICAgICAgICAgYW5kIHNhZmUtbW9kZSBjaGVja3MgbWF5IGJlIG9taXR0ZWQuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtmcmFtaW5nXSB0cnVlIGlmIGNvbXBhY3Rpb24gaXMgb2NjdXJpbmcgZHVyaW5nIGEgZnJhbWluZyBvcGVyYXRpb24uXG4gKiAgICAgICAgICBbc2FmZV0gdHJ1ZSB0byB1c2Ugc2FmZSBtb2RlLiAoZGVmYXVsdDogZmFsc2UpXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb21wYWN0ZWQgb3V0cHV0LlxuICovXG5qc29ubGQuY29tcGFjdCA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBjdHgsIG9wdGlvbnMpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb3VsZCBub3QgY29tcGFjdCwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICBpZihjdHggPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnVGhlIGNvbXBhY3Rpb24gY29udGV4dCBtdXN0IG5vdCBiZSBudWxsLicsXG4gICAgICAnanNvbmxkLkNvbXBhY3RFcnJvcicsIHtjb2RlOiAnaW52YWxpZCBsb2NhbCBjb250ZXh0J30pO1xuICB9XG5cbiAgLy8gbm90aGluZyB0byBjb21wYWN0XG4gIGlmKGlucHV0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGNvbXBhY3RBcnJheXM6IHRydWUsXG4gICAgY29tcGFjdFRvUmVsYXRpdmU6IHRydWUsXG4gICAgZ3JhcGg6IGZhbHNlLFxuICAgIHNraXBFeHBhbnNpb246IGZhbHNlLFxuICAgIGxpbms6IGZhbHNlLFxuICAgIGlzc3VlcjogbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG4gIGlmKG9wdGlvbnMubGluaykge1xuICAgIC8vIGZvcmNlIHNraXAgZXhwYW5zaW9uIHdoZW4gbGlua2luZywgXCJsaW5rXCIgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpY1xuICAgIC8vIEFQSSwgaXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gZnJhbWluZ1xuICAgIG9wdGlvbnMuc2tpcEV4cGFuc2lvbiA9IHRydWU7XG4gIH1cbiAgaWYoIW9wdGlvbnMuY29tcGFjdFRvUmVsYXRpdmUpIHtcbiAgICBkZWxldGUgb3B0aW9ucy5iYXNlO1xuICB9XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGxldCBleHBhbmRlZDtcbiAgaWYob3B0aW9ucy5za2lwRXhwYW5zaW9uKSB7XG4gICAgZXhwYW5kZWQgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICBleHBhbmRlZCA9IGF3YWl0IGpzb25sZC5leHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gcHJvY2VzcyBjb250ZXh0XG4gIGNvbnN0IGFjdGl2ZUN0eCA9IGF3YWl0IGpzb25sZC5wcm9jZXNzQ29udGV4dChcbiAgICBfZ2V0SW5pdGlhbENvbnRleHQob3B0aW9ucyksIGN0eCwgb3B0aW9ucyk7XG5cbiAgLy8gZG8gY29tcGFjdGlvblxuICBsZXQgY29tcGFjdGVkID0gYXdhaXQgX2NvbXBhY3Qoe1xuICAgIGFjdGl2ZUN0eCxcbiAgICBlbGVtZW50OiBleHBhbmRlZCxcbiAgICBvcHRpb25zXG4gIH0pO1xuXG4gIC8vIHBlcmZvcm0gY2xlYW4gdXBcbiAgaWYob3B0aW9ucy5jb21wYWN0QXJyYXlzICYmICFvcHRpb25zLmdyYXBoICYmIF9pc0FycmF5KGNvbXBhY3RlZCkpIHtcbiAgICBpZihjb21wYWN0ZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBzaW1wbGlmeSB0byBhIHNpbmdsZSBpdGVtXG4gICAgICBjb21wYWN0ZWQgPSBjb21wYWN0ZWRbMF07XG4gICAgfSBlbHNlIGlmKGNvbXBhY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHNpbXBsaWZ5IHRvIGFuIGVtcHR5IG9iamVjdFxuICAgICAgY29tcGFjdGVkID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYob3B0aW9ucy5ncmFwaCAmJiBfaXNPYmplY3QoY29tcGFjdGVkKSkge1xuICAgIC8vIGFsd2F5cyB1c2UgYXJyYXkgaWYgZ3JhcGggb3B0aW9uIGlzIG9uXG4gICAgY29tcGFjdGVkID0gW2NvbXBhY3RlZF07XG4gIH1cblxuICAvLyBmb2xsb3cgQGNvbnRleHQga2V5XG4gIGlmKF9pc09iamVjdChjdHgpICYmICdAY29udGV4dCcgaW4gY3R4KSB7XG4gICAgY3R4ID0gY3R4WydAY29udGV4dCddO1xuICB9XG5cbiAgLy8gYnVpbGQgb3V0cHV0IGNvbnRleHRcbiAgY3R4ID0gdXRpbC5jbG9uZShjdHgpO1xuICBpZighX2lzQXJyYXkoY3R4KSkge1xuICAgIGN0eCA9IFtjdHhdO1xuICB9XG4gIC8vIHJlbW92ZSBlbXB0eSBjb250ZXh0c1xuICBjb25zdCB0bXAgPSBjdHg7XG4gIGN0eCA9IFtdO1xuICBmb3IobGV0IGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKytpKSB7XG4gICAgaWYoIV9pc09iamVjdCh0bXBbaV0pIHx8IE9iamVjdC5rZXlzKHRtcFtpXSkubGVuZ3RoID4gMCkge1xuICAgICAgY3R4LnB1c2godG1wW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyByZW1vdmUgYXJyYXkgaWYgb25seSBvbmUgY29udGV4dFxuICBjb25zdCBoYXNDb250ZXh0ID0gKGN0eC5sZW5ndGggPiAwKTtcbiAgaWYoY3R4Lmxlbmd0aCA9PT0gMSkge1xuICAgIGN0eCA9IGN0eFswXTtcbiAgfVxuXG4gIC8vIGFkZCBjb250ZXh0IGFuZC9vciBAZ3JhcGhcbiAgaWYoX2lzQXJyYXkoY29tcGFjdGVkKSkge1xuICAgIC8vIHVzZSAnQGdyYXBoJyBrZXl3b3JkXG4gICAgY29uc3QgZ3JhcGhBbGlhcyA9IF9jb21wYWN0SXJpKHtcbiAgICAgIGFjdGl2ZUN0eCwgaXJpOiAnQGdyYXBoJywgcmVsYXRpdmVUbzoge3ZvY2FiOiB0cnVlfVxuICAgIH0pO1xuICAgIGNvbnN0IGdyYXBoID0gY29tcGFjdGVkO1xuICAgIGNvbXBhY3RlZCA9IHt9O1xuICAgIGlmKGhhc0NvbnRleHQpIHtcbiAgICAgIGNvbXBhY3RlZFsnQGNvbnRleHQnXSA9IGN0eDtcbiAgICB9XG4gICAgY29tcGFjdGVkW2dyYXBoQWxpYXNdID0gZ3JhcGg7XG4gIH0gZWxzZSBpZihfaXNPYmplY3QoY29tcGFjdGVkKSAmJiBoYXNDb250ZXh0KSB7XG4gICAgLy8gcmVvcmRlciBrZXlzIHNvIEBjb250ZXh0IGlzIGZpcnN0XG4gICAgY29uc3QgZ3JhcGggPSBjb21wYWN0ZWQ7XG4gICAgY29tcGFjdGVkID0geydAY29udGV4dCc6IGN0eH07XG4gICAgZm9yKGNvbnN0IGtleSBpbiBncmFwaCkge1xuICAgICAgY29tcGFjdGVkW2tleV0gPSBncmFwaFtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21wYWN0ZWQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIEpTT04tTEQgZXhwYW5zaW9uLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBpbnB1dCB0byBleHBhbmQuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtiYXNlXSB0aGUgYmFzZSBJUkkgdG8gdXNlLlxuICogICAgICAgICAgW2V4cGFuZENvbnRleHRdIGEgY29udGV4dCB0byBleHBhbmQgd2l0aC5cbiAqICAgICAgICAgIFtrZWVwRnJlZUZsb2F0aW5nTm9kZXNdIHRydWUgdG8ga2VlcCBmcmVlLWZsb2F0aW5nIG5vZGVzLFxuICogICAgICAgICAgICBmYWxzZSBub3QgdG8sIGRlZmF1bHRzIHRvIGZhbHNlLlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbc2FmZV0gdHJ1ZSB0byB1c2Ugc2FmZSBtb2RlLiAoZGVmYXVsdDogZmFsc2UpXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBleHBhbmRlZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5leHBhbmQgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBleHBhbmQsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBrZWVwRnJlZUZsb2F0aW5nTm9kZXM6IGZhbHNlLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gYnVpbGQgc2V0IG9mIG9iamVjdHMgdGhhdCBtYXkgaGF2ZSBAY29udGV4dHMgdG8gcmVzb2x2ZVxuICBjb25zdCB0b1Jlc29sdmUgPSB7fTtcblxuICAvLyBidWlsZCBzZXQgb2YgY29udGV4dHMgdG8gcHJvY2VzcyBwcmlvciB0byBleHBhbnNpb25cbiAgY29uc3QgY29udGV4dHNUb1Byb2Nlc3MgPSBbXTtcblxuICAvLyBpZiBhbiBgZXhwYW5kQ29udGV4dGAgaGFzIGJlZW4gZ2l2ZW4gZW5zdXJlIGl0IGdldHMgcmVzb2x2ZWRcbiAgaWYoJ2V4cGFuZENvbnRleHQnIGluIG9wdGlvbnMpIHtcbiAgICBjb25zdCBleHBhbmRDb250ZXh0ID0gdXRpbC5jbG9uZShvcHRpb25zLmV4cGFuZENvbnRleHQpO1xuICAgIGlmKF9pc09iamVjdChleHBhbmRDb250ZXh0KSAmJiAnQGNvbnRleHQnIGluIGV4cGFuZENvbnRleHQpIHtcbiAgICAgIHRvUmVzb2x2ZS5leHBhbmRDb250ZXh0ID0gZXhwYW5kQ29udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9SZXNvbHZlLmV4cGFuZENvbnRleHQgPSB7J0Bjb250ZXh0JzogZXhwYW5kQ29udGV4dH07XG4gICAgfVxuICAgIGNvbnRleHRzVG9Qcm9jZXNzLnB1c2godG9SZXNvbHZlLmV4cGFuZENvbnRleHQpO1xuICB9XG5cbiAgLy8gaWYgaW5wdXQgaXMgYSBzdHJpbmcsIGF0dGVtcHQgdG8gZGVyZWZlcmVuY2UgcmVtb3RlIGRvY3VtZW50XG4gIGxldCBkZWZhdWx0QmFzZTtcbiAgaWYoIV9pc1N0cmluZyhpbnB1dCkpIHtcbiAgICAvLyBpbnB1dCBpcyBub3QgYSBVUkwsIGRvIG5vdCBuZWVkIHRvIHJldHJpZXZlIGl0IGZpcnN0XG4gICAgdG9SZXNvbHZlLmlucHV0ID0gdXRpbC5jbG9uZShpbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbG9hZCByZW1vdGUgZG9jXG4gICAgY29uc3QgcmVtb3RlRG9jID0gYXdhaXQganNvbmxkLmdldChpbnB1dCwgb3B0aW9ucyk7XG4gICAgZGVmYXVsdEJhc2UgPSByZW1vdGVEb2MuZG9jdW1lbnRVcmw7XG4gICAgdG9SZXNvbHZlLmlucHV0ID0gcmVtb3RlRG9jLmRvY3VtZW50O1xuICAgIGlmKHJlbW90ZURvYy5jb250ZXh0VXJsKSB7XG4gICAgICAvLyBjb250ZXh0IGluY2x1ZGVkIGluIEhUVFAgbGluayBoZWFkZXIgYW5kIG11c3QgYmUgcmVzb2x2ZWRcbiAgICAgIHRvUmVzb2x2ZS5yZW1vdGVDb250ZXh0ID0geydAY29udGV4dCc6IHJlbW90ZURvYy5jb250ZXh0VXJsfTtcbiAgICAgIGNvbnRleHRzVG9Qcm9jZXNzLnB1c2godG9SZXNvbHZlLnJlbW90ZUNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IGJhc2VcbiAgaWYoISgnYmFzZScgaW4gb3B0aW9ucykpIHtcbiAgICBvcHRpb25zLmJhc2UgPSBkZWZhdWx0QmFzZSB8fCAnJztcbiAgfVxuXG4gIC8vIHByb2Nlc3MgYW55IGFkZGl0aW9uYWwgY29udGV4dHNcbiAgbGV0IGFjdGl2ZUN0eCA9IF9nZXRJbml0aWFsQ29udGV4dChvcHRpb25zKTtcbiAgZm9yKGNvbnN0IGxvY2FsQ3R4IG9mIGNvbnRleHRzVG9Qcm9jZXNzKSB7XG4gICAgYWN0aXZlQ3R4ID0gYXdhaXQgX3Byb2Nlc3NDb250ZXh0KHthY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zfSk7XG4gIH1cblxuICAvLyBleHBhbmQgcmVzb2x2ZWQgaW5wdXRcbiAgbGV0IGV4cGFuZGVkID0gYXdhaXQgX2V4cGFuZCh7XG4gICAgYWN0aXZlQ3R4LFxuICAgIGVsZW1lbnQ6IHRvUmVzb2x2ZS5pbnB1dCxcbiAgICBvcHRpb25zXG4gIH0pO1xuXG4gIC8vIG9wdGltaXplIGF3YXkgQGdyYXBoIHdpdGggbm8gb3RoZXIgcHJvcGVydGllc1xuICBpZihfaXNPYmplY3QoZXhwYW5kZWQpICYmICgnQGdyYXBoJyBpbiBleHBhbmRlZCkgJiZcbiAgICBPYmplY3Qua2V5cyhleHBhbmRlZCkubGVuZ3RoID09PSAxKSB7XG4gICAgZXhwYW5kZWQgPSBleHBhbmRlZFsnQGdyYXBoJ107XG4gIH0gZWxzZSBpZihleHBhbmRlZCA9PT0gbnVsbCkge1xuICAgIGV4cGFuZGVkID0gW107XG4gIH1cblxuICAvLyBub3JtYWxpemUgdG8gYW4gYXJyYXlcbiAgaWYoIV9pc0FycmF5KGV4cGFuZGVkKSkge1xuICAgIGV4cGFuZGVkID0gW2V4cGFuZGVkXTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgSlNPTi1MRCBmbGF0dGVuaW5nLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCB0byBmbGF0dGVuLlxuICogQHBhcmFtIGN0eCB0aGUgY29udGV4dCB0byB1c2UgdG8gY29tcGFjdCB0aGUgZmxhdHRlbmVkIG91dHB1dCwgb3IgbnVsbC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmbGF0dGVuZWQgb3V0cHV0LlxuICovXG5qc29ubGQuZmxhdHRlbiA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBjdHgsIG9wdGlvbnMpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGZsYXR0ZW4sIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgaWYodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGN0eCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgY3R4ID0gY3R4IHx8IG51bGw7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGNvbnN0IGV4cGFuZGVkID0gYXdhaXQganNvbmxkLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gZG8gZmxhdHRlbmluZ1xuICBjb25zdCBmbGF0dGVuZWQgPSBfZmxhdHRlbihleHBhbmRlZCk7XG5cbiAgaWYoY3R4ID09PSBudWxsKSB7XG4gICAgLy8gbm8gY29tcGFjdGlvbiByZXF1aXJlZFxuICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gIH1cblxuICAvLyBjb21wYWN0IHJlc3VsdCAoZm9yY2UgQGdyYXBoIG9wdGlvbiB0byB0cnVlLCBza2lwIGV4cGFuc2lvbilcbiAgb3B0aW9ucy5ncmFwaCA9IHRydWU7XG4gIG9wdGlvbnMuc2tpcEV4cGFuc2lvbiA9IHRydWU7XG4gIGNvbnN0IGNvbXBhY3RlZCA9IGF3YWl0IGpzb25sZC5jb21wYWN0KGZsYXR0ZW5lZCwgY3R4LCBvcHRpb25zKTtcblxuICByZXR1cm4gY29tcGFjdGVkO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBKU09OLUxEIGZyYW1pbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0IHRvIGZyYW1lLlxuICogQHBhcmFtIGZyYW1lIHRoZSBKU09OLUxEIGZyYW1lIHRvIHVzZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIGZyYW1pbmcgb3B0aW9ucy5cbiAqICAgICAgICAgIFtiYXNlXSB0aGUgYmFzZSBJUkkgdG8gdXNlLlxuICogICAgICAgICAgW2V4cGFuZENvbnRleHRdIGEgY29udGV4dCB0byBleHBhbmQgd2l0aC5cbiAqICAgICAgICAgIFtlbWJlZF0gZGVmYXVsdCBAZW1iZWQgZmxhZzogJ0BsYXN0JywgJ0BhbHdheXMnLCAnQG5ldmVyJywgJ0BsaW5rJ1xuICogICAgICAgICAgICAoZGVmYXVsdDogJ0BsYXN0JykuXG4gKiAgICAgICAgICBbZXhwbGljaXRdIGRlZmF1bHQgQGV4cGxpY2l0IGZsYWcgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFtyZXF1aXJlQWxsXSBkZWZhdWx0IEByZXF1aXJlQWxsIGZsYWcgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgICAgW29taXREZWZhdWx0XSBkZWZhdWx0IEBvbWl0RGVmYXVsdCBmbGFnIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtzYWZlXSB0cnVlIHRvIHVzZSBzYWZlIG1vZGUuIChkZWZhdWx0OiBmYWxzZSlcbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZyYW1lZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5mcmFtZSA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBmcmFtZSwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBmcmFtZSwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIGVtYmVkOiAnQG9uY2UnLFxuICAgIGV4cGxpY2l0OiBmYWxzZSxcbiAgICByZXF1aXJlQWxsOiBmYWxzZSxcbiAgICBvbWl0RGVmYXVsdDogZmFsc2UsXG4gICAgYm5vZGVzVG9DbGVhcjogW10sXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyBpZiBmcmFtZSBpcyBhIHN0cmluZywgYXR0ZW1wdCB0byBkZXJlZmVyZW5jZSByZW1vdGUgZG9jdW1lbnRcbiAgaWYoX2lzU3RyaW5nKGZyYW1lKSkge1xuICAgIC8vIGxvYWQgcmVtb3RlIGRvY1xuICAgIGNvbnN0IHJlbW90ZURvYyA9IGF3YWl0IGpzb25sZC5nZXQoZnJhbWUsIG9wdGlvbnMpO1xuICAgIGZyYW1lID0gcmVtb3RlRG9jLmRvY3VtZW50O1xuXG4gICAgaWYocmVtb3RlRG9jLmNvbnRleHRVcmwpIHtcbiAgICAgIC8vIGluamVjdCBsaW5rIGhlYWRlciBAY29udGV4dCBpbnRvIGZyYW1lXG4gICAgICBsZXQgY3R4ID0gZnJhbWVbJ0Bjb250ZXh0J107XG4gICAgICBpZighY3R4KSB7XG4gICAgICAgIGN0eCA9IHJlbW90ZURvYy5jb250ZXh0VXJsO1xuICAgICAgfSBlbHNlIGlmKF9pc0FycmF5KGN0eCkpIHtcbiAgICAgICAgY3R4LnB1c2gocmVtb3RlRG9jLmNvbnRleHRVcmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4ID0gW2N0eCwgcmVtb3RlRG9jLmNvbnRleHRVcmxdO1xuICAgICAgfVxuICAgICAgZnJhbWVbJ0Bjb250ZXh0J10gPSBjdHg7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZnJhbWVDb250ZXh0ID0gZnJhbWUgPyBmcmFtZVsnQGNvbnRleHQnXSB8fCB7fSA6IHt9O1xuXG4gIC8vIHByb2Nlc3MgY29udGV4dFxuICBjb25zdCBhY3RpdmVDdHggPSBhd2FpdCBqc29ubGQucHJvY2Vzc0NvbnRleHQoXG4gICAgX2dldEluaXRpYWxDb250ZXh0KG9wdGlvbnMpLCBmcmFtZUNvbnRleHQsIG9wdGlvbnMpO1xuXG4gIC8vIG1vZGUgc3BlY2lmaWMgZGVmYXVsdHNcbiAgaWYoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ29taXRHcmFwaCcpKSB7XG4gICAgb3B0aW9ucy5vbWl0R3JhcGggPSBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpO1xuICB9XG4gIGlmKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdwcnVuZUJsYW5rTm9kZUlkZW50aWZpZXJzJykpIHtcbiAgICBvcHRpb25zLnBydW5lQmxhbmtOb2RlSWRlbnRpZmllcnMgPSBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpO1xuICB9XG5cbiAgLy8gZXhwYW5kIGlucHV0XG4gIGNvbnN0IGV4cGFuZGVkID0gYXdhaXQganNvbmxkLmV4cGFuZChpbnB1dCwgb3B0aW9ucyk7XG5cbiAgLy8gZXhwYW5kIGZyYW1lXG4gIGNvbnN0IG9wdHMgPSB7Li4ub3B0aW9uc307XG4gIG9wdHMuaXNGcmFtZSA9IHRydWU7XG4gIG9wdHMua2VlcEZyZWVGbG9hdGluZ05vZGVzID0gdHJ1ZTtcbiAgY29uc3QgZXhwYW5kZWRGcmFtZSA9IGF3YWl0IGpzb25sZC5leHBhbmQoZnJhbWUsIG9wdHMpO1xuXG4gIC8vIGlmIHRoZSB1bmV4cGFuZGVkIGZyYW1lIGluY2x1ZGVzIGEga2V5IGV4cGFuZGluZyB0byBAZ3JhcGgsIGZyYW1lIHRoZVxuICAvLyBkZWZhdWx0IGdyYXBoLCBvdGhlcndpc2UsIHRoZSBtZXJnZWQgZ3JhcGhcbiAgY29uc3QgZnJhbWVLZXlzID0gT2JqZWN0LmtleXMoZnJhbWUpXG4gICAgLm1hcChrZXkgPT4gX2V4cGFuZElyaShhY3RpdmVDdHgsIGtleSwge3ZvY2FiOiB0cnVlfSkpO1xuICBvcHRzLm1lcmdlZCA9ICFmcmFtZUtleXMuaW5jbHVkZXMoJ0BncmFwaCcpO1xuICBvcHRzLmlzMTEgPSBfcHJvY2Vzc2luZ01vZGUoYWN0aXZlQ3R4LCAxLjEpO1xuXG4gIC8vIGRvIGZyYW1pbmdcbiAgY29uc3QgZnJhbWVkID0gX2ZyYW1lTWVyZ2VkT3JEZWZhdWx0KGV4cGFuZGVkLCBleHBhbmRlZEZyYW1lLCBvcHRzKTtcblxuICBvcHRzLmdyYXBoID0gIW9wdGlvbnMub21pdEdyYXBoO1xuICBvcHRzLnNraXBFeHBhbnNpb24gPSB0cnVlO1xuICBvcHRzLmxpbmsgPSB7fTtcbiAgb3B0cy5mcmFtaW5nID0gdHJ1ZTtcbiAgbGV0IGNvbXBhY3RlZCA9IGF3YWl0IGpzb25sZC5jb21wYWN0KGZyYW1lZCwgZnJhbWVDb250ZXh0LCBvcHRzKTtcblxuICAvLyByZXBsYWNlIEBudWxsIHdpdGggbnVsbCwgY29tcGFjdGluZyBhcnJheXNcbiAgb3B0cy5saW5rID0ge307XG4gIGNvbXBhY3RlZCA9IF9jbGVhbnVwTnVsbChjb21wYWN0ZWQsIG9wdHMpO1xuXG4gIHJldHVybiBjb21wYWN0ZWQ7XG59O1xuXG4vKipcbiAqICoqRXhwZXJpbWVudGFsKipcbiAqXG4gKiBMaW5rcyBhIEpTT04tTEQgZG9jdW1lbnQncyBub2RlcyBpbiBtZW1vcnkuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGRvY3VtZW50IHRvIGxpbmsuXG4gKiBAcGFyYW0gW2N0eF0gdGhlIEpTT04tTEQgY29udGV4dCB0byBhcHBseS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbc2FmZV0gdHJ1ZSB0byB1c2Ugc2FmZSBtb2RlLiAoZGVmYXVsdDogZmFsc2UpXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsaW5rZWQgb3V0cHV0LlxuICovXG5qc29ubGQubGluayA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBjdHgsIG9wdGlvbnMpIHtcbiAgLy8gQVBJIG1hdGNoZXMgcnVubmluZyBmcmFtZSB3aXRoIGEgd2lsZGNhcmQgZnJhbWUgYW5kIGVtYmVkOiAnQGxpbmsnXG4gIC8vIGdldCBhcmd1bWVudHNcbiAgY29uc3QgZnJhbWUgPSB7fTtcbiAgaWYoY3R4KSB7XG4gICAgZnJhbWVbJ0Bjb250ZXh0J10gPSBjdHg7XG4gIH1cbiAgZnJhbWVbJ0BlbWJlZCddID0gJ0BsaW5rJztcbiAgcmV0dXJuIGpzb25sZC5mcmFtZShpbnB1dCwgZnJhbWUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBSREYgZGF0YXNldCBub3JtYWxpemF0aW9uIG9uIHRoZSBnaXZlbiBpbnB1dC4gVGhlIGlucHV0IGlzIEpTT04tTERcbiAqIHVubGVzcyB0aGUgJ2lucHV0Rm9ybWF0JyBvcHRpb24gaXMgdXNlZC4gVGhlIG91dHB1dCBpcyBhbiBSREYgZGF0YXNldFxuICogdW5sZXNzIHRoZSAnZm9ybWF0JyBvcHRpb24gaXMgdXNlZC5cbiAqXG4gKiBOb3RlOiBDYW5vbmljYWxpemF0aW9uIHNldHMgYHNhZmVgIHRvIGB0cnVlYCBhbmQgYGJhc2VgIHRvIGBudWxsYCBieVxuICogZGVmYXVsdCBpbiBvcmRlciB0byBwcm9kdWNlIHNhZmUgb3V0cHV0cyBhbmQgXCJmYWlsIGNsb3NlZFwiIGJ5IGRlZmF1bHQuIFRoaXNcbiAqIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlciBBUEkgdHJhbnNmb3JtYXRpb25zIGluIHRoaXMgdmVyc2lvbiB3aGljaFxuICogYWxsb3cgdW5zYWZlIGRlZmF1bHRzIChmb3IgY3J5cHRvZ3JhcGhpYyB1c2FnZSkgaW4gb3JkZXIgdG8gY29tcGx5IHdpdGggdGhlXG4gKiBKU09OLUxEIDEuMSBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgaW5wdXQgdG8gbm9ybWFsaXplIGFzIEpTT04tTEQgb3IgYXMgYSBmb3JtYXQgc3BlY2lmaWVkIGJ5XG4gKiAgICAgICAgICB0aGUgJ2lucHV0Rm9ybWF0JyBvcHRpb24uXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFthbGdvcml0aG1dIHRoZSBub3JtYWxpemF0aW9uIGFsZ29yaXRobSB0byB1c2UsIGBVUkROQTIwMTVgIG9yXG4gKiAgICAgICAgICAgIGBVUkdOQTIwMTJgIChkZWZhdWx0OiBgVVJETkEyMDE1YCkuXG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZSAoZGVmYXVsdDogYG51bGxgKS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbc2tpcEV4cGFuc2lvbl0gdHJ1ZSB0byBhc3N1bWUgdGhlIGlucHV0IGlzIGV4cGFuZGVkIGFuZCBza2lwXG4gKiAgICAgICAgICAgIGV4cGFuc2lvbiwgZmFsc2Ugbm90IHRvLCBkZWZhdWx0cyB0byBmYWxzZS4gU29tZSB3ZWxsLWZvcm1lZFxuICogICAgICAgICAgICBhbmQgc2FmZS1tb2RlIGNoZWNrcyBtYXkgYmUgb21pdHRlZC5cbiAqICAgICAgICAgIFtpbnB1dEZvcm1hdF0gdGhlIGZvcm1hdCBpZiBpbnB1dCBpcyBub3QgSlNPTi1MRDpcbiAqICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBOLVF1YWRzLlxuICogICAgICAgICAgW2Zvcm1hdF0gdGhlIGZvcm1hdCBpZiBvdXRwdXQgaXMgYSBzdHJpbmc6XG4gKiAgICAgICAgICAgICdhcHBsaWNhdGlvbi9uLXF1YWRzJyBmb3IgTi1RdWFkcy5cbiAqICAgICAgICAgIFtkb2N1bWVudExvYWRlcih1cmwsIG9wdGlvbnMpXSB0aGUgZG9jdW1lbnQgbG9hZGVyLlxuICogICAgICAgICAgW3VzZU5hdGl2ZV0gdHJ1ZSB0byB1c2UgYSBuYXRpdmUgY2Fub25pemUgYWxnb3JpdGhtXG4gKiAgICAgICAgICBbcmRmRGlyZWN0aW9uXSBudWxsIG9yICdpMThuLWRhdGF0eXBlJyB0byBzdXBwb3J0IFJERlxuICogICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24gb2YgQGRpcmVjdGlvbiAoZGVmYXVsdDogbnVsbCkuXG4gKiAgICAgICAgICBbc2FmZV0gdHJ1ZSB0byB1c2Ugc2FmZSBtb2RlLiAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBub3JtYWxpemVkIG91dHB1dC5cbiAqL1xuanNvbmxkLm5vcm1hbGl6ZSA9IGpzb25sZC5jYW5vbml6ZSA9IGFzeW5jIGZ1bmN0aW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNhbm9uaXplLCB0b28gZmV3IGFyZ3VtZW50cy4nKTtcbiAgfVxuXG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogX2lzU3RyaW5nKGlucHV0KSA/IGlucHV0IDogbnVsbCxcbiAgICBhbGdvcml0aG06ICdVUkROQTIwMTUnLFxuICAgIHNraXBFeHBhbnNpb246IGZhbHNlLFxuICAgIHNhZmU6IHRydWUsXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcbiAgaWYoJ2lucHV0Rm9ybWF0JyBpbiBvcHRpb25zKSB7XG4gICAgaWYob3B0aW9ucy5pbnB1dEZvcm1hdCAhPT0gJ2FwcGxpY2F0aW9uL24tcXVhZHMnICYmXG4gICAgICBvcHRpb25zLmlucHV0Rm9ybWF0ICE9PSAnYXBwbGljYXRpb24vbnF1YWRzJykge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVW5rbm93biBjYW5vbmljYWxpemF0aW9uIGlucHV0IGZvcm1hdC4nLFxuICAgICAgICAnanNvbmxkLkNhbm9uaXplRXJyb3InKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYGF3YWl0YCBmb3IgYXN5bmMgcGFyc2Vyc1xuICAgIGNvbnN0IHBhcnNlZElucHV0ID0gTlF1YWRzLnBhcnNlKGlucHV0KTtcblxuICAgIC8vIGRvIGNhbm9uaWNhbGl6YXRpb25cbiAgICByZXR1cm4gY2Fub25pemUuY2Fub25pemUocGFyc2VkSW5wdXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gY29udmVydCB0byBSREYgZGF0YXNldCB0aGVuIGRvIG5vcm1hbGl6YXRpb25cbiAgY29uc3Qgb3B0cyA9IHsuLi5vcHRpb25zfTtcbiAgZGVsZXRlIG9wdHMuZm9ybWF0O1xuICBvcHRzLnByb2R1Y2VHZW5lcmFsaXplZFJkZiA9IGZhbHNlO1xuICBjb25zdCBkYXRhc2V0ID0gYXdhaXQganNvbmxkLnRvUkRGKGlucHV0LCBvcHRzKTtcblxuICAvLyBkbyBjYW5vbmljYWxpemF0aW9uXG4gIHJldHVybiBjYW5vbml6ZS5jYW5vbml6ZShkYXRhc2V0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gUkRGIGRhdGFzZXQgdG8gSlNPTi1MRC5cbiAqXG4gKiBAcGFyYW0gZGF0YXNldCBhIHNlcmlhbGl6ZWQgc3RyaW5nIG9mIFJERiBpbiBhIGZvcm1hdCBzcGVjaWZpZWQgYnkgdGhlXG4gKiAgICAgICAgICBmb3JtYXQgb3B0aW9uIG9yIGFuIFJERiBkYXRhc2V0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtmb3JtYXRdIHRoZSBmb3JtYXQgaWYgZGF0YXNldCBwYXJhbSBtdXN0IGZpcnN0IGJlIHBhcnNlZDpcbiAqICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBOLVF1YWRzIChkZWZhdWx0KS5cbiAqICAgICAgICAgIFtyZGZQYXJzZXJdIGEgY3VzdG9tIFJERi1wYXJzZXIgdG8gdXNlIHRvIHBhcnNlIHRoZSBkYXRhc2V0LlxuICogICAgICAgICAgW3VzZVJkZlR5cGVdIHRydWUgdG8gdXNlIHJkZjp0eXBlLCBmYWxzZSB0byB1c2UgQHR5cGVcbiAqICAgICAgICAgICAgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICAgIFt1c2VOYXRpdmVUeXBlc10gdHJ1ZSB0byBjb252ZXJ0IFhTRCB0eXBlcyBpbnRvIG5hdGl2ZSB0eXBlc1xuICogICAgICAgICAgICAoYm9vbGVhbiwgaW50ZWdlciwgZG91YmxlKSwgZmFsc2Ugbm90IHRvIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgICBbcmRmRGlyZWN0aW9uXSBudWxsIG9yICdpMThuLWRhdGF0eXBlJyB0byBzdXBwb3J0IFJERlxuICogICAgICAgICAgICAgdHJhbnNmb3JtYXRpb24gb2YgQGRpcmVjdGlvbiAoZGVmYXVsdDogbnVsbCkuXG4gKiAgICAgICAgICBbc2FmZV0gdHJ1ZSB0byB1c2Ugc2FmZSBtb2RlLiAoZGVmYXVsdDogZmFsc2UpXG4gKlxuICogQHJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgSlNPTi1MRCBkb2N1bWVudC5cbiAqL1xuanNvbmxkLmZyb21SREYgPSBhc3luYyBmdW5jdGlvbihkYXRhc2V0LCBvcHRpb25zKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgZnJvbSBSREYsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBmb3JtYXQ6IF9pc1N0cmluZyhkYXRhc2V0KSA/ICdhcHBsaWNhdGlvbi9uLXF1YWRzJyA6IHVuZGVmaW5lZFxuICB9KTtcblxuICBjb25zdCB7Zm9ybWF0fSA9IG9wdGlvbnM7XG4gIGxldCB7cmRmUGFyc2VyfSA9IG9wdGlvbnM7XG5cbiAgLy8gaGFuZGxlIHNwZWNpYWwgZm9ybWF0XG4gIGlmKGZvcm1hdCkge1xuICAgIC8vIGNoZWNrIHN1cHBvcnRlZCBmb3JtYXRzXG4gICAgcmRmUGFyc2VyID0gcmRmUGFyc2VyIHx8IF9yZGZQYXJzZXJzW2Zvcm1hdF07XG4gICAgaWYoIXJkZlBhcnNlcikge1xuICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAnVW5rbm93biBpbnB1dCBmb3JtYXQuJyxcbiAgICAgICAgJ2pzb25sZC5Vbmtub3duRm9ybWF0Jywge2Zvcm1hdH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBuby1vcCBwYXJzZXIsIGFzc3VtZSBkYXRhc2V0IGFscmVhZHkgcGFyc2VkXG4gICAgcmRmUGFyc2VyID0gKCkgPT4gZGF0YXNldDtcbiAgfVxuXG4gIC8vIHJkZlBhcnNlciBtdXN0IGJlIHN5bmNocm9ub3VzIG9yIHJldHVybiBhIHByb21pc2UsIG5vIGNhbGxiYWNrIHN1cHBvcnRcbiAgY29uc3QgcGFyc2VkRGF0YXNldCA9IGF3YWl0IHJkZlBhcnNlcihkYXRhc2V0KTtcbiAgcmV0dXJuIF9mcm9tUkRGKHBhcnNlZERhdGFzZXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBPdXRwdXRzIHRoZSBSREYgZGF0YXNldCBmb3VuZCBpbiB0aGUgZ2l2ZW4gSlNPTi1MRCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbYmFzZV0gdGhlIGJhc2UgSVJJIHRvIHVzZS5cbiAqICAgICAgICAgIFtleHBhbmRDb250ZXh0XSBhIGNvbnRleHQgdG8gZXhwYW5kIHdpdGguXG4gKiAgICAgICAgICBbc2tpcEV4cGFuc2lvbl0gdHJ1ZSB0byBhc3N1bWUgdGhlIGlucHV0IGlzIGV4cGFuZGVkIGFuZCBza2lwXG4gKiAgICAgICAgICAgIGV4cGFuc2lvbiwgZmFsc2Ugbm90IHRvLCBkZWZhdWx0cyB0byBmYWxzZS4gU29tZSB3ZWxsLWZvcm1lZFxuICogICAgICAgICAgICBhbmQgc2FmZS1tb2RlIGNoZWNrcyBtYXkgYmUgb21pdHRlZC5cbiAqICAgICAgICAgIFtmb3JtYXRdIHRoZSBmb3JtYXQgdG8gdXNlIHRvIG91dHB1dCBhIHN0cmluZzpcbiAqICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBOLVF1YWRzLlxuICogICAgICAgICAgW3Byb2R1Y2VHZW5lcmFsaXplZFJkZl0gdHJ1ZSB0byBvdXRwdXQgZ2VuZXJhbGl6ZWQgUkRGLCBmYWxzZVxuICogICAgICAgICAgICB0byBwcm9kdWNlIG9ubHkgc3RhbmRhcmQgUkRGIChkZWZhdWx0OiBmYWxzZSkuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtzYWZlXSB0cnVlIHRvIHVzZSBzYWZlIG1vZGUuIChkZWZhdWx0OiBmYWxzZSlcbiAqICAgICAgICAgIFtyZGZEaXJlY3Rpb25dIG51bGwgb3IgJ2kxOG4tZGF0YXR5cGUnIHRvIHN1cHBvcnQgUkRGXG4gKiAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbiBvZiBAZGlyZWN0aW9uIChkZWZhdWx0OiBudWxsKS5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFJERiBkYXRhc2V0LlxuICovXG5qc29ubGQudG9SREYgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHRvIFJERiwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGJhc2U6IF9pc1N0cmluZyhpbnB1dCkgPyBpbnB1dCA6ICcnLFxuICAgIHNraXBFeHBhbnNpb246IGZhbHNlLFxuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gVE9ETzogc3VwcG9ydCB0b1JERiBjdXN0b20gbWFwP1xuICBsZXQgZXhwYW5kZWQ7XG4gIGlmKG9wdGlvbnMuc2tpcEV4cGFuc2lvbikge1xuICAgIGV4cGFuZGVkID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gZXhwYW5kIGlucHV0XG4gICAgZXhwYW5kZWQgPSBhd2FpdCBqc29ubGQuZXhwYW5kKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIG91dHB1dCBSREYgZGF0YXNldFxuICBjb25zdCBkYXRhc2V0ID0gX3RvUkRGKGV4cGFuZGVkLCBvcHRpb25zKTtcbiAgaWYob3B0aW9ucy5mb3JtYXQpIHtcbiAgICBpZihvcHRpb25zLmZvcm1hdCA9PT0gJ2FwcGxpY2F0aW9uL24tcXVhZHMnIHx8XG4gICAgICBvcHRpb25zLmZvcm1hdCA9PT0gJ2FwcGxpY2F0aW9uL25xdWFkcycpIHtcbiAgICAgIHJldHVybiBOUXVhZHMuc2VyaWFsaXplKGRhdGFzZXQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnVW5rbm93biBvdXRwdXQgZm9ybWF0LicsXG4gICAgICAnanNvbmxkLlVua25vd25Gb3JtYXQnLCB7Zm9ybWF0OiBvcHRpb25zLmZvcm1hdH0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGFzZXQ7XG59O1xuXG4vKipcbiAqICoqRXhwZXJpbWVudGFsKipcbiAqXG4gKiBSZWN1cnNpdmVseSBmbGF0dGVucyB0aGUgbm9kZXMgaW4gdGhlIGdpdmVuIEpTT04tTEQgaW5wdXQgaW50byBhIG1lcmdlZFxuICogbWFwIG9mIG5vZGUgSUQgPT4gbm9kZS4gQWxsIGdyYXBocyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSBkZWZhdWx0IGdyYXBoLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBpbnB1dC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2lzc3Vlcl0gYSBqc29ubGQuSWRlbnRpZmllcklzc3VlciB0byB1c2UgdG8gbGFiZWwgYmxhbmsgbm9kZXMuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG1lcmdlZCBub2RlIG1hcC5cbiAqL1xuanNvbmxkLmNyZWF0ZU5vZGVNYXAgPSBhc3luYyBmdW5jdGlvbihpbnB1dCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgbm9kZSBtYXAsIHRvbyBmZXcgYXJndW1lbnRzLicpO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBvcHRpb25zID0gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICBiYXNlOiBfaXNTdHJpbmcoaW5wdXQpID8gaW5wdXQgOiAnJyxcbiAgICBjb250ZXh0UmVzb2x2ZXI6IG5ldyBDb250ZXh0UmVzb2x2ZXIoXG4gICAgICB7c2hhcmVkQ2FjaGU6IF9yZXNvbHZlZENvbnRleHRDYWNoZX0pXG4gIH0pO1xuXG4gIC8vIGV4cGFuZCBpbnB1dFxuICBjb25zdCBleHBhbmRlZCA9IGF3YWl0IGpzb25sZC5leHBhbmQoaW5wdXQsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBfY3JlYXRlTWVyZ2VkTm9kZU1hcChleHBhbmRlZCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqICoqRXhwZXJpbWVudGFsKipcbiAqXG4gKiBNZXJnZXMgdHdvIG9yIG1vcmUgSlNPTi1MRCBkb2N1bWVudHMgaW50byBhIHNpbmdsZSBmbGF0dGVuZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRvY3MgdGhlIEpTT04tTEQgZG9jdW1lbnRzIHRvIG1lcmdlIHRvZ2V0aGVyLlxuICogQHBhcmFtIGN0eCB0aGUgY29udGV4dCB0byB1c2UgdG8gY29tcGFjdCB0aGUgbWVyZ2VkIHJlc3VsdCwgb3IgbnVsbC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2Jhc2VdIHRoZSBiYXNlIElSSSB0byB1c2UuXG4gKiAgICAgICAgICBbZXhwYW5kQ29udGV4dF0gYSBjb250ZXh0IHRvIGV4cGFuZCB3aXRoLlxuICogICAgICAgICAgW2lzc3Vlcl0gYSBqc29ubGQuSWRlbnRpZmllcklzc3VlciB0byB1c2UgdG8gbGFiZWwgYmxhbmsgbm9kZXMuXG4gKiAgICAgICAgICBbbWVyZ2VOb2Rlc10gdHJ1ZSB0byBtZXJnZSBwcm9wZXJ0aWVzIGZvciBub2RlcyB3aXRoIHRoZSBzYW1lIElELFxuICogICAgICAgICAgICBmYWxzZSB0byBpZ25vcmUgbmV3IHByb3BlcnRpZXMgZm9yIG5vZGVzIHdpdGggdGhlIHNhbWUgSUQgb25jZVxuICogICAgICAgICAgICB0aGUgSUQgaGFzIGJlZW4gZGVmaW5lZDsgbm90ZSB0aGF0IHRoaXMgbWF5IG5vdCBwcmV2ZW50IG1lcmdpbmdcbiAqICAgICAgICAgICAgbmV3IHByb3BlcnRpZXMgd2hlcmUgYSBub2RlIGlzIGluIHRoZSBgb2JqZWN0YCBwb3NpdGlvblxuICogICAgICAgICAgICAoZGVmYXVsdDogdHJ1ZSkuXG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXIodXJsLCBvcHRpb25zKV0gdGhlIGRvY3VtZW50IGxvYWRlci5cbiAqICAgICAgICAgIFtzYWZlXSB0cnVlIHRvIHVzZSBzYWZlIG1vZGUuIChkZWZhdWx0OiBmYWxzZSlcbiAqICAgICAgICAgIFtjb250ZXh0UmVzb2x2ZXJdIGludGVybmFsIHVzZSBvbmx5LlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG1lcmdlZCBvdXRwdXQuXG4gKi9cbmpzb25sZC5tZXJnZSA9IGFzeW5jIGZ1bmN0aW9uKGRvY3MsIGN0eCwgb3B0aW9ucykge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBtZXJnZSwgdG9vIGZldyBhcmd1bWVudHMuJyk7XG4gIH1cbiAgaWYoIV9pc0FycmF5KGRvY3MpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IG1lcmdlLCBcImRvY3NcIiBtdXN0IGJlIGFuIGFycmF5LicpO1xuICB9XG5cbiAgaWYodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGN0eCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgY3R4ID0gY3R4IHx8IG51bGw7XG4gIH1cblxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBfc2V0RGVmYXVsdHMob3B0aW9ucywge1xuICAgIGNvbnRleHRSZXNvbHZlcjogbmV3IENvbnRleHRSZXNvbHZlcihcbiAgICAgIHtzaGFyZWRDYWNoZTogX3Jlc29sdmVkQ29udGV4dENhY2hlfSlcbiAgfSk7XG5cbiAgLy8gZXhwYW5kIGFsbCBkb2N1bWVudHNcbiAgY29uc3QgZXhwYW5kZWQgPSBhd2FpdCBQcm9taXNlLmFsbChkb2NzLm1hcChkb2MgPT4ge1xuICAgIGNvbnN0IG9wdHMgPSB7Li4ub3B0aW9uc307XG4gICAgcmV0dXJuIGpzb25sZC5leHBhbmQoZG9jLCBvcHRzKTtcbiAgfSkpO1xuXG4gIGxldCBtZXJnZU5vZGVzID0gdHJ1ZTtcbiAgaWYoJ21lcmdlTm9kZXMnIGluIG9wdGlvbnMpIHtcbiAgICBtZXJnZU5vZGVzID0gb3B0aW9ucy5tZXJnZU5vZGVzO1xuICB9XG5cbiAgY29uc3QgaXNzdWVyID0gb3B0aW9ucy5pc3N1ZXIgfHwgbmV3IElkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICBjb25zdCBncmFwaHMgPSB7J0BkZWZhdWx0Jzoge319O1xuXG4gIGZvcihsZXQgaSA9IDA7IGkgPCBleHBhbmRlZC5sZW5ndGg7ICsraSkge1xuICAgIC8vIHVuaXF1ZWx5IHJlbGFiZWwgYmxhbmsgbm9kZXNcbiAgICBjb25zdCBkb2MgPSB1dGlsLnJlbGFiZWxCbGFua05vZGVzKGV4cGFuZGVkW2ldLCB7XG4gICAgICBpc3N1ZXI6IG5ldyBJZGVudGlmaWVySXNzdWVyKCdfOmInICsgaSArICctJylcbiAgICB9KTtcblxuICAgIC8vIGFkZCBub2RlcyB0byB0aGUgc2hhcmVkIG5vZGUgbWFwIGdyYXBocyBpZiBtZXJnaW5nIG5vZGVzLCB0byBhXG4gICAgLy8gc2VwYXJhdGUgZ3JhcGggc2V0IGlmIG5vdFxuICAgIGNvbnN0IF9ncmFwaHMgPSAobWVyZ2VOb2RlcyB8fCBpID09PSAwKSA/IGdyYXBocyA6IHsnQGRlZmF1bHQnOiB7fX07XG4gICAgX2NyZWF0ZU5vZGVNYXAoZG9jLCBfZ3JhcGhzLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuXG4gICAgaWYoX2dyYXBocyAhPT0gZ3JhcGhzKSB7XG4gICAgICAvLyBtZXJnZSBkb2N1bWVudCBncmFwaHMgYnV0IGRvbid0IG1lcmdlIGV4aXN0aW5nIG5vZGVzXG4gICAgICBmb3IoY29uc3QgZ3JhcGhOYW1lIGluIF9ncmFwaHMpIHtcbiAgICAgICAgY29uc3QgX25vZGVNYXAgPSBfZ3JhcGhzW2dyYXBoTmFtZV07XG4gICAgICAgIGlmKCEoZ3JhcGhOYW1lIGluIGdyYXBocykpIHtcbiAgICAgICAgICBncmFwaHNbZ3JhcGhOYW1lXSA9IF9ub2RlTWFwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaHNbZ3JhcGhOYW1lXTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiBfbm9kZU1hcCkge1xuICAgICAgICAgIGlmKCEoa2V5IGluIG5vZGVNYXApKSB7XG4gICAgICAgICAgICBub2RlTWFwW2tleV0gPSBfbm9kZU1hcFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbGwgbm9uLWRlZmF1bHQgZ3JhcGhzIHRvIGRlZmF1bHQgZ3JhcGhcbiAgY29uc3QgZGVmYXVsdEdyYXBoID0gX21lcmdlTm9kZU1hcHMoZ3JhcGhzKTtcblxuICAvLyBwcm9kdWNlIGZsYXR0ZW5lZCBvdXRwdXRcbiAgY29uc3QgZmxhdHRlbmVkID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0R3JhcGgpLnNvcnQoKTtcbiAgZm9yKGxldCBraSA9IDA7IGtpIDwga2V5cy5sZW5ndGg7ICsra2kpIHtcbiAgICBjb25zdCBub2RlID0gZGVmYXVsdEdyYXBoW2tleXNba2ldXTtcbiAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzIHRvIHRvcC1sZXZlbFxuICAgIGlmKCFfaXNTdWJqZWN0UmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICBmbGF0dGVuZWQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICBpZihjdHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmxhdHRlbmVkO1xuICB9XG5cbiAgLy8gY29tcGFjdCByZXN1bHQgKGZvcmNlIEBncmFwaCBvcHRpb24gdG8gdHJ1ZSwgc2tpcCBleHBhbnNpb24pXG4gIG9wdGlvbnMuZ3JhcGggPSB0cnVlO1xuICBvcHRpb25zLnNraXBFeHBhbnNpb24gPSB0cnVlO1xuICBjb25zdCBjb21wYWN0ZWQgPSBhd2FpdCBqc29ubGQuY29tcGFjdChmbGF0dGVuZWQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgcmV0dXJuIGNvbXBhY3RlZDtcbn07XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZG9jdW1lbnQgbG9hZGVyIGZvciBleHRlcm5hbCBkb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIHVybCB0aGUgVVJMIHRvIGxvYWQuXG4gKlxuICogQHJldHVybiBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVtb3RlIGRvY3VtZW50LlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoanNvbmxkLCAnZG9jdW1lbnRMb2FkZXInLCB7XG4gIGdldDogKCkgPT4ganNvbmxkLl9kb2N1bWVudExvYWRlcixcbiAgc2V0OiB2ID0+IGpzb25sZC5fZG9jdW1lbnRMb2FkZXIgPSB2XG59KTtcbi8vIGRlZmF1bHQgZG9jdW1lbnQgbG9hZGVyIG5vdCBpbXBsZW1lbnRlZFxuanNvbmxkLmRvY3VtZW50TG9hZGVyID0gYXN5bmMgdXJsID0+IHtcbiAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICdDb3VsZCBub3QgcmV0cmlldmUgYSBKU09OLUxEIGRvY3VtZW50IGZyb20gdGhlIFVSTC4gVVJMICcgK1xuICAgICdkZXJlZmVyZW5jaW5nIG5vdCBpbXBsZW1lbnRlZC4nLCAnanNvbmxkLkxvYWREb2N1bWVudEVycm9yJyxcbiAgICB7Y29kZTogJ2xvYWRpbmcgZG9jdW1lbnQgZmFpbGVkJywgdXJsfSk7XG59O1xuXG4vKipcbiAqIEdldHMgYSByZW1vdGUgSlNPTi1MRCBkb2N1bWVudCB1c2luZyB0aGUgZGVmYXVsdCBkb2N1bWVudCBsb2FkZXIgb3JcbiAqIG9uZSBnaXZlbiBpbiB0aGUgcGFzc2VkIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHVybCB0aGUgVVJMIHRvIGZldGNoLlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbZG9jdW1lbnRMb2FkZXJdIHRoZSBkb2N1bWVudCBsb2FkZXIgdG8gdXNlLlxuICpcbiAqIEByZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJldHJpZXZlZCByZW1vdGUgZG9jdW1lbnQuXG4gKi9cbmpzb25sZC5nZXQgPSBhc3luYyBmdW5jdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgbGV0IGxvYWQ7XG4gIGlmKHR5cGVvZiBvcHRpb25zLmRvY3VtZW50TG9hZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbG9hZCA9IG9wdGlvbnMuZG9jdW1lbnRMb2FkZXI7XG4gIH0gZWxzZSB7XG4gICAgbG9hZCA9IGpzb25sZC5kb2N1bWVudExvYWRlcjtcbiAgfVxuXG4gIGNvbnN0IHJlbW90ZURvYyA9IGF3YWl0IGxvYWQodXJsKTtcblxuICB0cnkge1xuICAgIGlmKCFyZW1vdGVEb2MuZG9jdW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBKc29uTGRFcnJvcihcbiAgICAgICAgJ05vIHJlbW90ZSBkb2N1bWVudCBmb3VuZCBhdCB0aGUgZ2l2ZW4gVVJMLicsXG4gICAgICAgICdqc29ubGQuTnVsbFJlbW90ZURvY3VtZW50Jyk7XG4gICAgfVxuICAgIGlmKF9pc1N0cmluZyhyZW1vdGVEb2MuZG9jdW1lbnQpKSB7XG4gICAgICByZW1vdGVEb2MuZG9jdW1lbnQgPSBKU09OLnBhcnNlKHJlbW90ZURvYy5kb2N1bWVudCk7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnQ291bGQgbm90IHJldHJpZXZlIGEgSlNPTi1MRCBkb2N1bWVudCBmcm9tIHRoZSBVUkwuJyxcbiAgICAgICdqc29ubGQuTG9hZERvY3VtZW50RXJyb3InLCB7XG4gICAgICAgIGNvZGU6ICdsb2FkaW5nIGRvY3VtZW50IGZhaWxlZCcsXG4gICAgICAgIGNhdXNlOiBlLFxuICAgICAgICByZW1vdGVEb2NcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlbW90ZURvYztcbn07XG5cbi8qKlxuICogUHJvY2Vzc2VzIGEgbG9jYWwgY29udGV4dCwgcmVzb2x2aW5nIGFueSBVUkxzIGFzIG5lY2Vzc2FyeSwgYW5kIHJldHVybnMgYVxuICogbmV3IGFjdGl2ZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBhY3RpdmVDdHggdGhlIGN1cnJlbnQgYWN0aXZlIGNvbnRleHQuXG4gKiBAcGFyYW0gbG9jYWxDdHggdGhlIGxvY2FsIGNvbnRleHQgdG8gcHJvY2Vzcy5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW2RvY3VtZW50TG9hZGVyKHVybCwgb3B0aW9ucyldIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKiAgICAgICAgICBbc2FmZV0gdHJ1ZSB0byB1c2Ugc2FmZSBtb2RlLiAoZGVmYXVsdDogZmFsc2UpXG4gKiAgICAgICAgICBbY29udGV4dFJlc29sdmVyXSBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgYWN0aXZlIGNvbnRleHQuXG4gKi9cbmpzb25sZC5wcm9jZXNzQ29udGV4dCA9IGFzeW5jIGZ1bmN0aW9uKFxuICBhY3RpdmVDdHgsIGxvY2FsQ3R4LCBvcHRpb25zKSB7XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgb3B0aW9ucyA9IF9zZXREZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgYmFzZTogJycsXG4gICAgY29udGV4dFJlc29sdmVyOiBuZXcgQ29udGV4dFJlc29sdmVyKFxuICAgICAge3NoYXJlZENhY2hlOiBfcmVzb2x2ZWRDb250ZXh0Q2FjaGV9KVxuICB9KTtcblxuICAvLyByZXR1cm4gaW5pdGlhbCBjb250ZXh0IGVhcmx5IGZvciBudWxsIGNvbnRleHRcbiAgaWYobG9jYWxDdHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gX2dldEluaXRpYWxDb250ZXh0KG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gZ2V0IFVSTHMgaW4gbG9jYWxDdHhcbiAgbG9jYWxDdHggPSB1dGlsLmNsb25lKGxvY2FsQ3R4KTtcbiAgaWYoIShfaXNPYmplY3QobG9jYWxDdHgpICYmICdAY29udGV4dCcgaW4gbG9jYWxDdHgpKSB7XG4gICAgbG9jYWxDdHggPSB7J0Bjb250ZXh0JzogbG9jYWxDdHh9O1xuICB9XG5cbiAgcmV0dXJuIF9wcm9jZXNzQ29udGV4dCh7YWN0aXZlQ3R4LCBsb2NhbEN0eCwgb3B0aW9uc30pO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmpzb25sZC5nZXRDb250ZXh0VmFsdWUgPSByZXF1aXJlKCcuL2NvbnRleHQnKS5nZXRDb250ZXh0VmFsdWU7XG5cbi8qKlxuICogRG9jdW1lbnQgbG9hZGVycy5cbiAqL1xuanNvbmxkLmRvY3VtZW50TG9hZGVycyA9IHt9O1xuXG4vKipcbiAqIEFzc2lnbnMgdGhlIGRlZmF1bHQgZG9jdW1lbnQgbG9hZGVyIGZvciBleHRlcm5hbCBkb2N1bWVudCBVUkxzIHRvIGEgYnVpbHQtaW5cbiAqIGRlZmF1bHQuIFN1cHBvcnRlZCB0eXBlcyBjdXJyZW50bHkgaW5jbHVkZTogJ3hocicgYW5kICdub2RlJy5cbiAqXG4gKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSB0byBzZXQuXG4gKiBAcGFyYW0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgcmVxdWlyZWQgdG8gdXNlIHRoZSBkb2N1bWVudCBsb2FkZXIuXG4gKi9cbmpzb25sZC51c2VEb2N1bWVudExvYWRlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYoISh0eXBlIGluIGpzb25sZC5kb2N1bWVudExvYWRlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgJ1Vua25vd24gZG9jdW1lbnQgbG9hZGVyIHR5cGU6IFwiJyArIHR5cGUgKyAnXCInLFxuICAgICAgJ2pzb25sZC5Vbmtub3duRG9jdW1lbnRMb2FkZXInLFxuICAgICAge3R5cGV9KTtcbiAgfVxuXG4gIC8vIHNldCBkb2N1bWVudCBsb2FkZXJcbiAganNvbmxkLmRvY3VtZW50TG9hZGVyID0ganNvbmxkLmRvY3VtZW50TG9hZGVyc1t0eXBlXS5hcHBseShcbiAgICBqc29ubGQsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gUkRGIGRhdGFzZXQgcGFyc2VyIGJ5IGNvbnRlbnQtdHlwZSwgZm9yIHVzZSB3aXRoXG4gKiBqc29ubGQuZnJvbVJERi4gQW4gUkRGIGRhdGFzZXQgcGFyc2VyIHdpbGwgYWx3YXlzIGJlIGdpdmVuIG9uZSBwYXJhbWV0ZXIsXG4gKiBhIHN0cmluZyBvZiBpbnB1dC4gQW4gUkRGIGRhdGFzZXQgcGFyc2VyIGNhbiBiZSBzeW5jaHJvbm91cyBvclxuICogYXN5bmNocm9ub3VzIChieSByZXR1cm5pbmcgYSBwcm9taXNlKS5cbiAqXG4gKiBAcGFyYW0gY29udGVudFR5cGUgdGhlIGNvbnRlbnQtdHlwZSBmb3IgdGhlIHBhcnNlci5cbiAqIEBwYXJhbSBwYXJzZXIoaW5wdXQpIHRoZSBwYXJzZXIgZnVuY3Rpb24gKHRha2VzIGEgc3RyaW5nIGFzIGEgcGFyYW1ldGVyXG4gKiAgICAgICAgICBhbmQgZWl0aGVyIHJldHVybnMgYW4gUkRGIGRhdGFzZXQgb3IgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gb25lLlxuICovXG5qc29ubGQucmVnaXN0ZXJSREZQYXJzZXIgPSBmdW5jdGlvbihjb250ZW50VHlwZSwgcGFyc2VyKSB7XG4gIF9yZGZQYXJzZXJzW2NvbnRlbnRUeXBlXSA9IHBhcnNlcjtcbn07XG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYW4gUkRGIGRhdGFzZXQgcGFyc2VyIGJ5IGNvbnRlbnQtdHlwZS5cbiAqXG4gKiBAcGFyYW0gY29udGVudFR5cGUgdGhlIGNvbnRlbnQtdHlwZSBmb3IgdGhlIHBhcnNlci5cbiAqL1xuanNvbmxkLnVucmVnaXN0ZXJSREZQYXJzZXIgPSBmdW5jdGlvbihjb250ZW50VHlwZSkge1xuICBkZWxldGUgX3JkZlBhcnNlcnNbY29udGVudFR5cGVdO1xufTtcblxuLy8gcmVnaXN0ZXIgdGhlIE4tUXVhZHMgUkRGIHBhcnNlclxuanNvbmxkLnJlZ2lzdGVyUkRGUGFyc2VyKCdhcHBsaWNhdGlvbi9uLXF1YWRzJywgTlF1YWRzLnBhcnNlKTtcbmpzb25sZC5yZWdpc3RlclJERlBhcnNlcignYXBwbGljYXRpb24vbnF1YWRzJywgTlF1YWRzLnBhcnNlKTtcblxuLyogVVJMIEFQSSAqL1xuanNvbmxkLnVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbi8qIEV2ZW50cyBBUEkgYW5kIGhhbmRsZXJzICovXG5qc29ubGQubG9nRXZlbnRIYW5kbGVyID0gX2xvZ0V2ZW50SGFuZGxlcjtcbmpzb25sZC5sb2dXYXJuaW5nRXZlbnRIYW5kbGVyID0gX2xvZ1dhcm5pbmdFdmVudEhhbmRsZXI7XG5qc29ubGQuc2FmZUV2ZW50SGFuZGxlciA9IF9zYWZlRXZlbnRIYW5kbGVyO1xuanNvbmxkLnNldERlZmF1bHRFdmVudEhhbmRsZXIgPSBfc2V0RGVmYXVsdEV2ZW50SGFuZGxlcjtcbmpzb25sZC5zdHJpY3RFdmVudEhhbmRsZXIgPSBfc3RyaWN0RXZlbnRIYW5kbGVyO1xuanNvbmxkLnVuaGFuZGxlZEV2ZW50SGFuZGxlciA9IF91bmhhbmRsZWRFdmVudEhhbmRsZXI7XG5cbi8qIFV0aWxpdHkgQVBJICovXG5qc29ubGQudXRpbCA9IHV0aWw7XG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuT2JqZWN0LmFzc2lnbihqc29ubGQsIHV0aWwpO1xuXG4vLyByZWV4cG9zZSBBUEkgYXMganNvbmxkLnByb21pc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eVxuanNvbmxkLnByb21pc2VzID0ganNvbmxkO1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuanNvbmxkLlJlcXVlc3RRdWV1ZSA9IHJlcXVpcmUoJy4vUmVxdWVzdFF1ZXVlJyk7XG5cbi8qIFdlYklETCBBUEkgKi9cbmpzb25sZC5Kc29uTGRQcm9jZXNzb3IgPSByZXF1aXJlKCcuL0pzb25MZFByb2Nlc3NvcicpKGpzb25sZCk7XG5cbnBsYXRmb3JtLnNldHVwR2xvYmFscyhqc29ubGQpO1xucGxhdGZvcm0uc2V0dXBEb2N1bWVudExvYWRlcnMoanNvbmxkKTtcblxuZnVuY3Rpb24gX3NldERlZmF1bHRzKG9wdGlvbnMsIHtcbiAgZG9jdW1lbnRMb2FkZXIgPSBqc29ubGQuZG9jdW1lbnRMb2FkZXIsXG4gIC4uLmRlZmF1bHRzXG59KSB7XG4gIC8vIGZhaWwgaWYgb2Jzb2xldGUgb3B0aW9ucyBwcmVzZW50XG4gIGlmKG9wdGlvbnMgJiYgJ2NvbXBhY3Rpb25NYXAnIGluIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnXCJjb21wYWN0aW9uTWFwXCIgbm90IHN1cHBvcnRlZC4nLFxuICAgICAgJ2pzb25sZC5PcHRpb25zRXJyb3InKTtcbiAgfVxuICBpZihvcHRpb25zICYmICdleHBhbnNpb25NYXAnIGluIG9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAnXCJleHBhbnNpb25NYXBcIiBub3Qgc3VwcG9ydGVkLicsXG4gICAgICAnanNvbmxkLk9wdGlvbnNFcnJvcicpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIHt9LFxuICAgIHtkb2N1bWVudExvYWRlcn0sXG4gICAgZGVmYXVsdHMsXG4gICAgb3B0aW9ucyxcbiAgICB7ZXZlbnRIYW5kbGVyOiBfc2V0dXBFdmVudEhhbmRsZXIoe29wdGlvbnN9KX1cbiAgKTtcbn1cblxuLy8gZW5kIG9mIGpzb25sZCBBUEkgYHdyYXBwZXJgIGZhY3RvcnlcbnJldHVybiBqc29ubGQ7XG59O1xuXG4vLyBleHRlcm5hbCBBUElzOlxuXG4vLyB1c2VkIHRvIGdlbmVyYXRlIGEgbmV3IGpzb25sZCBBUEkgaW5zdGFuY2VcbmNvbnN0IGZhY3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHdyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkoKTtcbiAgfSk7XG59O1xuXG4vLyB3cmFwIHRoZSBtYWluIGpzb25sZCBBUEkgaW5zdGFuY2VcbndyYXBwZXIoZmFjdG9yeSk7XG4vLyBleHBvcnQgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/jsonld.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/nodeMap.js":
/*!********************************************!*\
  !*** ./node_modules/jsonld/lib/nodeMap.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if(property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9ub2RlTWFwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLE9BQU8sV0FBVyxFQUFFLG1CQUFPLENBQUMsNkRBQVc7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsbUVBQWM7QUFDekMsY0FBYyxtQkFBTyxDQUFDLHlEQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx1REFBUTtBQUM3QixvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBZTs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQTZDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEMsV0FBVyw2Q0FBNkM7QUFDeEQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVcsNkNBQTZDO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVcsNkNBQTZDO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQTZDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNkNBQTZDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9ub2RlTWFwLmpzP2E4ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtpc0tleXdvcmR9ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XG5jb25zdCBncmFwaFR5cGVzID0gcmVxdWlyZSgnLi9ncmFwaFR5cGVzJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtZXJnZWQgSlNPTi1MRCBub2RlIG1hcCAobm9kZSBJRCA9PiBub2RlKS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGV4cGFuZGVkIEpTT04tTEQgdG8gY3JlYXRlIGEgbm9kZSBtYXAgb2YuXG4gKiBAcGFyYW0gW29wdGlvbnNdIHRoZSBvcHRpb25zIHRvIHVzZTpcbiAqICAgICAgICAgIFtpc3N1ZXJdIGEganNvbmxkLklkZW50aWZpZXJJc3N1ZXIgdG8gdXNlIHRvIGxhYmVsIGJsYW5rIG5vZGVzLlxuICpcbiAqIEByZXR1cm4gdGhlIG5vZGUgbWFwLlxuICovXG5hcGkuY3JlYXRlTWVyZ2VkTm9kZU1hcCA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBwcm9kdWNlIGEgbWFwIG9mIGFsbCBzdWJqZWN0cyBhbmQgbmFtZSBlYWNoIGJub2RlXG4gIGNvbnN0IGlzc3VlciA9IG9wdGlvbnMuaXNzdWVyIHx8IG5ldyB1dGlsLklkZW50aWZpZXJJc3N1ZXIoJ186YicpO1xuICBjb25zdCBncmFwaHMgPSB7J0BkZWZhdWx0Jzoge319O1xuICBhcGkuY3JlYXRlTm9kZU1hcChpbnB1dCwgZ3JhcGhzLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuXG4gIC8vIGFkZCBhbGwgbm9uLWRlZmF1bHQgZ3JhcGhzIHRvIGRlZmF1bHQgZ3JhcGhcbiAgcmV0dXJuIGFwaS5tZXJnZU5vZGVNYXBzKGdyYXBocyk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZSBzdWJqZWN0cyBpbiB0aGUgZ2l2ZW4gSlNPTi1MRCBleHBhbmRlZCBpbnB1dFxuICogaW50byBhIG5vZGUgbWFwLlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgSlNPTi1MRCBleHBhbmRlZCBpbnB1dC5cbiAqIEBwYXJhbSBncmFwaHMgYSBtYXAgb2YgZ3JhcGggbmFtZSB0byBzdWJqZWN0IG1hcC5cbiAqIEBwYXJhbSBncmFwaCB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBncmFwaC5cbiAqIEBwYXJhbSBpc3N1ZXIgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpc3N1ZXIuXG4gKiBAcGFyYW0gbmFtZSB0aGUgbmFtZSBhc3NpZ25lZCB0byB0aGUgY3VycmVudCBpbnB1dCBpZiBpdCBpcyBhIGJub2RlLlxuICogQHBhcmFtIGxpc3QgdGhlIGxpc3QgdG8gYXBwZW5kIHRvLCBudWxsIGZvciBub25lLlxuICovXG5hcGkuY3JlYXRlTm9kZU1hcCA9IChpbnB1dCwgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCBuYW1lLCBsaXN0KSA9PiB7XG4gIC8vIHJlY3Vyc2UgdGhyb3VnaCBhcnJheVxuICBpZih0eXBlcy5pc0FycmF5KGlucHV0KSkge1xuICAgIGZvcihjb25zdCBub2RlIG9mIGlucHV0KSB7XG4gICAgICBhcGkuY3JlYXRlTm9kZU1hcChub2RlLCBncmFwaHMsIGdyYXBoLCBpc3N1ZXIsIHVuZGVmaW5lZCwgbGlzdCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFkZCBub24tb2JqZWN0IHRvIGxpc3RcbiAgaWYoIXR5cGVzLmlzT2JqZWN0KGlucHV0KSkge1xuICAgIGlmKGxpc3QpIHtcbiAgICAgIGxpc3QucHVzaChpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFkZCB2YWx1ZXMgdG8gbGlzdFxuICBpZihncmFwaFR5cGVzLmlzVmFsdWUoaW5wdXQpKSB7XG4gICAgaWYoJ0B0eXBlJyBpbiBpbnB1dCkge1xuICAgICAgbGV0IHR5cGUgPSBpbnB1dFsnQHR5cGUnXTtcbiAgICAgIC8vIHJlbmFtZSBAdHlwZSBibGFuayBub2RlXG4gICAgICBpZih0eXBlLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgaW5wdXRbJ0B0eXBlJ10gPSB0eXBlID0gaXNzdWVyLmdldElkKHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihsaXN0KSB7XG4gICAgICBsaXN0LnB1c2goaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZihsaXN0ICYmIGdyYXBoVHlwZXMuaXNMaXN0KGlucHV0KSkge1xuICAgIGNvbnN0IF9saXN0ID0gW107XG4gICAgYXBpLmNyZWF0ZU5vZGVNYXAoaW5wdXRbJ0BsaXN0J10sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgbmFtZSwgX2xpc3QpO1xuICAgIGxpc3QucHVzaCh7J0BsaXN0JzogX2xpc3R9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBOb3RlOiBBdCB0aGlzIHBvaW50LCBpbnB1dCBtdXN0IGJlIGEgc3ViamVjdC5cblxuICAvLyBzcGVjIHJlcXVpcmVzIEB0eXBlIHRvIGJlIG5hbWVkIGZpcnN0LCBzbyBhc3NpZ24gbmFtZXMgZWFybHlcbiAgaWYoJ0B0eXBlJyBpbiBpbnB1dCkge1xuICAgIGNvbnN0IHR5cGVzID0gaW5wdXRbJ0B0eXBlJ107XG4gICAgZm9yKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgIGlmKHR5cGUuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICBpc3N1ZXIuZ2V0SWQodHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IG5hbWUgZm9yIHN1YmplY3RcbiAgaWYodHlwZXMuaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBuYW1lID0gZ3JhcGhUeXBlcy5pc0JsYW5rTm9kZShpbnB1dCkgP1xuICAgICAgaXNzdWVyLmdldElkKGlucHV0WydAaWQnXSkgOiBpbnB1dFsnQGlkJ107XG4gIH1cblxuICAvLyBhZGQgc3ViamVjdCByZWZlcmVuY2UgdG8gbGlzdFxuICBpZihsaXN0KSB7XG4gICAgbGlzdC5wdXNoKHsnQGlkJzogbmFtZX0pO1xuICB9XG5cbiAgLy8gY3JlYXRlIG5ldyBzdWJqZWN0IG9yIG1lcmdlIGludG8gZXhpc3Rpbmcgb25lXG4gIGNvbnN0IHN1YmplY3RzID0gZ3JhcGhzW2dyYXBoXTtcbiAgY29uc3Qgc3ViamVjdCA9IHN1YmplY3RzW25hbWVdID0gc3ViamVjdHNbbmFtZV0gfHwge307XG4gIHN1YmplY3RbJ0BpZCddID0gbmFtZTtcbiAgY29uc3QgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGlucHV0KS5zb3J0KCk7XG4gIGZvcihsZXQgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIC8vIHNraXAgQGlkXG4gICAgaWYocHJvcGVydHkgPT09ICdAaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcmV2ZXJzZSBwcm9wZXJ0aWVzXG4gICAgaWYocHJvcGVydHkgPT09ICdAcmV2ZXJzZScpIHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZWROb2RlID0geydAaWQnOiBuYW1lfTtcbiAgICAgIGNvbnN0IHJldmVyc2VNYXAgPSBpbnB1dFsnQHJldmVyc2UnXTtcbiAgICAgIGZvcihjb25zdCByZXZlcnNlUHJvcGVydHkgaW4gcmV2ZXJzZU1hcCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHJldmVyc2VNYXBbcmV2ZXJzZVByb3BlcnR5XTtcbiAgICAgICAgZm9yKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICBsZXQgaXRlbU5hbWUgPSBpdGVtWydAaWQnXTtcbiAgICAgICAgICBpZihncmFwaFR5cGVzLmlzQmxhbmtOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtTmFtZSA9IGlzc3Vlci5nZXRJZChpdGVtTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKGl0ZW0sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgaXRlbU5hbWUpO1xuICAgICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgICBzdWJqZWN0c1tpdGVtTmFtZV0sIHJldmVyc2VQcm9wZXJ0eSwgcmVmZXJlbmNlZE5vZGUsXG4gICAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSBpbnRvIGdyYXBoXG4gICAgaWYocHJvcGVydHkgPT09ICdAZ3JhcGgnKSB7XG4gICAgICAvLyBhZGQgZ3JhcGggc3ViamVjdHMgbWFwIGVudHJ5XG4gICAgICBpZighKG5hbWUgaW4gZ3JhcGhzKSkge1xuICAgICAgICBncmFwaHNbbmFtZV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKGlucHV0W3Byb3BlcnR5XSwgZ3JhcGhzLCBuYW1lLCBpc3N1ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzZSBpbnRvIGluY2x1ZGVkXG4gICAgaWYocHJvcGVydHkgPT09ICdAaW5jbHVkZWQnKSB7XG4gICAgICBhcGkuY3JlYXRlTm9kZU1hcChpbnB1dFtwcm9wZXJ0eV0sIGdyYXBocywgZ3JhcGgsIGlzc3Vlcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb3B5IG5vbi1AdHlwZSBrZXl3b3Jkc1xuICAgIGlmKHByb3BlcnR5ICE9PSAnQHR5cGUnICYmIGlzS2V5d29yZChwcm9wZXJ0eSkpIHtcbiAgICAgIGlmKHByb3BlcnR5ID09PSAnQGluZGV4JyAmJiBwcm9wZXJ0eSBpbiBzdWJqZWN0ICYmXG4gICAgICAgIChpbnB1dFtwcm9wZXJ0eV0gIT09IHN1YmplY3RbcHJvcGVydHldIHx8XG4gICAgICAgIGlucHV0W3Byb3BlcnR5XVsnQGlkJ10gIT09IHN1YmplY3RbcHJvcGVydHldWydAaWQnXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICAgICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBjb25mbGljdGluZyBAaW5kZXggcHJvcGVydHkgZGV0ZWN0ZWQuJyxcbiAgICAgICAgICAnanNvbmxkLlN5bnRheEVycm9yJyxcbiAgICAgICAgICB7Y29kZTogJ2NvbmZsaWN0aW5nIGluZGV4ZXMnLCBzdWJqZWN0fSk7XG4gICAgICB9XG4gICAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IGlucHV0W3Byb3BlcnR5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBvYmplY3RzXG4gICAgY29uc3Qgb2JqZWN0cyA9IGlucHV0W3Byb3BlcnR5XTtcblxuICAgIC8vIGlmIHByb3BlcnR5IGlzIGEgYm5vZGUsIGFzc2lnbiBpdCBhIG5ldyBpZFxuICAgIGlmKHByb3BlcnR5LmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgIHByb3BlcnR5ID0gaXNzdWVyLmdldElkKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcHJvcGVydHkgaXMgYWRkZWQgZm9yIGVtcHR5IGFycmF5c1xuICAgIGlmKG9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB1dGlsLmFkZFZhbHVlKHN1YmplY3QsIHByb3BlcnR5LCBbXSwge3Byb3BlcnR5SXNBcnJheTogdHJ1ZX0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvcihsZXQgbyBvZiBvYmplY3RzKSB7XG4gICAgICBpZihwcm9wZXJ0eSA9PT0gJ0B0eXBlJykge1xuICAgICAgICAvLyByZW5hbWUgQHR5cGUgYmxhbmsgbm9kZXNcbiAgICAgICAgbyA9IChvLmluZGV4T2YoJ186JykgPT09IDApID8gaXNzdWVyLmdldElkKG8pIDogbztcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIGVtYmVkZGVkIHN1YmplY3Qgb3Igc3ViamVjdCByZWZlcmVuY2VcbiAgICAgIGlmKGdyYXBoVHlwZXMuaXNTdWJqZWN0KG8pIHx8IGdyYXBoVHlwZXMuaXNTdWJqZWN0UmVmZXJlbmNlKG8pKSB7XG4gICAgICAgIC8vIHNraXAgbnVsbCBAaWRcbiAgICAgICAgaWYoJ0BpZCcgaW4gbyAmJiAhb1snQGlkJ10pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbGFiZWwgYmxhbmsgbm9kZSBAaWRcbiAgICAgICAgY29uc3QgaWQgPSBncmFwaFR5cGVzLmlzQmxhbmtOb2RlKG8pID9cbiAgICAgICAgICBpc3N1ZXIuZ2V0SWQob1snQGlkJ10pIDogb1snQGlkJ107XG5cbiAgICAgICAgLy8gYWRkIHJlZmVyZW5jZSBhbmQgcmVjdXJzZVxuICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgIHN1YmplY3QsIHByb3BlcnR5LCB7J0BpZCc6IGlkfSxcbiAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgICAgYXBpLmNyZWF0ZU5vZGVNYXAobywgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCBpZCk7XG4gICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc1ZhbHVlKG8pKSB7XG4gICAgICAgIHV0aWwuYWRkVmFsdWUoXG4gICAgICAgICAgc3ViamVjdCwgcHJvcGVydHksIG8sXG4gICAgICAgICAge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICB9IGVsc2UgaWYoZ3JhcGhUeXBlcy5pc0xpc3QobykpIHtcbiAgICAgICAgLy8gaGFuZGxlIEBsaXN0XG4gICAgICAgIGNvbnN0IF9saXN0ID0gW107XG4gICAgICAgIGFwaS5jcmVhdGVOb2RlTWFwKG9bJ0BsaXN0J10sIGdyYXBocywgZ3JhcGgsIGlzc3VlciwgbmFtZSwgX2xpc3QpO1xuICAgICAgICBvID0geydAbGlzdCc6IF9saXN0fTtcbiAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICBzdWJqZWN0LCBwcm9wZXJ0eSwgbyxcbiAgICAgICAgICB7cHJvcGVydHlJc0FycmF5OiB0cnVlLCBhbGxvd0R1cGxpY2F0ZTogZmFsc2V9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBAdmFsdWVcbiAgICAgICAgYXBpLmNyZWF0ZU5vZGVNYXAobywgZ3JhcGhzLCBncmFwaCwgaXNzdWVyLCBuYW1lKTtcbiAgICAgICAgdXRpbC5hZGRWYWx1ZShcbiAgICAgICAgICBzdWJqZWN0LCBwcm9wZXJ0eSwgbywge3Byb3BlcnR5SXNBcnJheTogdHJ1ZSwgYWxsb3dEdXBsaWNhdGU6IGZhbHNlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1lcmdlIHNlcGFyYXRlIG5hbWVkIGdyYXBocyBpbnRvIGEgc2luZ2xlIG1lcmdlZCBncmFwaCBpbmNsdWRpbmdcbiAqIGFsbCBub2RlcyBmcm9tIHRoZSBkZWZhdWx0IGdyYXBoIGFuZCBuYW1lZCBncmFwaHMuXG4gKlxuICogQHBhcmFtIGdyYXBocyBhIG1hcCBvZiBncmFwaCBuYW1lIHRvIHN1YmplY3QgbWFwLlxuICpcbiAqIEByZXR1cm4gdGhlIG1lcmdlZCBncmFwaCBtYXAuXG4gKi9cbmFwaS5tZXJnZU5vZGVNYXBHcmFwaHMgPSBncmFwaHMgPT4ge1xuICBjb25zdCBtZXJnZWQgPSB7fTtcbiAgZm9yKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZ3JhcGhzKS5zb3J0KCkpIHtcbiAgICBmb3IoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMoZ3JhcGhzW25hbWVdKS5zb3J0KCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBncmFwaHNbbmFtZV1baWRdO1xuICAgICAgaWYoIShpZCBpbiBtZXJnZWQpKSB7XG4gICAgICAgIG1lcmdlZFtpZF0gPSB7J0BpZCc6IGlkfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZE5vZGUgPSBtZXJnZWRbaWRdO1xuXG4gICAgICBmb3IoY29uc3QgcHJvcGVydHkgb2YgT2JqZWN0LmtleXMobm9kZSkuc29ydCgpKSB7XG4gICAgICAgIGlmKGlzS2V5d29yZChwcm9wZXJ0eSkgJiYgcHJvcGVydHkgIT09ICdAdHlwZScpIHtcbiAgICAgICAgICAvLyBjb3B5IGtleXdvcmRzXG4gICAgICAgICAgbWVyZ2VkTm9kZVtwcm9wZXJ0eV0gPSB1dGlsLmNsb25lKG5vZGVbcHJvcGVydHldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtZXJnZSBvYmplY3RzXG4gICAgICAgICAgZm9yKGNvbnN0IHZhbHVlIG9mIG5vZGVbcHJvcGVydHldKSB7XG4gICAgICAgICAgICB1dGlsLmFkZFZhbHVlKFxuICAgICAgICAgICAgICBtZXJnZWROb2RlLCBwcm9wZXJ0eSwgdXRpbC5jbG9uZSh2YWx1ZSksXG4gICAgICAgICAgICAgIHtwcm9wZXJ0eUlzQXJyYXk6IHRydWUsIGFsbG93RHVwbGljYXRlOiBmYWxzZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59O1xuXG5hcGkubWVyZ2VOb2RlTWFwcyA9IGdyYXBocyA9PiB7XG4gIC8vIGFkZCBhbGwgbm9uLWRlZmF1bHQgZ3JhcGhzIHRvIGRlZmF1bHQgZ3JhcGhcbiAgY29uc3QgZGVmYXVsdEdyYXBoID0gZ3JhcGhzWydAZGVmYXVsdCddO1xuICBjb25zdCBncmFwaE5hbWVzID0gT2JqZWN0LmtleXMoZ3JhcGhzKS5zb3J0KCk7XG4gIGZvcihjb25zdCBncmFwaE5hbWUgb2YgZ3JhcGhOYW1lcykge1xuICAgIGlmKGdyYXBoTmFtZSA9PT0gJ0BkZWZhdWx0Jykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVNYXAgPSBncmFwaHNbZ3JhcGhOYW1lXTtcbiAgICBsZXQgc3ViamVjdCA9IGRlZmF1bHRHcmFwaFtncmFwaE5hbWVdO1xuICAgIGlmKCFzdWJqZWN0KSB7XG4gICAgICBkZWZhdWx0R3JhcGhbZ3JhcGhOYW1lXSA9IHN1YmplY3QgPSB7XG4gICAgICAgICdAaWQnOiBncmFwaE5hbWUsXG4gICAgICAgICdAZ3JhcGgnOiBbXVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYoISgnQGdyYXBoJyBpbiBzdWJqZWN0KSkge1xuICAgICAgc3ViamVjdFsnQGdyYXBoJ10gPSBbXTtcbiAgICB9XG4gICAgY29uc3QgZ3JhcGggPSBzdWJqZWN0WydAZ3JhcGgnXTtcbiAgICBmb3IoY29uc3QgaWQgb2YgT2JqZWN0LmtleXMobm9kZU1hcCkuc29ydCgpKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcFtpZF07XG4gICAgICAvLyBvbmx5IGFkZCBmdWxsIHN1YmplY3RzXG4gICAgICBpZighZ3JhcGhUeXBlcy5pc1N1YmplY3RSZWZlcmVuY2Uobm9kZSkpIHtcbiAgICAgICAgZ3JhcGgucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRHcmFwaDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/nodeMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/platform.js":
/*!*********************************************!*\
  !*** ./node_modules/jsonld/lib/platform.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst nodeLoader = __webpack_require__(/*! ./documentLoaders/node */ \"(ssr)/./node_modules/jsonld/lib/documentLoaders/node.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Setup Node.js document loaders.\n *\n * @param jsonld the jsonld api.\n */\napi.setupDocumentLoaders = function(jsonld) {\n  jsonld.documentLoaders.node = nodeLoader;\n  // use node document loader by default\n  jsonld.useDocumentLoader('node');\n};\n\n/**\n * Setup Node.js globals.\n *\n * @param jsonld the jsonld api.\n */\n/* eslint-disable-next-line no-unused-vars */\napi.setupGlobals = function(jsonld) {\n  // none for Node.js\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi9wbGF0Zm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBd0I7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC9saWIvcGxhdGZvcm0uanM/MTYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgbm9kZUxvYWRlciA9IHJlcXVpcmUoJy4vZG9jdW1lbnRMb2FkZXJzL25vZGUnKTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcblxuLyoqXG4gKiBTZXR1cCBOb2RlLmpzIGRvY3VtZW50IGxvYWRlcnMuXG4gKlxuICogQHBhcmFtIGpzb25sZCB0aGUganNvbmxkIGFwaS5cbiAqL1xuYXBpLnNldHVwRG9jdW1lbnRMb2FkZXJzID0gZnVuY3Rpb24oanNvbmxkKSB7XG4gIGpzb25sZC5kb2N1bWVudExvYWRlcnMubm9kZSA9IG5vZGVMb2FkZXI7XG4gIC8vIHVzZSBub2RlIGRvY3VtZW50IGxvYWRlciBieSBkZWZhdWx0XG4gIGpzb25sZC51c2VEb2N1bWVudExvYWRlcignbm9kZScpO1xufTtcblxuLyoqXG4gKiBTZXR1cCBOb2RlLmpzIGdsb2JhbHMuXG4gKlxuICogQHBhcmFtIGpzb25sZCB0aGUganNvbmxkIGFwaS5cbiAqL1xuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzICovXG5hcGkuc2V0dXBHbG9iYWxzID0gZnVuY3Rpb24oanNvbmxkKSB7XG4gIC8vIG5vbmUgZm9yIE5vZGUuanNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/platform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/toRdf.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/toRdf.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {createNodeMap} = __webpack_require__(/*! ./nodeMap */ \"(ssr)/./node_modules/jsonld/lib/nodeMap.js\");\nconst {isKeyword} = __webpack_require__(/*! ./context */ \"(ssr)/./node_modules/jsonld/lib/context.js\");\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\nconst jsonCanonicalize = __webpack_require__(/*! canonicalize */ \"(ssr)/./node_modules/canonicalize/lib/canonicalize.js\");\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\nconst util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/jsonld/lib/util.js\");\n\nconst {\n  handleEvent: _handleEvent\n} = __webpack_require__(/*! ./events */ \"(ssr)/./node_modules/jsonld/lib/events.js\");\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/jsonld/lib/constants.js\");\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = __webpack_require__(/*! ./url */ \"(ssr)/./node_modules/jsonld/lib/url.js\");\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      if(options.eventHandler) {\n        _handleEvent({\n          event: {\n            type: ['JsonLdEvent'],\n            code: 'relative graph reference',\n            level: 'warning',\n            message: 'Relative graph reference found.',\n            details: {\n              graph: graphName\n            }\n          },\n          options\n        });\n      }\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative subject reference',\n                level: 'warning',\n                message: 'Relative subject reference found.',\n                details: {\n                  subject: id\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'relative predicate reference',\n                level: 'warning',\n                message: 'Relative predicate reference found.',\n                details: {\n                  predicate: property\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          if(options.eventHandler) {\n            _handleEvent({\n              event: {\n                type: ['JsonLdEvent'],\n                code: 'blank node predicate',\n                level: 'warning',\n                message: 'Dropping blank node predicate.',\n                details: {\n                  // FIXME: add better issuer API to get reverse mapping\n                  property: issuer.getOldIds()\n                    .find(key => issuer.getId(key) === property)\n                }\n              },\n              options\n            });\n          }\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object = _objectToRDF(\n          item, issuer, dataset, graphTerm, options.rdfDirection, options);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection, options) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(\n      item, issuer, dataset, graphTerm, rdfDirection, options);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(\n      last, issuer, dataset, graphTerm, rdfDirection, options);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n * @param options the RDF serialization options.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(\n  item, issuer, dataset, graphTerm, rdfDirection, options\n) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if('@direction' in item && rdfDirection === 'i18n-datatype') {\n      const language = (item['@language'] || '').toLowerCase();\n      const direction = item['@direction'];\n      const datatype = `https://www.w3.org/ns/i18n#${language}_${direction}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@direction' in item && rdfDirection === 'compound-literal') {\n      throw new JsonLdError(\n        'Unsupported rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    } else if('@direction' in item && rdfDirection) {\n      throw new JsonLdError(\n        'Unknown rdfDirection value.',\n        'jsonld.InvalidRdfDirection',\n        {value: rdfDirection});\n    } else if('@language' in item) {\n      if('@direction' in item && !rdfDirection) {\n        if(options.eventHandler) {\n          // FIXME: only emit once?\n          _handleEvent({\n            event: {\n              type: ['JsonLdEvent'],\n              code: 'rdfDirection not set',\n              level: 'warning',\n              message: 'rdfDirection not set for @direction.',\n              details: {\n                object: object.value\n              }\n            },\n            options\n          });\n        }\n      }\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      if('@direction' in item && !rdfDirection) {\n        if(options.eventHandler) {\n          // FIXME: only emit once?\n          _handleEvent({\n            event: {\n              type: ['JsonLdEvent'],\n              code: 'rdfDirection not set',\n              level: 'warning',\n              message: 'rdfDirection not set for @direction.',\n              details: {\n                object: object.value\n              }\n            },\n            options\n          });\n        }\n      }\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list = _listToRDF(\n      item['@list'], issuer, dataset, graphTerm, rdfDirection, options);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    if(options.eventHandler) {\n      _handleEvent({\n        event: {\n          type: ['JsonLdEvent'],\n          code: 'relative object reference',\n          level: 'warning',\n          message: 'Relative object reference found.',\n          details: {\n            object: object.value\n          }\n        },\n        options\n      });\n    }\n    return null;\n  }\n\n  return object;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi90b1JkZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixPQUFPLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDZEQUFXO0FBQzNDLE9BQU8sV0FBVyxFQUFFLG1CQUFPLENBQUMsNkRBQVc7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsbUVBQWM7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsMkVBQWM7QUFDL0Msb0JBQW9CLG1CQUFPLENBQUMscUVBQWU7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLHlEQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx1REFBUTs7QUFFN0I7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJEQUFVOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFhOztBQUV6QjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscURBQU87O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBLHFCQUFxQjtBQUNyQixRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGVBQWU7O0FBRWY7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBOEM7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFEQUFxRCxTQUFTLEdBQUcsVUFBVTtBQUMzRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi90b1JkZi5qcz9hOTg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAyMyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtjcmVhdGVOb2RlTWFwfSA9IHJlcXVpcmUoJy4vbm9kZU1hcCcpO1xuY29uc3Qge2lzS2V5d29yZH0gPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcbmNvbnN0IGdyYXBoVHlwZXMgPSByZXF1aXJlKCcuL2dyYXBoVHlwZXMnKTtcbmNvbnN0IGpzb25DYW5vbmljYWxpemUgPSByZXF1aXJlKCdjYW5vbmljYWxpemUnKTtcbmNvbnN0IEpzb25MZEVycm9yID0gcmVxdWlyZSgnLi9Kc29uTGRFcnJvcicpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmNvbnN0IHtcbiAgaGFuZGxlRXZlbnQ6IF9oYW5kbGVFdmVudFxufSA9IHJlcXVpcmUoJy4vZXZlbnRzJyk7XG5cbmNvbnN0IHtcbiAgLy8gUkRGLFxuICAvLyBSREZfTElTVCxcbiAgUkRGX0ZJUlNULFxuICBSREZfUkVTVCxcbiAgUkRGX05JTCxcbiAgUkRGX1RZUEUsXG4gIC8vIFJERl9QTEFJTl9MSVRFUkFMLFxuICAvLyBSREZfWE1MX0xJVEVSQUwsXG4gIFJERl9KU09OX0xJVEVSQUwsXG4gIC8vIFJERl9PQkpFQ1QsXG4gIFJERl9MQU5HU1RSSU5HLFxuXG4gIC8vIFhTRCxcbiAgWFNEX0JPT0xFQU4sXG4gIFhTRF9ET1VCTEUsXG4gIFhTRF9JTlRFR0VSLFxuICBYU0RfU1RSSU5HLFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IHtcbiAgaXNBYnNvbHV0ZTogX2lzQWJzb2x1dGVJcmlcbn0gPSByZXF1aXJlKCcuL3VybCcpO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIE91dHB1dHMgYW4gUkRGIGRhdGFzZXQgZm9yIHRoZSBleHBhbmRlZCBKU09OLUxEIGlucHV0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCB0aGUgZXhwYW5kZWQgSlNPTi1MRCBpbnB1dC5cbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBSREYgc2VyaWFsaXphdGlvbiBvcHRpb25zLlxuICpcbiAqIEByZXR1cm4gdGhlIFJERiBkYXRhc2V0LlxuICovXG5hcGkudG9SREYgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcbiAgLy8gY3JlYXRlIG5vZGUgbWFwIGZvciBkZWZhdWx0IGdyYXBoIChhbmQgYW55IG5hbWVkIGdyYXBocylcbiAgY29uc3QgaXNzdWVyID0gbmV3IHV0aWwuSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG4gIGNvbnN0IG5vZGVNYXAgPSB7J0BkZWZhdWx0Jzoge319O1xuICBjcmVhdGVOb2RlTWFwKGlucHV0LCBub2RlTWFwLCAnQGRlZmF1bHQnLCBpc3N1ZXIpO1xuXG4gIGNvbnN0IGRhdGFzZXQgPSBbXTtcbiAgY29uc3QgZ3JhcGhOYW1lcyA9IE9iamVjdC5rZXlzKG5vZGVNYXApLnNvcnQoKTtcbiAgZm9yKGNvbnN0IGdyYXBoTmFtZSBvZiBncmFwaE5hbWVzKSB7XG4gICAgbGV0IGdyYXBoVGVybTtcbiAgICBpZihncmFwaE5hbWUgPT09ICdAZGVmYXVsdCcpIHtcbiAgICAgIGdyYXBoVGVybSA9IHt0ZXJtVHlwZTogJ0RlZmF1bHRHcmFwaCcsIHZhbHVlOiAnJ307XG4gICAgfSBlbHNlIGlmKF9pc0Fic29sdXRlSXJpKGdyYXBoTmFtZSkpIHtcbiAgICAgIGlmKGdyYXBoTmFtZS5zdGFydHNXaXRoKCdfOicpKSB7XG4gICAgICAgIGdyYXBoVGVybSA9IHt0ZXJtVHlwZTogJ0JsYW5rTm9kZSd9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JhcGhUZXJtID0ge3Rlcm1UeXBlOiAnTmFtZWROb2RlJ307XG4gICAgICB9XG4gICAgICBncmFwaFRlcm0udmFsdWUgPSBncmFwaE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNraXAgcmVsYXRpdmUgSVJJcyAobm90IHZhbGlkIFJERilcbiAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgICAgZXZlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgIGNvZGU6ICdyZWxhdGl2ZSBncmFwaCByZWZlcmVuY2UnLFxuICAgICAgICAgICAgbGV2ZWw6ICd3YXJuaW5nJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWxhdGl2ZSBncmFwaCByZWZlcmVuY2UgZm91bmQuJyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgZ3JhcGg6IGdyYXBoTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfZ3JhcGhUb1JERihkYXRhc2V0LCBub2RlTWFwW2dyYXBoTmFtZV0sIGdyYXBoVGVybSwgaXNzdWVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhc2V0O1xufTtcblxuLyoqXG4gKiBBZGRzIFJERiBxdWFkcyBmb3IgYSBwYXJ0aWN1bGFyIGdyYXBoIHRvIHRoZSBnaXZlbiBkYXRhc2V0LlxuICpcbiAqIEBwYXJhbSBkYXRhc2V0IHRoZSBkYXRhc2V0IHRvIGFwcGVuZCBSREYgcXVhZHMgdG8uXG4gKiBAcGFyYW0gZ3JhcGggdGhlIGdyYXBoIHRvIGNyZWF0ZSBSREYgcXVhZHMgZm9yLlxuICogQHBhcmFtIGdyYXBoVGVybSB0aGUgZ3JhcGggdGVybSBmb3IgZWFjaCBxdWFkLlxuICogQHBhcmFtIGlzc3VlciBhIElkZW50aWZpZXJJc3N1ZXIgZm9yIGFzc2lnbmluZyBibGFuayBub2RlIG5hbWVzLlxuICogQHBhcmFtIG9wdGlvbnMgdGhlIFJERiBzZXJpYWxpemF0aW9uIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB0aGUgYXJyYXkgb2YgUkRGIHRyaXBsZXMgZm9yIHRoZSBnaXZlbiBncmFwaC5cbiAqL1xuZnVuY3Rpb24gX2dyYXBoVG9SREYoZGF0YXNldCwgZ3JhcGgsIGdyYXBoVGVybSwgaXNzdWVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGdyYXBoKS5zb3J0KCk7XG4gIGZvcihjb25zdCBpZCBvZiBpZHMpIHtcbiAgICBjb25zdCBub2RlID0gZ3JhcGhbaWRdO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhub2RlKS5zb3J0KCk7XG4gICAgZm9yKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBpdGVtcyA9IG5vZGVbcHJvcGVydHldO1xuICAgICAgaWYocHJvcGVydHkgPT09ICdAdHlwZScpIHtcbiAgICAgICAgcHJvcGVydHkgPSBSREZfVFlQRTtcbiAgICAgIH0gZWxzZSBpZihpc0tleXdvcmQocHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAvLyBSREYgc3ViamVjdFxuICAgICAgICBjb25zdCBzdWJqZWN0ID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiBpZC5zdGFydHNXaXRoKCdfOicpID8gJ0JsYW5rTm9kZScgOiAnTmFtZWROb2RlJyxcbiAgICAgICAgICB2YWx1ZTogaWRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBza2lwIHJlbGF0aXZlIElSSSBzdWJqZWN0cyAobm90IHZhbGlkIFJERilcbiAgICAgICAgaWYoIV9pc0Fic29sdXRlSXJpKGlkKSkge1xuICAgICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgICAgICBjb2RlOiAncmVsYXRpdmUgc3ViamVjdCByZWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlbGF0aXZlIHN1YmplY3QgcmVmZXJlbmNlIGZvdW5kLicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgc3ViamVjdDogaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJERiBwcmVkaWNhdGVcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiBwcm9wZXJ0eS5zdGFydHNXaXRoKCdfOicpID8gJ0JsYW5rTm9kZScgOiAnTmFtZWROb2RlJyxcbiAgICAgICAgICB2YWx1ZTogcHJvcGVydHlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBza2lwIHJlbGF0aXZlIElSSSBwcmVkaWNhdGVzIChub3QgdmFsaWQgUkRGKVxuICAgICAgICBpZighX2lzQWJzb2x1dGVJcmkocHJvcGVydHkpKSB7XG4gICAgICAgICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdyZWxhdGl2ZSBwcmVkaWNhdGUgcmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWxhdGl2ZSBwcmVkaWNhdGUgcmVmZXJlbmNlIGZvdW5kLicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgcHJlZGljYXRlOiBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2tpcCBibGFuayBub2RlIHByZWRpY2F0ZXMgdW5sZXNzIHByb2R1Y2luZyBnZW5lcmFsaXplZCBSREZcbiAgICAgICAgaWYocHJlZGljYXRlLnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJlxuICAgICAgICAgICFvcHRpb25zLnByb2R1Y2VHZW5lcmFsaXplZFJkZikge1xuICAgICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBfaGFuZGxlRXZlbnQoe1xuICAgICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFsnSnNvbkxkRXZlbnQnXSxcbiAgICAgICAgICAgICAgICBjb2RlOiAnYmxhbmsgbm9kZSBwcmVkaWNhdGUnLFxuICAgICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Ryb3BwaW5nIGJsYW5rIG5vZGUgcHJlZGljYXRlLicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IGFkZCBiZXR0ZXIgaXNzdWVyIEFQSSB0byBnZXQgcmV2ZXJzZSBtYXBwaW5nXG4gICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogaXNzdWVyLmdldE9sZElkcygpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKGtleSA9PiBpc3N1ZXIuZ2V0SWQoa2V5KSA9PT0gcHJvcGVydHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IGxpc3QsIHZhbHVlIG9yIG5vZGUgb2JqZWN0IHRvIHRyaXBsZVxuICAgICAgICBjb25zdCBvYmplY3QgPSBfb2JqZWN0VG9SREYoXG4gICAgICAgICAgaXRlbSwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIG9wdGlvbnMucmRmRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgLy8gc2tpcCBudWxsIG9iamVjdHMgKHRoZXkgYXJlIHJlbGF0aXZlIElSSXMpXG4gICAgICAgIGlmKG9iamVjdCkge1xuICAgICAgICAgIGRhdGFzZXQucHVzaCh7XG4gICAgICAgICAgICBzdWJqZWN0LFxuICAgICAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBAbGlzdCB2YWx1ZSBpbnRvIGxpbmtlZCBsaXN0IG9mIGJsYW5rIG5vZGUgUkRGIHF1YWRzXG4gKiAoYW4gUkRGIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBsaXN0IHRoZSBAbGlzdCB2YWx1ZS5cbiAqIEBwYXJhbSBpc3N1ZXIgYSBJZGVudGlmaWVySXNzdWVyIGZvciBhc3NpZ25pbmcgYmxhbmsgbm9kZSBuYW1lcy5cbiAqIEBwYXJhbSBkYXRhc2V0IHRoZSBhcnJheSBvZiBxdWFkcyB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0gZ3JhcGhUZXJtIHRoZSBncmFwaCB0ZXJtIGZvciBlYWNoIHF1YWQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgUkRGIHNlcmlhbGl6YXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICovXG5mdW5jdGlvbiBfbGlzdFRvUkRGKGxpc3QsIGlzc3VlciwgZGF0YXNldCwgZ3JhcGhUZXJtLCByZGZEaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgZmlyc3QgPSB7dGVybVR5cGU6ICdOYW1lZE5vZGUnLCB2YWx1ZTogUkRGX0ZJUlNUfTtcbiAgY29uc3QgcmVzdCA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBSREZfUkVTVH07XG4gIGNvbnN0IG5pbCA9IHt0ZXJtVHlwZTogJ05hbWVkTm9kZScsIHZhbHVlOiBSREZfTklMfTtcblxuICBjb25zdCBsYXN0ID0gbGlzdC5wb3AoKTtcbiAgLy8gUmVzdWx0IGlzIHRoZSBoZWFkIG9mIHRoZSBsaXN0XG4gIGNvbnN0IHJlc3VsdCA9IGxhc3QgPyB7dGVybVR5cGU6ICdCbGFua05vZGUnLCB2YWx1ZTogaXNzdWVyLmdldElkKCl9IDogbmlsO1xuICBsZXQgc3ViamVjdCA9IHJlc3VsdDtcblxuICBmb3IoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gX29iamVjdFRvUkRGKFxuICAgICAgaXRlbSwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIHJkZkRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3QgbmV4dCA9IHt0ZXJtVHlwZTogJ0JsYW5rTm9kZScsIHZhbHVlOiBpc3N1ZXIuZ2V0SWQoKX07XG4gICAgZGF0YXNldC5wdXNoKHtcbiAgICAgIHN1YmplY3QsXG4gICAgICBwcmVkaWNhdGU6IGZpcnN0LFxuICAgICAgb2JqZWN0LFxuICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgIH0pO1xuICAgIGRhdGFzZXQucHVzaCh7XG4gICAgICBzdWJqZWN0LFxuICAgICAgcHJlZGljYXRlOiByZXN0LFxuICAgICAgb2JqZWN0OiBuZXh0LFxuICAgICAgZ3JhcGg6IGdyYXBoVGVybVxuICAgIH0pO1xuICAgIHN1YmplY3QgPSBuZXh0O1xuICB9XG5cbiAgLy8gVGFpbCBvZiBsaXN0XG4gIGlmKGxhc3QpIHtcbiAgICBjb25zdCBvYmplY3QgPSBfb2JqZWN0VG9SREYoXG4gICAgICBsYXN0LCBpc3N1ZXIsIGRhdGFzZXQsIGdyYXBoVGVybSwgcmRmRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICBkYXRhc2V0LnB1c2goe1xuICAgICAgc3ViamVjdCxcbiAgICAgIHByZWRpY2F0ZTogZmlyc3QsXG4gICAgICBvYmplY3QsXG4gICAgICBncmFwaDogZ3JhcGhUZXJtXG4gICAgfSk7XG4gICAgZGF0YXNldC5wdXNoKHtcbiAgICAgIHN1YmplY3QsXG4gICAgICBwcmVkaWNhdGU6IHJlc3QsXG4gICAgICBvYmplY3Q6IG5pbCxcbiAgICAgIGdyYXBoOiBncmFwaFRlcm1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBKU09OLUxEIHZhbHVlIG9iamVjdCB0byBhbiBSREYgbGl0ZXJhbCBvciBhIEpTT04tTEQgc3RyaW5nLFxuICogbm9kZSBvYmplY3QgdG8gYW4gUkRGIHJlc291cmNlLCBvciBhZGRzIGEgbGlzdC5cbiAqXG4gKiBAcGFyYW0gaXRlbSB0aGUgSlNPTi1MRCB2YWx1ZSBvciBub2RlIG9iamVjdC5cbiAqIEBwYXJhbSBpc3N1ZXIgYSBJZGVudGlmaWVySXNzdWVyIGZvciBhc3NpZ25pbmcgYmxhbmsgbm9kZSBuYW1lcy5cbiAqIEBwYXJhbSBkYXRhc2V0IHRoZSBkYXRhc2V0IHRvIGFwcGVuZCBSREYgcXVhZHMgdG8uXG4gKiBAcGFyYW0gZ3JhcGhUZXJtIHRoZSBncmFwaCB0ZXJtIGZvciBlYWNoIHF1YWQuXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgUkRGIHNlcmlhbGl6YXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHRoZSBSREYgbGl0ZXJhbCBvciBSREYgcmVzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIF9vYmplY3RUb1JERihcbiAgaXRlbSwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIHJkZkRpcmVjdGlvbiwgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IG9iamVjdCA9IHt9O1xuXG4gIC8vIGNvbnZlcnQgdmFsdWUgb2JqZWN0IHRvIFJERlxuICBpZihncmFwaFR5cGVzLmlzVmFsdWUoaXRlbSkpIHtcbiAgICBvYmplY3QudGVybVR5cGUgPSAnTGl0ZXJhbCc7XG4gICAgb2JqZWN0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgIG9iamVjdC5kYXRhdHlwZSA9IHtcbiAgICAgIHRlcm1UeXBlOiAnTmFtZWROb2RlJ1xuICAgIH07XG4gICAgbGV0IHZhbHVlID0gaXRlbVsnQHZhbHVlJ107XG4gICAgY29uc3QgZGF0YXR5cGUgPSBpdGVtWydAdHlwZSddIHx8IG51bGw7XG5cbiAgICAvLyBjb252ZXJ0IHRvIFhTRC9KU09OIGRhdGF0eXBlcyBhcyBhcHByb3ByaWF0ZVxuICAgIGlmKGRhdGF0eXBlID09PSAnQGpzb24nKSB7XG4gICAgICBvYmplY3QudmFsdWUgPSBqc29uQ2Fub25pY2FsaXplKHZhbHVlKTtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IFJERl9KU09OX0xJVEVSQUw7XG4gICAgfSBlbHNlIGlmKHR5cGVzLmlzQm9vbGVhbih2YWx1ZSkpIHtcbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfQk9PTEVBTjtcbiAgICB9IGVsc2UgaWYodHlwZXMuaXNEb3VibGUodmFsdWUpIHx8IGRhdGF0eXBlID09PSBYU0RfRE9VQkxFKSB7XG4gICAgICBpZighdHlwZXMuaXNEb3VibGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBjYW5vbmljYWwgZG91YmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICBvYmplY3QudmFsdWUgPSB2YWx1ZS50b0V4cG9uZW50aWFsKDE1KS5yZXBsYWNlKC8oXFxkKTAqZVxcKz8vLCAnJDFFJyk7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfRE9VQkxFO1xuICAgIH0gZWxzZSBpZih0eXBlcy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIG9iamVjdC52YWx1ZSA9IHZhbHVlLnRvRml4ZWQoMCk7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfSU5URUdFUjtcbiAgICB9IGVsc2UgaWYoJ0BkaXJlY3Rpb24nIGluIGl0ZW0gJiYgcmRmRGlyZWN0aW9uID09PSAnaTE4bi1kYXRhdHlwZScpIHtcbiAgICAgIGNvbnN0IGxhbmd1YWdlID0gKGl0ZW1bJ0BsYW5ndWFnZSddIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gaXRlbVsnQGRpcmVjdGlvbiddO1xuICAgICAgY29uc3QgZGF0YXR5cGUgPSBgaHR0cHM6Ly93d3cudzMub3JnL25zL2kxOG4jJHtsYW5ndWFnZX1fJHtkaXJlY3Rpb259YDtcbiAgICAgIG9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IGRhdGF0eXBlO1xuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmKCdAZGlyZWN0aW9uJyBpbiBpdGVtICYmIHJkZkRpcmVjdGlvbiA9PT0gJ2NvbXBvdW5kLWxpdGVyYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVbnN1cHBvcnRlZCByZGZEaXJlY3Rpb24gdmFsdWUuJyxcbiAgICAgICAgJ2pzb25sZC5JbnZhbGlkUmRmRGlyZWN0aW9uJyxcbiAgICAgICAge3ZhbHVlOiByZGZEaXJlY3Rpb259KTtcbiAgICB9IGVsc2UgaWYoJ0BkaXJlY3Rpb24nIGluIGl0ZW0gJiYgcmRmRGlyZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSnNvbkxkRXJyb3IoXG4gICAgICAgICdVbmtub3duIHJkZkRpcmVjdGlvbiB2YWx1ZS4nLFxuICAgICAgICAnanNvbmxkLkludmFsaWRSZGZEaXJlY3Rpb24nLFxuICAgICAgICB7dmFsdWU6IHJkZkRpcmVjdGlvbn0pO1xuICAgIH0gZWxzZSBpZignQGxhbmd1YWdlJyBpbiBpdGVtKSB7XG4gICAgICBpZignQGRpcmVjdGlvbicgaW4gaXRlbSAmJiAhcmRmRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgLy8gRklYTUU6IG9ubHkgZW1pdCBvbmNlP1xuICAgICAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICAgIGNvZGU6ICdyZGZEaXJlY3Rpb24gbm90IHNldCcsXG4gICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdyZGZEaXJlY3Rpb24gbm90IHNldCBmb3IgQGRpcmVjdGlvbi4nLFxuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBSREZfTEFOR1NUUklORztcbiAgICAgIG9iamVjdC5sYW5ndWFnZSA9IGl0ZW1bJ0BsYW5ndWFnZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZignQGRpcmVjdGlvbicgaW4gaXRlbSAmJiAhcmRmRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmKG9wdGlvbnMuZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgLy8gRklYTUU6IG9ubHkgZW1pdCBvbmNlP1xuICAgICAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgICAgICBldmVudDoge1xuICAgICAgICAgICAgICB0eXBlOiBbJ0pzb25MZEV2ZW50J10sXG4gICAgICAgICAgICAgIGNvZGU6ICdyZGZEaXJlY3Rpb24gbm90IHNldCcsXG4gICAgICAgICAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdyZGZEaXJlY3Rpb24gbm90IHNldCBmb3IgQGRpcmVjdGlvbi4nLFxuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0LnZhbHVlID0gdmFsdWU7XG4gICAgICBvYmplY3QuZGF0YXR5cGUudmFsdWUgPSBkYXRhdHlwZSB8fCBYU0RfU1RSSU5HO1xuICAgIH1cbiAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNMaXN0KGl0ZW0pKSB7XG4gICAgY29uc3QgX2xpc3QgPSBfbGlzdFRvUkRGKFxuICAgICAgaXRlbVsnQGxpc3QnXSwgaXNzdWVyLCBkYXRhc2V0LCBncmFwaFRlcm0sIHJkZkRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgb2JqZWN0LnRlcm1UeXBlID0gX2xpc3QudGVybVR5cGU7XG4gICAgb2JqZWN0LnZhbHVlID0gX2xpc3QudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gY29udmVydCBzdHJpbmcvbm9kZSBvYmplY3QgdG8gUkRGXG4gICAgY29uc3QgaWQgPSB0eXBlcy5pc09iamVjdChpdGVtKSA/IGl0ZW1bJ0BpZCddIDogaXRlbTtcbiAgICBvYmplY3QudGVybVR5cGUgPSBpZC5zdGFydHNXaXRoKCdfOicpID8gJ0JsYW5rTm9kZScgOiAnTmFtZWROb2RlJztcbiAgICBvYmplY3QudmFsdWUgPSBpZDtcbiAgfVxuXG4gIC8vIHNraXAgcmVsYXRpdmUgSVJJcywgbm90IHZhbGlkIFJERlxuICBpZihvYmplY3QudGVybVR5cGUgPT09ICdOYW1lZE5vZGUnICYmICFfaXNBYnNvbHV0ZUlyaShvYmplY3QudmFsdWUpKSB7XG4gICAgaWYob3B0aW9ucy5ldmVudEhhbmRsZXIpIHtcbiAgICAgIF9oYW5kbGVFdmVudCh7XG4gICAgICAgIGV2ZW50OiB7XG4gICAgICAgICAgdHlwZTogWydKc29uTGRFdmVudCddLFxuICAgICAgICAgIGNvZGU6ICdyZWxhdGl2ZSBvYmplY3QgcmVmZXJlbmNlJyxcbiAgICAgICAgICBsZXZlbDogJ3dhcm5pbmcnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdSZWxhdGl2ZSBvYmplY3QgcmVmZXJlbmNlIGZvdW5kLicsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgb2JqZWN0OiBvYmplY3QudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/toRdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/types.js":
/*!******************************************!*\
  !*** ./node_modules/jsonld/lib/types.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Returns true if the given value is an Array.\n *\n * @param v the value to check.\n *\n * @return true if the value is an Array, false if not.\n */\napi.isArray = Array.isArray;\n\n/**\n * Returns true if the given value is a Boolean.\n *\n * @param v the value to check.\n *\n * @return true if the value is a Boolean, false if not.\n */\napi.isBoolean = v => (typeof v === 'boolean' ||\n  Object.prototype.toString.call(v) === '[object Boolean]');\n\n/**\n * Returns true if the given value is a double.\n *\n * @param v the value to check.\n *\n * @return true if the value is a double, false if not.\n */\napi.isDouble = v => api.isNumber(v) &&\n  (String(v).indexOf('.') !== -1 || Math.abs(v) >= 1e21);\n\n/**\n * Returns true if the given value is an empty Object.\n *\n * @param v the value to check.\n *\n * @return true if the value is an empty Object, false if not.\n */\napi.isEmptyObject = v => api.isObject(v) && Object.keys(v).length === 0;\n\n/**\n * Returns true if the given value is a Number.\n *\n * @param v the value to check.\n *\n * @return true if the value is a Number, false if not.\n */\napi.isNumber = v => (typeof v === 'number' ||\n  Object.prototype.toString.call(v) === '[object Number]');\n\n/**\n * Returns true if the given value is numeric.\n *\n * @param v the value to check.\n *\n * @return true if the value is numeric, false if not.\n */\napi.isNumeric = v => !isNaN(parseFloat(v)) && isFinite(v);\n\n/**\n * Returns true if the given value is an Object.\n *\n * @param v the value to check.\n *\n * @return true if the value is an Object, false if not.\n */\napi.isObject = v => Object.prototype.toString.call(v) === '[object Object]';\n\n/**\n * Returns true if the given value is a String.\n *\n * @param v the value to check.\n *\n * @return true if the value is a String, false if not.\n */\napi.isString = v => (typeof v === 'string' ||\n  Object.prototype.toString.call(v) === '[object String]');\n\n/**\n * Returns true if the given value is undefined.\n *\n * @param v the value to check.\n *\n * @return true if the value is undefined, false if not.\n */\napi.isUndefined = v => typeof v === 'undefined';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi90eXBlcy5qcz8yNjVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gQXJyYXksIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBCb29sZWFuLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgQm9vbGVhbiwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNCb29sZWFuID0gdiA9PiAodHlwZW9mIHYgPT09ICdib29sZWFuJyB8fFxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGRvdWJsZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGRvdWJsZSwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNEb3VibGUgPSB2ID0+IGFwaS5pc051bWJlcih2KSAmJlxuICAoU3RyaW5nKHYpLmluZGV4T2YoJy4nKSAhPT0gLTEgfHwgTWF0aC5hYnModikgPj0gMWUyMSk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBlbXB0eSBPYmplY3QuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYW4gZW1wdHkgT2JqZWN0LCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc0VtcHR5T2JqZWN0ID0gdiA9PiBhcGkuaXNPYmplY3QodikgJiYgT2JqZWN0LmtleXModikubGVuZ3RoID09PSAwO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBOdW1iZXIuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBOdW1iZXIsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzTnVtYmVyID0gdiA9PiAodHlwZW9mIHYgPT09ICdudW1iZXInIHx8XG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbnVtZXJpYy5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc051bWVyaWMgPSB2ID0+ICFpc05hTihwYXJzZUZsb2F0KHYpKSAmJiBpc0Zpbml0ZSh2KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIE9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBPYmplY3QsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzT2JqZWN0ID0gdiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBTdHJpbmcuXG4gKlxuICogQHBhcmFtIHYgdGhlIHZhbHVlIHRvIGNoZWNrLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBTdHJpbmcsIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzU3RyaW5nID0gdiA9PiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8XG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaXNVbmRlZmluZWQgPSB2ID0+IHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/url.js":
/*!****************************************!*\
  !*** ./node_modules/jsonld/lib/url.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n\nconst api = {};\nmodule.exports = api;\n\n// define URL parser\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\n// with local jsonld.js modifications\napi.parsers = {\n  simple: {\n    // RFC 3986 basic parts\n    keys: [\n      'href', 'scheme', 'authority', 'path', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/\n  },\n  full: {\n    keys: [\n      'href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password',\n      'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(?:(((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\napi.parse = (str, parser) => {\n  const parsed = {};\n  const o = api.parsers[parser || 'full'];\n  const m = o.regex.exec(str);\n  let i = o.keys.length;\n  while(i--) {\n    parsed[o.keys[i]] = (m[i] === undefined) ? null : m[i];\n  }\n\n  // remove default ports in found in URLs\n  if((parsed.scheme === 'https' && parsed.port === '443') ||\n    (parsed.scheme === 'http' && parsed.port === '80')) {\n    parsed.href = parsed.href.replace(':' + parsed.port, '');\n    parsed.authority = parsed.authority.replace(':' + parsed.port, '');\n    parsed.port = null;\n  }\n\n  parsed.normalizedPath = api.removeDotSegments(parsed.path);\n  return parsed;\n};\n\n/**\n * Prepends a base IRI to the given relative IRI.\n *\n * @param base the base IRI.\n * @param iri the relative IRI.\n *\n * @return the absolute IRI.\n */\napi.prependBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n  // already an absolute IRI\n  if(api.isAbsolute(iri)) {\n    return iri;\n  }\n\n  // parse base if it is a string\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // parse given IRI\n  const rel = api.parse(iri);\n\n  // per RFC3986 5.2.2\n  const transform = {\n    protocol: base.protocol || ''\n  };\n\n  if(rel.authority !== null) {\n    transform.authority = rel.authority;\n    transform.path = rel.path;\n    transform.query = rel.query;\n  } else {\n    transform.authority = base.authority;\n\n    if(rel.path === '') {\n      transform.path = base.path;\n      if(rel.query !== null) {\n        transform.query = rel.query;\n      } else {\n        transform.query = base.query;\n      }\n    } else {\n      if(rel.path.indexOf('/') === 0) {\n        // IRI represents an absolute path\n        transform.path = rel.path;\n      } else {\n        // merge paths\n        let path = base.path;\n\n        // append relative path to the end of the last directory from base\n        path = path.substr(0, path.lastIndexOf('/') + 1);\n        if((path.length > 0 || base.authority) && path.substr(-1) !== '/') {\n          path += '/';\n        }\n        path += rel.path;\n\n        transform.path = path;\n      }\n      transform.query = rel.query;\n    }\n  }\n\n  if(rel.path !== '') {\n    // remove slashes and dots in path\n    transform.path = api.removeDotSegments(transform.path);\n  }\n\n  // construct URL\n  let rval = transform.protocol;\n  if(transform.authority !== null) {\n    rval += '//' + transform.authority;\n  }\n  rval += transform.path;\n  if(transform.query !== null) {\n    rval += '?' + transform.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes a base IRI from the given absolute IRI.\n *\n * @param base the base IRI.\n * @param iri the absolute IRI.\n *\n * @return the relative IRI if relative to base, otherwise the absolute IRI.\n */\napi.removeBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // establish base root\n  let root = '';\n  if(base.href !== '') {\n    root += (base.protocol || '') + '//' + (base.authority || '');\n  } else if(iri.indexOf('//')) {\n    // support network-path reference with empty base\n    root += '//';\n  }\n\n  // IRI not relative to base\n  if(iri.indexOf(root) !== 0) {\n    return iri;\n  }\n\n  // remove root from IRI and parse remainder\n  const rel = api.parse(iri.substr(root.length));\n\n  // remove path segments that match (do not remove last segment unless there\n  // is a hash or query)\n  const baseSegments = base.normalizedPath.split('/');\n  const iriSegments = rel.normalizedPath.split('/');\n  const last = (rel.fragment || rel.query) ? 0 : 1;\n  while(baseSegments.length > 0 && iriSegments.length > last) {\n    if(baseSegments[0] !== iriSegments[0]) {\n      break;\n    }\n    baseSegments.shift();\n    iriSegments.shift();\n  }\n\n  // use '../' for each non-matching base segment\n  let rval = '';\n  if(baseSegments.length > 0) {\n    // don't count the last segment (if it ends with '/' last path doesn't\n    // count and if it doesn't end with '/' it isn't a path)\n    baseSegments.pop();\n    for(let i = 0; i < baseSegments.length; ++i) {\n      rval += '../';\n    }\n  }\n\n  // prepend remaining segments\n  rval += iriSegments.join('/');\n\n  // add query and hash\n  if(rel.query !== null) {\n    rval += '?' + rel.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes dot segments from a URL path.\n *\n * @param path the path to remove dot segments from.\n */\napi.removeDotSegments = path => {\n  // RFC 3986 5.2.4 (reworked)\n\n  // empty path shortcut\n  if(path.length === 0) {\n    return '';\n  }\n\n  const input = path.split('/');\n  const output = [];\n\n  while(input.length > 0) {\n    const next = input.shift();\n    const done = input.length === 0;\n\n    if(next === '.') {\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    if(next === '..') {\n      output.pop();\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    output.push(next);\n  }\n\n  // if path was absolute, ensure output has leading /\n  if(path[0] === '/' && output.length > 0 && output[0] !== '') {\n    output.unshift('');\n  }\n  if(output.length === 1 && output[0] === '') {\n    return '/';\n  }\n\n  return output.join('/');\n};\n\n// TODO: time better isAbsolute/isRelative checks using full regexes:\n// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html\n\n// regex to check for absolute IRI (starting scheme and ':') or blank node IRI\nconst isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\\s]*$/;\n\n/**\n * Returns true if the given value is an absolute IRI or blank node IRI, false\n * if not.\n * Note: This weak check only checks for a correct starting scheme.\n *\n * @param v the value to check.\n *\n * @return true if the value is an absolute IRI, false if not.\n */\napi.isAbsolute = v => types.isString(v) && isAbsoluteRegex.test(v);\n\n/**\n * Returns true if the given value is a relative IRI, false if not.\n * Note: this is a weak check.\n *\n * @param v the value to check.\n *\n * @return true if the value is a relative IRI, false if not.\n */\napi.isRelative = v => types.isString(v);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi91cmwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHlEQUFTOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi91cmwuanM/ZWQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIGRlZmluZSBVUkwgcGFyc2VyXG4vLyBwYXJzZVVyaSAxLjIuMlxuLy8gKGMpIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPlxuLy8gTUlUIExpY2Vuc2Vcbi8vIHdpdGggbG9jYWwganNvbmxkLmpzIG1vZGlmaWNhdGlvbnNcbmFwaS5wYXJzZXJzID0ge1xuICBzaW1wbGU6IHtcbiAgICAvLyBSRkMgMzk4NiBiYXNpYyBwYXJ0c1xuICAgIGtleXM6IFtcbiAgICAgICdocmVmJywgJ3NjaGVtZScsICdhdXRob3JpdHknLCAncGF0aCcsICdxdWVyeScsICdmcmFnbWVudCdcbiAgICBdLFxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuICovXG4gICAgcmVnZXg6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IyguKikpPy9cbiAgfSxcbiAgZnVsbDoge1xuICAgIGtleXM6IFtcbiAgICAgICdocmVmJywgJ3Byb3RvY29sJywgJ3NjaGVtZScsICdhdXRob3JpdHknLCAnYXV0aCcsICd1c2VyJywgJ3Bhc3N3b3JkJyxcbiAgICAgICdob3N0bmFtZScsICdwb3J0JywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnZnJhZ21lbnQnXG4gICAgXSxcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlbiAqL1xuICAgIHJlZ2V4OiAvXigoW2EtekEtWl1bYS16QS1aMC05Ky0uXSopOik/KD86XFwvXFwvKCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oPzooKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL1xuICB9XG59O1xuYXBpLnBhcnNlID0gKHN0ciwgcGFyc2VyKSA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBjb25zdCBvID0gYXBpLnBhcnNlcnNbcGFyc2VyIHx8ICdmdWxsJ107XG4gIGNvbnN0IG0gPSBvLnJlZ2V4LmV4ZWMoc3RyKTtcbiAgbGV0IGkgPSBvLmtleXMubGVuZ3RoO1xuICB3aGlsZShpLS0pIHtcbiAgICBwYXJzZWRbby5rZXlzW2ldXSA9IChtW2ldID09PSB1bmRlZmluZWQpID8gbnVsbCA6IG1baV07XG4gIH1cblxuICAvLyByZW1vdmUgZGVmYXVsdCBwb3J0cyBpbiBmb3VuZCBpbiBVUkxzXG4gIGlmKChwYXJzZWQuc2NoZW1lID09PSAnaHR0cHMnICYmIHBhcnNlZC5wb3J0ID09PSAnNDQzJykgfHxcbiAgICAocGFyc2VkLnNjaGVtZSA9PT0gJ2h0dHAnICYmIHBhcnNlZC5wb3J0ID09PSAnODAnKSkge1xuICAgIHBhcnNlZC5ocmVmID0gcGFyc2VkLmhyZWYucmVwbGFjZSgnOicgKyBwYXJzZWQucG9ydCwgJycpO1xuICAgIHBhcnNlZC5hdXRob3JpdHkgPSBwYXJzZWQuYXV0aG9yaXR5LnJlcGxhY2UoJzonICsgcGFyc2VkLnBvcnQsICcnKTtcbiAgICBwYXJzZWQucG9ydCA9IG51bGw7XG4gIH1cblxuICBwYXJzZWQubm9ybWFsaXplZFBhdGggPSBhcGkucmVtb3ZlRG90U2VnbWVudHMocGFyc2VkLnBhdGgpO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLyoqXG4gKiBQcmVwZW5kcyBhIGJhc2UgSVJJIHRvIHRoZSBnaXZlbiByZWxhdGl2ZSBJUkkuXG4gKlxuICogQHBhcmFtIGJhc2UgdGhlIGJhc2UgSVJJLlxuICogQHBhcmFtIGlyaSB0aGUgcmVsYXRpdmUgSVJJLlxuICpcbiAqIEByZXR1cm4gdGhlIGFic29sdXRlIElSSS5cbiAqL1xuYXBpLnByZXBlbmRCYXNlID0gKGJhc2UsIGlyaSkgPT4ge1xuICAvLyBza2lwIElSSSBwcm9jZXNzaW5nXG4gIGlmKGJhc2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gaXJpO1xuICB9XG4gIC8vIGFscmVhZHkgYW4gYWJzb2x1dGUgSVJJXG4gIGlmKGFwaS5pc0Fic29sdXRlKGlyaSkpIHtcbiAgICByZXR1cm4gaXJpO1xuICB9XG5cbiAgLy8gcGFyc2UgYmFzZSBpZiBpdCBpcyBhIHN0cmluZ1xuICBpZighYmFzZSB8fCB0eXBlcy5pc1N0cmluZyhiYXNlKSkge1xuICAgIGJhc2UgPSBhcGkucGFyc2UoYmFzZSB8fCAnJyk7XG4gIH1cblxuICAvLyBwYXJzZSBnaXZlbiBJUklcbiAgY29uc3QgcmVsID0gYXBpLnBhcnNlKGlyaSk7XG5cbiAgLy8gcGVyIFJGQzM5ODYgNS4yLjJcbiAgY29uc3QgdHJhbnNmb3JtID0ge1xuICAgIHByb3RvY29sOiBiYXNlLnByb3RvY29sIHx8ICcnXG4gIH07XG5cbiAgaWYocmVsLmF1dGhvcml0eSAhPT0gbnVsbCkge1xuICAgIHRyYW5zZm9ybS5hdXRob3JpdHkgPSByZWwuYXV0aG9yaXR5O1xuICAgIHRyYW5zZm9ybS5wYXRoID0gcmVsLnBhdGg7XG4gICAgdHJhbnNmb3JtLnF1ZXJ5ID0gcmVsLnF1ZXJ5O1xuICB9IGVsc2Uge1xuICAgIHRyYW5zZm9ybS5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcblxuICAgIGlmKHJlbC5wYXRoID09PSAnJykge1xuICAgICAgdHJhbnNmb3JtLnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICBpZihyZWwucXVlcnkgIT09IG51bGwpIHtcbiAgICAgICAgdHJhbnNmb3JtLnF1ZXJ5ID0gcmVsLnF1ZXJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYocmVsLnBhdGguaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICAgIC8vIElSSSByZXByZXNlbnRzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgdHJhbnNmb3JtLnBhdGggPSByZWwucGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1lcmdlIHBhdGhzXG4gICAgICAgIGxldCBwYXRoID0gYmFzZS5wYXRoO1xuXG4gICAgICAgIC8vIGFwcGVuZCByZWxhdGl2ZSBwYXRoIHRvIHRoZSBlbmQgb2YgdGhlIGxhc3QgZGlyZWN0b3J5IGZyb20gYmFzZVxuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgIGlmKChwYXRoLmxlbmd0aCA+IDAgfHwgYmFzZS5hdXRob3JpdHkpICYmIHBhdGguc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCArPSByZWwucGF0aDtcblxuICAgICAgICB0cmFuc2Zvcm0ucGF0aCA9IHBhdGg7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ucXVlcnkgPSByZWwucXVlcnk7XG4gICAgfVxuICB9XG5cbiAgaWYocmVsLnBhdGggIT09ICcnKSB7XG4gICAgLy8gcmVtb3ZlIHNsYXNoZXMgYW5kIGRvdHMgaW4gcGF0aFxuICAgIHRyYW5zZm9ybS5wYXRoID0gYXBpLnJlbW92ZURvdFNlZ21lbnRzKHRyYW5zZm9ybS5wYXRoKTtcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBVUkxcbiAgbGV0IHJ2YWwgPSB0cmFuc2Zvcm0ucHJvdG9jb2w7XG4gIGlmKHRyYW5zZm9ybS5hdXRob3JpdHkgIT09IG51bGwpIHtcbiAgICBydmFsICs9ICcvLycgKyB0cmFuc2Zvcm0uYXV0aG9yaXR5O1xuICB9XG4gIHJ2YWwgKz0gdHJhbnNmb3JtLnBhdGg7XG4gIGlmKHRyYW5zZm9ybS5xdWVyeSAhPT0gbnVsbCkge1xuICAgIHJ2YWwgKz0gJz8nICsgdHJhbnNmb3JtLnF1ZXJ5O1xuICB9XG4gIGlmKHJlbC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIHJ2YWwgKz0gJyMnICsgcmVsLmZyYWdtZW50O1xuICB9XG5cbiAgLy8gaGFuZGxlIGVtcHR5IGJhc2VcbiAgaWYocnZhbCA9PT0gJycpIHtcbiAgICBydmFsID0gJy4vJztcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgYmFzZSBJUkkgZnJvbSB0aGUgZ2l2ZW4gYWJzb2x1dGUgSVJJLlxuICpcbiAqIEBwYXJhbSBiYXNlIHRoZSBiYXNlIElSSS5cbiAqIEBwYXJhbSBpcmkgdGhlIGFic29sdXRlIElSSS5cbiAqXG4gKiBAcmV0dXJuIHRoZSByZWxhdGl2ZSBJUkkgaWYgcmVsYXRpdmUgdG8gYmFzZSwgb3RoZXJ3aXNlIHRoZSBhYnNvbHV0ZSBJUkkuXG4gKi9cbmFwaS5yZW1vdmVCYXNlID0gKGJhc2UsIGlyaSkgPT4ge1xuICAvLyBza2lwIElSSSBwcm9jZXNzaW5nXG4gIGlmKGJhc2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gaXJpO1xuICB9XG5cbiAgaWYoIWJhc2UgfHwgdHlwZXMuaXNTdHJpbmcoYmFzZSkpIHtcbiAgICBiYXNlID0gYXBpLnBhcnNlKGJhc2UgfHwgJycpO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGJhc2Ugcm9vdFxuICBsZXQgcm9vdCA9ICcnO1xuICBpZihiYXNlLmhyZWYgIT09ICcnKSB7XG4gICAgcm9vdCArPSAoYmFzZS5wcm90b2NvbCB8fCAnJykgKyAnLy8nICsgKGJhc2UuYXV0aG9yaXR5IHx8ICcnKTtcbiAgfSBlbHNlIGlmKGlyaS5pbmRleE9mKCcvLycpKSB7XG4gICAgLy8gc3VwcG9ydCBuZXR3b3JrLXBhdGggcmVmZXJlbmNlIHdpdGggZW1wdHkgYmFzZVxuICAgIHJvb3QgKz0gJy8vJztcbiAgfVxuXG4gIC8vIElSSSBub3QgcmVsYXRpdmUgdG8gYmFzZVxuICBpZihpcmkuaW5kZXhPZihyb290KSAhPT0gMCkge1xuICAgIHJldHVybiBpcmk7XG4gIH1cblxuICAvLyByZW1vdmUgcm9vdCBmcm9tIElSSSBhbmQgcGFyc2UgcmVtYWluZGVyXG4gIGNvbnN0IHJlbCA9IGFwaS5wYXJzZShpcmkuc3Vic3RyKHJvb3QubGVuZ3RoKSk7XG5cbiAgLy8gcmVtb3ZlIHBhdGggc2VnbWVudHMgdGhhdCBtYXRjaCAoZG8gbm90IHJlbW92ZSBsYXN0IHNlZ21lbnQgdW5sZXNzIHRoZXJlXG4gIC8vIGlzIGEgaGFzaCBvciBxdWVyeSlcbiAgY29uc3QgYmFzZVNlZ21lbnRzID0gYmFzZS5ub3JtYWxpemVkUGF0aC5zcGxpdCgnLycpO1xuICBjb25zdCBpcmlTZWdtZW50cyA9IHJlbC5ub3JtYWxpemVkUGF0aC5zcGxpdCgnLycpO1xuICBjb25zdCBsYXN0ID0gKHJlbC5mcmFnbWVudCB8fCByZWwucXVlcnkpID8gMCA6IDE7XG4gIHdoaWxlKGJhc2VTZWdtZW50cy5sZW5ndGggPiAwICYmIGlyaVNlZ21lbnRzLmxlbmd0aCA+IGxhc3QpIHtcbiAgICBpZihiYXNlU2VnbWVudHNbMF0gIT09IGlyaVNlZ21lbnRzWzBdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYmFzZVNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgaXJpU2VnbWVudHMuc2hpZnQoKTtcbiAgfVxuXG4gIC8vIHVzZSAnLi4vJyBmb3IgZWFjaCBub24tbWF0Y2hpbmcgYmFzZSBzZWdtZW50XG4gIGxldCBydmFsID0gJyc7XG4gIGlmKGJhc2VTZWdtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgLy8gZG9uJ3QgY291bnQgdGhlIGxhc3Qgc2VnbWVudCAoaWYgaXQgZW5kcyB3aXRoICcvJyBsYXN0IHBhdGggZG9lc24ndFxuICAgIC8vIGNvdW50IGFuZCBpZiBpdCBkb2Vzbid0IGVuZCB3aXRoICcvJyBpdCBpc24ndCBhIHBhdGgpXG4gICAgYmFzZVNlZ21lbnRzLnBvcCgpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBiYXNlU2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJ2YWwgKz0gJy4uLyc7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJlcGVuZCByZW1haW5pbmcgc2VnbWVudHNcbiAgcnZhbCArPSBpcmlTZWdtZW50cy5qb2luKCcvJyk7XG5cbiAgLy8gYWRkIHF1ZXJ5IGFuZCBoYXNoXG4gIGlmKHJlbC5xdWVyeSAhPT0gbnVsbCkge1xuICAgIHJ2YWwgKz0gJz8nICsgcmVsLnF1ZXJ5O1xuICB9XG4gIGlmKHJlbC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIHJ2YWwgKz0gJyMnICsgcmVsLmZyYWdtZW50O1xuICB9XG5cbiAgLy8gaGFuZGxlIGVtcHR5IGJhc2VcbiAgaWYocnZhbCA9PT0gJycpIHtcbiAgICBydmFsID0gJy4vJztcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBmcm9tIGEgVVJMIHBhdGguXG4gKlxuICogQHBhcmFtIHBhdGggdGhlIHBhdGggdG8gcmVtb3ZlIGRvdCBzZWdtZW50cyBmcm9tLlxuICovXG5hcGkucmVtb3ZlRG90U2VnbWVudHMgPSBwYXRoID0+IHtcbiAgLy8gUkZDIDM5ODYgNS4yLjQgKHJld29ya2VkKVxuXG4gIC8vIGVtcHR5IHBhdGggc2hvcnRjdXRcbiAgaWYocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBpbnB1dCA9IHBhdGguc3BsaXQoJy8nKTtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG5cbiAgd2hpbGUoaW5wdXQubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5leHQgPSBpbnB1dC5zaGlmdCgpO1xuICAgIGNvbnN0IGRvbmUgPSBpbnB1dC5sZW5ndGggPT09IDA7XG5cbiAgICBpZihuZXh0ID09PSAnLicpIHtcbiAgICAgIGlmKGRvbmUpIHtcbiAgICAgICAgLy8gZW5zdXJlIG91dHB1dCBoYXMgdHJhaWxpbmcgL1xuICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZihuZXh0ID09PSAnLi4nKSB7XG4gICAgICBvdXRwdXQucG9wKCk7XG4gICAgICBpZihkb25lKSB7XG4gICAgICAgIC8vIGVuc3VyZSBvdXRwdXQgaGFzIHRyYWlsaW5nIC9cbiAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgb3V0cHV0LnB1c2gobmV4dCk7XG4gIH1cblxuICAvLyBpZiBwYXRoIHdhcyBhYnNvbHV0ZSwgZW5zdXJlIG91dHB1dCBoYXMgbGVhZGluZyAvXG4gIGlmKHBhdGhbMF0gPT09ICcvJyAmJiBvdXRwdXQubGVuZ3RoID4gMCAmJiBvdXRwdXRbMF0gIT09ICcnKSB7XG4gICAgb3V0cHV0LnVuc2hpZnQoJycpO1xuICB9XG4gIGlmKG91dHB1dC5sZW5ndGggPT09IDEgJiYgb3V0cHV0WzBdID09PSAnJykge1xuICAgIHJldHVybiAnLyc7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oJy8nKTtcbn07XG5cbi8vIFRPRE86IHRpbWUgYmV0dGVyIGlzQWJzb2x1dGUvaXNSZWxhdGl2ZSBjaGVja3MgdXNpbmcgZnVsbCByZWdleGVzOlxuLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbFxuXG4vLyByZWdleCB0byBjaGVjayBmb3IgYWJzb2x1dGUgSVJJIChzdGFydGluZyBzY2hlbWUgYW5kICc6Jykgb3IgYmxhbmsgbm9kZSBJUklcbmNvbnN0IGlzQWJzb2x1dGVSZWdleCA9IC9eKFtBLVphLXpdW0EtWmEtejAtOSstLl0qfF8pOlteXFxzXSokLztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGFic29sdXRlIElSSSBvciBibGFuayBub2RlIElSSSwgZmFsc2VcbiAqIGlmIG5vdC5cbiAqIE5vdGU6IFRoaXMgd2VhayBjaGVjayBvbmx5IGNoZWNrcyBmb3IgYSBjb3JyZWN0IHN0YXJ0aW5nIHNjaGVtZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBhYnNvbHV0ZSBJUkksIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmlzQWJzb2x1dGUgPSB2ID0+IHR5cGVzLmlzU3RyaW5nKHYpICYmIGlzQWJzb2x1dGVSZWdleC50ZXN0KHYpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSByZWxhdGl2ZSBJUkksIGZhbHNlIGlmIG5vdC5cbiAqIE5vdGU6IHRoaXMgaXMgYSB3ZWFrIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGlzIGEgcmVsYXRpdmUgSVJJLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5pc1JlbGF0aXZlID0gdiA9PiB0eXBlcy5pc1N0cmluZyh2KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/lib/util.js":
/*!*****************************************!*\
  !*** ./node_modules/jsonld/lib/util.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst graphTypes = __webpack_require__(/*! ./graphTypes */ \"(ssr)/./node_modules/jsonld/lib/graphTypes.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/jsonld/lib/types.js\");\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = (__webpack_require__(/*! rdf-canonize */ \"(ssr)/./node_modules/rdf-canonize/index.js\").IdentifierIssuer);\nconst JsonLdError = __webpack_require__(/*! ./JsonLdError */ \"(ssr)/./node_modules/jsonld/lib/JsonLdError.js\");\n\n// constants\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\nconst REGEX_KEYWORD = /^@[a-zA-Z]+$/;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\napi.REGEX_BCP47 = REGEX_BCP47;\napi.REGEX_KEYWORD = REGEX_KEYWORD;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result.rel || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = (v, isFrame) => {\n  if(types.isString(v)) {\n    return;\n  }\n\n  if(types.isArray(v) && v.every(vv => types.isString(vv))) {\n    return;\n  }\n  if(isFrame && types.isObject(v)) {\n    switch(Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n      case 1:\n        // default entry is all strings\n        if('@default' in v &&\n          api.asArray(v['@default']).every(vv => types.isString(vv))) {\n          return;\n        }\n    }\n  }\n\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n    'strings, an empty object, ' +\n    'or a default object.', 'jsonld.SyntaxError',\n    {code: 'invalid type value', value: v});\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if(!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if(options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      if(options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLG1FQUFjO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyx5REFBUztBQUMvQjtBQUNBLHlCQUF5Qix3R0FBd0M7QUFDakUsb0JBQW9CLG1CQUFPLENBQUMscUVBQWU7O0FBRTNDO0FBQ0EsK0JBQStCLElBQUksY0FBYyxJQUFJO0FBQ3JEO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUEsd0JBQXdCLGdDQUFnQztBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSyxxQ0FBcUM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkL2xpYi91dGlsLmpzPzVlYWEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDE5IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ3JhcGhUeXBlcyA9IHJlcXVpcmUoJy4vZ3JhcGhUeXBlcycpO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG4vLyBUT0RPOiBtb3ZlIGBJZGVudGlmaWVySXNzdWVyYCB0byBpdHMgb3duIHBhY2thZ2VcbmNvbnN0IElkZW50aWZpZXJJc3N1ZXIgPSByZXF1aXJlKCdyZGYtY2Fub25pemUnKS5JZGVudGlmaWVySXNzdWVyO1xuY29uc3QgSnNvbkxkRXJyb3IgPSByZXF1aXJlKCcuL0pzb25MZEVycm9yJyk7XG5cbi8vIGNvbnN0YW50c1xuY29uc3QgUkVHRVhfQkNQNDcgPSAvXlthLXpBLVpdezEsOH0oLVthLXpBLVowLTldezEsOH0pKiQvO1xuY29uc3QgUkVHRVhfTElOS19IRUFERVJTID0gLyg/OjxbXj5dKj8+fFwiW15cIl0qP1wifFteLF0pKy9nO1xuY29uc3QgUkVHRVhfTElOS19IRUFERVIgPSAvXFxzKjwoW14+XSo/KT5cXHMqKD86O1xccyooLiopKT8vO1xuY29uc3QgUkVHRVhfTElOS19IRUFERVJfUEFSQU1TID1cbiAgLyguKj8pPSg/Oig/OlwiKFteXCJdKj8pXCIpfChbXlwiXSo/KSlcXHMqKD86KD86O1xccyopfCQpL2c7XG5jb25zdCBSRUdFWF9LRVlXT1JEID0gL15AW2EtekEtWl0rJC87XG5cbmNvbnN0IERFRkFVTFRTID0ge1xuICBoZWFkZXJzOiB7XG4gICAgYWNjZXB0OiAnYXBwbGljYXRpb24vbGQranNvbiwgYXBwbGljYXRpb24vanNvbidcbiAgfVxufTtcblxuY29uc3QgYXBpID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGFwaTtcbmFwaS5JZGVudGlmaWVySXNzdWVyID0gSWRlbnRpZmllcklzc3VlcjtcbmFwaS5SRUdFWF9CQ1A0NyA9IFJFR0VYX0JDUDQ3O1xuYXBpLlJFR0VYX0tFWVdPUkQgPSBSRUdFWF9LRVlXT1JEO1xuXG4vKipcbiAqIENsb25lcyBhbiBvYmplY3QsIGFycmF5LCBNYXAsIFNldCwgb3Igc3RyaW5nL251bWJlci4gSWYgYSB0eXBlZCBKYXZhU2NyaXB0XG4gKiBvYmplY3QgaXMgZ2l2ZW4sIHN1Y2ggYXMgYSBEYXRlLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNsb25lLlxuICpcbiAqIEByZXR1cm4gdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuYXBpLmNsb25lID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGxldCBydmFsO1xuICAgIGlmKHR5cGVzLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBydmFsID0gW107XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcnZhbFtpXSA9IGFwaS5jbG9uZSh2YWx1ZVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBydmFsID0gbmV3IE1hcCgpO1xuICAgICAgZm9yKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgICAgICBydmFsLnNldChrLCBhcGkuY2xvbmUodikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZih2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgcnZhbCA9IG5ldyBTZXQoKTtcbiAgICAgIGZvcihjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIHJ2YWwuYWRkKGFwaS5jbG9uZSh2KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcnZhbCA9IHt9O1xuICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBydmFsW2tleV0gPSBhcGkuY2xvbmUodmFsdWVba2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIEVuc3VyZSBhIHZhbHVlIGlzIGFuIGFycmF5LiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIGl0IGlzIHJldHVybmVkLlxuICogT3RoZXJ3aXNlLCBpdCBpcyB3cmFwcGVkIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gcmV0dXJuIGFzIGFuIGFycmF5LlxuICpcbiAqIEByZXR1cm4gdGhlIHZhbHVlIGFzIGFuIGFycmF5LlxuICovXG5hcGkuYXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn07XG5cbi8qKlxuICogQnVpbGRzIGFuIEhUVFAgaGVhZGVycyBvYmplY3QgZm9yIG1ha2luZyBhIEpTT04tTEQgcmVxdWVzdCBmcm9tIGN1c3RvbVxuICogaGVhZGVycyBhbmQgYXNzZXJ0cyB0aGUgYGFjY2VwdGAgaGVhZGVyIGlzbid0IG92ZXJyaWRkZW4uXG4gKlxuICogQHBhcmFtIGhlYWRlcnMgYW4gb2JqZWN0IG9mIGhlYWRlcnMgd2l0aCBrZXlzIGFzIGhlYWRlciBuYW1lcyBhbmQgdmFsdWVzXG4gKiAgICAgICAgICBhcyBoZWFkZXIgdmFsdWVzLlxuICpcbiAqIEByZXR1cm4gYW4gb2JqZWN0IG9mIGhlYWRlcnMgd2l0aCBhIHZhbGlkIGBhY2NlcHRgIGhlYWRlci5cbiAqL1xuYXBpLmJ1aWxkSGVhZGVycyA9IChoZWFkZXJzID0ge30pID0+IHtcbiAgY29uc3QgaGFzQWNjZXB0ID0gT2JqZWN0LmtleXMoaGVhZGVycykuc29tZShcbiAgICBoID0+IGgudG9Mb3dlckNhc2UoKSA9PT0gJ2FjY2VwdCcpO1xuXG4gIGlmKGhhc0FjY2VwdCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgJ0FjY2VwdCBoZWFkZXIgbWF5IG5vdCBiZSBzcGVjaWZpZWQ7IG9ubHkgXCInICtcbiAgICAgIERFRkFVTFRTLmhlYWRlcnMuYWNjZXB0ICsgJ1wiIGlzIHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtBY2NlcHQ6IERFRkFVTFRTLmhlYWRlcnMuYWNjZXB0fSwgaGVhZGVycyk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGxpbmsgaGVhZGVyLiBUaGUgcmVzdWx0cyB3aWxsIGJlIGtleSdkIGJ5IHRoZSB2YWx1ZSBvZiBcInJlbFwiLlxuICpcbiAqIExpbms6IDxodHRwOi8vanNvbi1sZC5vcmcvY29udGV4dHMvcGVyc29uLmpzb25sZD47XG4gKiByZWw9XCJodHRwOi8vd3d3LnczLm9yZy9ucy9qc29uLWxkI2NvbnRleHRcIjsgdHlwZT1cImFwcGxpY2F0aW9uL2xkK2pzb25cIlxuICpcbiAqIFBhcnNlcyBhczoge1xuICogICAnaHR0cDovL3d3dy53My5vcmcvbnMvanNvbi1sZCNjb250ZXh0Jzoge1xuICogICAgIHRhcmdldDogaHR0cDovL2pzb24tbGQub3JnL2NvbnRleHRzL3BlcnNvbi5qc29ubGQsXG4gKiAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2xkK2pzb24nXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIFwicmVsXCIgd2l0aCB0aGUgc2FtZSBJUkksIHRoZW4gZW50cmllcyBpbiB0aGVcbiAqIHJlc3VsdGluZyBtYXAgZm9yIHRoYXQgXCJyZWxcIiB3aWxsIGJlIGFycmF5cy5cbiAqXG4gKiBAcGFyYW0gaGVhZGVyIHRoZSBsaW5rIGhlYWRlciB0byBwYXJzZS5cbiAqL1xuYXBpLnBhcnNlTGlua0hlYWRlciA9IGhlYWRlciA9PiB7XG4gIGNvbnN0IHJ2YWwgPSB7fTtcbiAgLy8gc3BsaXQgb24gdW5icmFja2V0ZWQvdW5xdW90ZWQgY29tbWFzXG4gIGNvbnN0IGVudHJpZXMgPSBoZWFkZXIubWF0Y2goUkVHRVhfTElOS19IRUFERVJTKTtcbiAgZm9yKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgbWF0Y2ggPSBlbnRyaWVzW2ldLm1hdGNoKFJFR0VYX0xJTktfSEVBREVSKTtcbiAgICBpZighbWF0Y2gpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7dGFyZ2V0OiBtYXRjaFsxXX07XG4gICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbMl07XG4gICAgd2hpbGUoKG1hdGNoID0gUkVHRVhfTElOS19IRUFERVJfUEFSQU1TLmV4ZWMocGFyYW1zKSkpIHtcbiAgICAgIHJlc3VsdFttYXRjaFsxXV0gPSAobWF0Y2hbMl0gPT09IHVuZGVmaW5lZCkgPyBtYXRjaFszXSA6IG1hdGNoWzJdO1xuICAgIH1cbiAgICBjb25zdCByZWwgPSByZXN1bHQucmVsIHx8ICcnO1xuICAgIGlmKEFycmF5LmlzQXJyYXkocnZhbFtyZWxdKSkge1xuICAgICAgcnZhbFtyZWxdLnB1c2gocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYocnZhbC5oYXNPd25Qcm9wZXJ0eShyZWwpKSB7XG4gICAgICBydmFsW3JlbF0gPSBbcnZhbFtyZWxdLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBydmFsW3JlbF0gPSByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBAdHlwZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdiB0aGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmFwaS52YWxpZGF0ZVR5cGVWYWx1ZSA9ICh2LCBpc0ZyYW1lKSA9PiB7XG4gIGlmKHR5cGVzLmlzU3RyaW5nKHYpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYodHlwZXMuaXNBcnJheSh2KSAmJiB2LmV2ZXJ5KHZ2ID0+IHR5cGVzLmlzU3RyaW5nKHZ2KSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYoaXNGcmFtZSAmJiB0eXBlcy5pc09iamVjdCh2KSkge1xuICAgIHN3aXRjaChPYmplY3Qua2V5cyh2KS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgLy8gZW1wdHkgb2JqZWN0IGlzIHdpbGRjYXJkXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLy8gZGVmYXVsdCBlbnRyeSBpcyBhbGwgc3RyaW5nc1xuICAgICAgICBpZignQGRlZmF1bHQnIGluIHYgJiZcbiAgICAgICAgICBhcGkuYXNBcnJheSh2WydAZGVmYXVsdCddKS5ldmVyeSh2diA9PiB0eXBlcy5pc1N0cmluZyh2dikpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEpzb25MZEVycm9yKFxuICAgICdJbnZhbGlkIEpTT04tTEQgc3ludGF4OyBcIkB0eXBlXCIgdmFsdWUgbXVzdCBhIHN0cmluZywgYW4gYXJyYXkgb2YgJyArXG4gICAgJ3N0cmluZ3MsIGFuIGVtcHR5IG9iamVjdCwgJyArXG4gICAgJ29yIGEgZGVmYXVsdCBvYmplY3QuJywgJ2pzb25sZC5TeW50YXhFcnJvcicsXG4gICAge2NvZGU6ICdpbnZhbGlkIHR5cGUgdmFsdWUnLCB2YWx1ZTogdn0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHN1YmplY3QgaGFzIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gc3ViamVjdCB0aGUgc3ViamVjdCB0byBjaGVjay5cbiAqIEBwYXJhbSBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgdG8gbG9vayBmb3IuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBzdWJqZWN0IGhhcyB0aGUgZ2l2ZW4gcHJvcGVydHksIGZhbHNlIGlmIG5vdC5cbiAqL1xuYXBpLmhhc1Byb3BlcnR5ID0gKHN1YmplY3QsIHByb3BlcnR5KSA9PiB7XG4gIGlmKHN1YmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdWJqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gKCF0eXBlcy5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiAwKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgcHJvcGVydHkgb2YgdGhlIGdpdmVuIHN1YmplY3QuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjaGVjay5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIGV4aXN0cywgZmFsc2UgaWYgbm90LlxuICovXG5hcGkuaGFzVmFsdWUgPSAoc3ViamVjdCwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIGlmKGFwaS5oYXNQcm9wZXJ0eShzdWJqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBsZXQgdmFsID0gc3ViamVjdFtwcm9wZXJ0eV07XG4gICAgY29uc3QgaXNMaXN0ID0gZ3JhcGhUeXBlcy5pc0xpc3QodmFsKTtcbiAgICBpZih0eXBlcy5pc0FycmF5KHZhbCkgfHwgaXNMaXN0KSB7XG4gICAgICBpZihpc0xpc3QpIHtcbiAgICAgICAgdmFsID0gdmFsWydAbGlzdCddO1xuICAgICAgfVxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZihhcGkuY29tcGFyZVZhbHVlcyh2YWx1ZSwgdmFsW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCF0eXBlcy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gYXZvaWQgbWF0Y2hpbmcgdGhlIHNldCBvZiB2YWx1ZXMgd2l0aCBhbiBhcnJheSB2YWx1ZSBwYXJhbWV0ZXJcbiAgICAgIHJldHVybiBhcGkuY29tcGFyZVZhbHVlcyh2YWx1ZSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gYSBzdWJqZWN0LiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIGFsbCB2YWx1ZXMgaW4gdGhlXG4gKiBhcnJheSB3aWxsIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0IHRvIGFkZCB0aGUgdmFsdWUgdG8uXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRoYXQgcmVsYXRlcyB0aGUgdmFsdWUgdG8gdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGFkZC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgIFtwcm9wZXJ0eUlzQXJyYXldIHRydWUgaWYgdGhlIHByb3BlcnR5IGlzIGFsd2F5cyBhbiBhcnJheSwgZmFsc2VcbiAqICAgICAgICAgIGlmIG5vdCAoZGVmYXVsdDogZmFsc2UpLlxuICogICAgICAgIFt2YWx1ZUlzQXJyYXldIHRydWUgaWYgdGhlIHZhbHVlIHRvIGJlIGFkZGVkIHNob3VsZCBiZSBwcmVzZXJ2ZWQgYXNcbiAqICAgICAgICAgIGFuIGFycmF5IChsaXN0cykgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqICAgICAgICBbYWxsb3dEdXBsaWNhdGVdIHRydWUgdG8gYWxsb3cgZHVwbGljYXRlcywgZmFsc2Ugbm90IHRvICh1c2VzIGFcbiAqICAgICAgICAgIHNpbXBsZSBzaGFsbG93IGNvbXBhcmlzb24gb2Ygc3ViamVjdCBJRCBvciB2YWx1ZSkgKGRlZmF1bHQ6IHRydWUpLlxuICogICAgICAgIFtwcmVwZW5kVmFsdWVdIGZhbHNlIHRvIHByZXBlbmQgdmFsdWUgdG8gYW55IGV4aXN0aW5nIHZhbHVlcy5cbiAqICAgICAgICAgIChkZWZhdWx0OiBmYWxzZSlcbiAqL1xuYXBpLmFkZFZhbHVlID0gKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoISgncHJvcGVydHlJc0FycmF5JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucHJvcGVydHlJc0FycmF5ID0gZmFsc2U7XG4gIH1cbiAgaWYoISgndmFsdWVJc0FycmF5JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMudmFsdWVJc0FycmF5ID0gZmFsc2U7XG4gIH1cbiAgaWYoISgnYWxsb3dEdXBsaWNhdGUnIGluIG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5hbGxvd0R1cGxpY2F0ZSA9IHRydWU7XG4gIH1cbiAgaWYoISgncHJlcGVuZFZhbHVlJyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucHJlcGVuZFZhbHVlID0gZmFsc2U7XG4gIH1cblxuICBpZihvcHRpb25zLnZhbHVlSXNBcnJheSkge1xuICAgIHN1YmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gIH0gZWxzZSBpZih0eXBlcy5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBvcHRpb25zLnByb3BlcnR5SXNBcnJheSAmJlxuICAgICAgIXN1YmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IFtdO1xuICAgIH1cbiAgICBpZihvcHRpb25zLnByZXBlbmRWYWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5jb25jYXQoc3ViamVjdFtwcm9wZXJ0eV0pO1xuICAgICAgc3ViamVjdFtwcm9wZXJ0eV0gPSBbXTtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcGkuYWRkVmFsdWUoc3ViamVjdCwgcHJvcGVydHksIHZhbHVlW2ldLCBvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZihzdWJqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgIC8vIGNoZWNrIGlmIHN1YmplY3QgYWxyZWFkeSBoYXMgdmFsdWUgaWYgZHVwbGljYXRlcyBub3QgYWxsb3dlZFxuICAgIGNvbnN0IGhhc1ZhbHVlID0gKCFvcHRpb25zLmFsbG93RHVwbGljYXRlICYmXG4gICAgICBhcGkuaGFzVmFsdWUoc3ViamVjdCwgcHJvcGVydHksIHZhbHVlKSk7XG5cbiAgICAvLyBtYWtlIHByb3BlcnR5IGFuIGFycmF5IGlmIHZhbHVlIG5vdCBwcmVzZW50IG9yIGFsd2F5cyBhbiBhcnJheVxuICAgIGlmKCF0eXBlcy5pc0FycmF5KHN1YmplY3RbcHJvcGVydHldKSAmJlxuICAgICAgKCFoYXNWYWx1ZSB8fCBvcHRpb25zLnByb3BlcnR5SXNBcnJheSkpIHtcbiAgICAgIHN1YmplY3RbcHJvcGVydHldID0gW3N1YmplY3RbcHJvcGVydHldXTtcbiAgICB9XG5cbiAgICAvLyBhZGQgbmV3IHZhbHVlXG4gICAgaWYoIWhhc1ZhbHVlKSB7XG4gICAgICBpZihvcHRpb25zLnByZXBlbmRWYWx1ZSkge1xuICAgICAgICBzdWJqZWN0W3Byb3BlcnR5XS51bnNoaWZ0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YmplY3RbcHJvcGVydHldLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhZGQgbmV3IHZhbHVlIGFzIHNldCBvciBzaW5nbGUgdmFsdWVcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IG9wdGlvbnMucHJvcGVydHlJc0FycmF5ID8gW3ZhbHVlXSA6IHZhbHVlO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgYWxsIG9mIHRoZSB2YWx1ZXMgZm9yIGEgc3ViamVjdCdzIHByb3BlcnR5IGFzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSBzdWJqZWN0LlxuICogQHBhcmFtIHByb3BlcnR5IHRoZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIGFsbCBvZiB0aGUgdmFsdWVzIGZvciBhIHN1YmplY3QncyBwcm9wZXJ0eSBhcyBhbiBhcnJheS5cbiAqL1xuYXBpLmdldFZhbHVlcyA9IChzdWJqZWN0LCBwcm9wZXJ0eSkgPT4gW10uY29uY2F0KHN1YmplY3RbcHJvcGVydHldIHx8IFtdKTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcHJvcGVydHkgZnJvbSBhIHN1YmplY3QuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5LlxuICovXG5hcGkucmVtb3ZlUHJvcGVydHkgPSAoc3ViamVjdCwgcHJvcGVydHkpID0+IHtcbiAgZGVsZXRlIHN1YmplY3RbcHJvcGVydHldO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSBhIHN1YmplY3QuXG4gKlxuICogQHBhcmFtIHN1YmplY3QgdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gcHJvcGVydHkgdGhlIHByb3BlcnR5IHRoYXQgcmVsYXRlcyB0aGUgdmFsdWUgdG8gdGhlIHN1YmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICAgICAgICAgW3Byb3BlcnR5SXNBcnJheV0gdHJ1ZSBpZiB0aGUgcHJvcGVydHkgaXMgYWx3YXlzIGFuIGFycmF5LCBmYWxzZVxuICogICAgICAgICAgICBpZiBub3QgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqL1xuYXBpLnJlbW92ZVZhbHVlID0gKHN1YmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYoISgncHJvcGVydHlJc0FycmF5JyBpbiBvcHRpb25zKSkge1xuICAgIG9wdGlvbnMucHJvcGVydHlJc0FycmF5ID0gZmFsc2U7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHZhbHVlXG4gIGNvbnN0IHZhbHVlcyA9IGFwaS5nZXRWYWx1ZXMoc3ViamVjdCwgcHJvcGVydHkpLmZpbHRlcihcbiAgICBlID0+ICFhcGkuY29tcGFyZVZhbHVlcyhlLCB2YWx1ZSkpO1xuXG4gIGlmKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICBhcGkucmVtb3ZlUHJvcGVydHkoc3ViamVjdCwgcHJvcGVydHkpO1xuICB9IGVsc2UgaWYodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiAhb3B0aW9ucy5wcm9wZXJ0eUlzQXJyYXkpIHtcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IHZhbHVlc1swXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJqZWN0W3Byb3BlcnR5XSA9IHZhbHVlcztcbiAgfVxufTtcblxuLyoqXG4gKiBSZWxhYmVscyBhbGwgYmxhbmsgbm9kZXMgaW4gdGhlIGdpdmVuIEpTT04tTEQgaW5wdXQuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBKU09OLUxEIGlucHV0LlxuICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgICAgICAgICBbaXNzdWVyXSBhbiBJZGVudGlmaWVySXNzdWVyIHRvIHVzZSB0byBsYWJlbCBibGFuayBub2Rlcy5cbiAqL1xuYXBpLnJlbGFiZWxCbGFua05vZGVzID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBpc3N1ZXIgPSBvcHRpb25zLmlzc3VlciB8fCBuZXcgSWRlbnRpZmllcklzc3VlcignXzpiJyk7XG4gIHJldHVybiBfbGFiZWxCbGFua05vZGVzKGlzc3VlciwgaW5wdXQpO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gSlNPTi1MRCB2YWx1ZXMgZm9yIGVxdWFsaXR5LiBUd28gSlNPTi1MRCB2YWx1ZXMgd2lsbCBiZVxuICogY29uc2lkZXJlZCBlcXVhbCBpZjpcbiAqXG4gKiAxLiBUaGV5IGFyZSBib3RoIHByaW1pdGl2ZXMgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdmFsdWUuXG4gKiAyLiBUaGV5IGFyZSBib3RoIEB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBAdmFsdWUsIEB0eXBlLCBAbGFuZ3VhZ2UsXG4gKiAgIGFuZCBAaW5kZXgsIE9SXG4gKiAzLiBUaGV5IGJvdGggaGF2ZSBAaWRzIHRoZXkgYXJlIHRoZSBzYW1lLlxuICpcbiAqIEBwYXJhbSB2MSB0aGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0gdjIgdGhlIHNlY29uZCB2YWx1ZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdjEgYW5kIHYyIGFyZSBjb25zaWRlcmVkIGVxdWFsLCBmYWxzZSBpZiBub3QuXG4gKi9cbmFwaS5jb21wYXJlVmFsdWVzID0gKHYxLCB2MikgPT4ge1xuICAvLyAxLiBlcXVhbCBwcmltaXRpdmVzXG4gIGlmKHYxID09PSB2Mikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMi4gZXF1YWwgQHZhbHVlc1xuICBpZihncmFwaFR5cGVzLmlzVmFsdWUodjEpICYmIGdyYXBoVHlwZXMuaXNWYWx1ZSh2MikgJiZcbiAgICB2MVsnQHZhbHVlJ10gPT09IHYyWydAdmFsdWUnXSAmJlxuICAgIHYxWydAdHlwZSddID09PSB2MlsnQHR5cGUnXSAmJlxuICAgIHYxWydAbGFuZ3VhZ2UnXSA9PT0gdjJbJ0BsYW5ndWFnZSddICYmXG4gICAgdjFbJ0BpbmRleCddID09PSB2MlsnQGluZGV4J10pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDMuIGVxdWFsIEBpZHNcbiAgaWYodHlwZXMuaXNPYmplY3QodjEpICYmXG4gICAgKCdAaWQnIGluIHYxKSAmJlxuICAgIHR5cGVzLmlzT2JqZWN0KHYyKSAmJlxuICAgICgnQGlkJyBpbiB2MikpIHtcbiAgICByZXR1cm4gdjFbJ0BpZCddID09PSB2MlsnQGlkJ107XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHR3byBzdHJpbmdzIGZpcnN0IGJhc2VkIG9uIGxlbmd0aCBhbmQgdGhlbiBsZXhpY29ncmFwaGljYWxseS5cbiAqXG4gKiBAcGFyYW0gYSB0aGUgZmlyc3Qgc3RyaW5nLlxuICogQHBhcmFtIGIgdGhlIHNlY29uZCBzdHJpbmcuXG4gKlxuICogQHJldHVybiAtMSBpZiBhIDwgYiwgMSBpZiBhID4gYiwgMCBpZiBhID09PSBiLlxuICovXG5hcGkuY29tcGFyZVNob3J0ZXN0TGVhc3QgPSAoYSwgYikgPT4ge1xuICBpZihhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmKGIubGVuZ3RoIDwgYS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZihhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIChhIDwgYikgPyAtMSA6IDE7XG59O1xuXG4vKipcbiAqIExhYmVscyB0aGUgYmxhbmsgbm9kZXMgaW4gdGhlIGdpdmVuIHZhbHVlIHVzaW5nIHRoZSBnaXZlbiBJZGVudGlmaWVySXNzdWVyLlxuICpcbiAqIEBwYXJhbSBpc3N1ZXIgdGhlIElkZW50aWZpZXJJc3N1ZXIgdG8gdXNlLlxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnQgd2l0aCBibGFuayBub2RlcyB0byByZW5hbWUuXG4gKlxuICogQHJldHVybiB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gX2xhYmVsQmxhbmtOb2Rlcyhpc3N1ZXIsIGVsZW1lbnQpIHtcbiAgaWYodHlwZXMuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBlbGVtZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICBlbGVtZW50W2ldID0gX2xhYmVsQmxhbmtOb2Rlcyhpc3N1ZXIsIGVsZW1lbnRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmKGdyYXBoVHlwZXMuaXNMaXN0KGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudFsnQGxpc3QnXSA9IF9sYWJlbEJsYW5rTm9kZXMoaXNzdWVyLCBlbGVtZW50WydAbGlzdCddKTtcbiAgfSBlbHNlIGlmKHR5cGVzLmlzT2JqZWN0KGVsZW1lbnQpKSB7XG4gICAgLy8gcmVsYWJlbCBibGFuayBub2RlXG4gICAgaWYoZ3JhcGhUeXBlcy5pc0JsYW5rTm9kZShlbGVtZW50KSkge1xuICAgICAgZWxlbWVudFsnQGlkJ10gPSBpc3N1ZXIuZ2V0SWQoZWxlbWVudFsnQGlkJ10pO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IGFwcGx5IHRvIGFsbCBrZXlzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQpLnNvcnQoKTtcbiAgICBmb3IobGV0IGtpID0gMDsga2kgPCBrZXlzLmxlbmd0aDsgKytraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1traV07XG4gICAgICBpZihrZXkgIT09ICdAaWQnKSB7XG4gICAgICAgIGVsZW1lbnRba2V5XSA9IF9sYWJlbEJsYW5rTm9kZXMoaXNzdWVyLCBlbGVtZW50W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/lib/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld/node_modules/lru-cache/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/jsonld/node_modules/lru-cache/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A linked list to keep track of recently-used-ness\nconst Yallist = __webpack_require__(/*! yallist */ \"(ssr)/./node_modules/yallist/yallist.js\")\n\nconst MAX = Symbol('max')\nconst LENGTH = Symbol('length')\nconst LENGTH_CALCULATOR = Symbol('lengthCalculator')\nconst ALLOW_STALE = Symbol('allowStale')\nconst MAX_AGE = Symbol('maxAge')\nconst DISPOSE = Symbol('dispose')\nconst NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')\nconst LRU_LIST = Symbol('lruList')\nconst CACHE = Symbol('cache')\nconst UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')\n\nconst naiveLength = () => 1\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nclass LRUCache {\n  constructor (options) {\n    if (typeof options === 'number')\n      options = { max: options }\n\n    if (!options)\n      options = {}\n\n    if (options.max && (typeof options.max !== 'number' || options.max < 0))\n      throw new TypeError('max must be a non-negative number')\n    // Kind of weird to have a default max of Infinity, but oh well.\n    const max = this[MAX] = options.max || Infinity\n\n    const lc = options.length || naiveLength\n    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc\n    this[ALLOW_STALE] = options.stale || false\n    if (options.maxAge && typeof options.maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n    this[MAX_AGE] = options.maxAge || 0\n    this[DISPOSE] = options.dispose\n    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false\n    this.reset()\n  }\n\n  // resize the cache when the max changes.\n  set max (mL) {\n    if (typeof mL !== 'number' || mL < 0)\n      throw new TypeError('max must be a non-negative number')\n\n    this[MAX] = mL || Infinity\n    trim(this)\n  }\n  get max () {\n    return this[MAX]\n  }\n\n  set allowStale (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  }\n  get allowStale () {\n    return this[ALLOW_STALE]\n  }\n\n  set maxAge (mA) {\n    if (typeof mA !== 'number')\n      throw new TypeError('maxAge must be a non-negative number')\n\n    this[MAX_AGE] = mA\n    trim(this)\n  }\n  get maxAge () {\n    return this[MAX_AGE]\n  }\n\n  // resize the cache when the lengthCalculator changes.\n  set lengthCalculator (lC) {\n    if (typeof lC !== 'function')\n      lC = naiveLength\n\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(hit => {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      })\n    }\n    trim(this)\n  }\n  get lengthCalculator () { return this[LENGTH_CALCULATOR] }\n\n  get length () { return this[LENGTH] }\n  get itemCount () { return this[LRU_LIST].length }\n\n  rforEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].tail; walker !== null;) {\n      const prev = walker.prev\n      forEachStep(this, fn, walker, thisp)\n      walker = prev\n    }\n  }\n\n  forEach (fn, thisp) {\n    thisp = thisp || this\n    for (let walker = this[LRU_LIST].head; walker !== null;) {\n      const next = walker.next\n      forEachStep(this, fn, walker, thisp)\n      walker = next\n    }\n  }\n\n  keys () {\n    return this[LRU_LIST].toArray().map(k => k.key)\n  }\n\n  values () {\n    return this[LRU_LIST].toArray().map(k => k.value)\n  }\n\n  reset () {\n    if (this[DISPOSE] &&\n        this[LRU_LIST] &&\n        this[LRU_LIST].length) {\n      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))\n    }\n\n    this[CACHE] = new Map() // hash of items by key\n    this[LRU_LIST] = new Yallist() // list of items in order of use recency\n    this[LENGTH] = 0 // length of items in the list\n  }\n\n  dump () {\n    return this[LRU_LIST].map(hit =>\n      isStale(this, hit) ? false : {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }).toArray().filter(h => h)\n  }\n\n  dumpLru () {\n    return this[LRU_LIST]\n  }\n\n  set (key, value, maxAge) {\n    maxAge = maxAge || this[MAX_AGE]\n\n    if (maxAge && typeof maxAge !== 'number')\n      throw new TypeError('maxAge must be a number')\n\n    const now = maxAge ? Date.now() : 0\n    const len = this[LENGTH_CALCULATOR](value, key)\n\n    if (this[CACHE].has(key)) {\n      if (len > this[MAX]) {\n        del(this, this[CACHE].get(key))\n        return false\n      }\n\n      const node = this[CACHE].get(key)\n      const item = node.value\n\n      // dispose of the old one before overwriting\n      // split out into 2 ifs for better coverage tracking\n      if (this[DISPOSE]) {\n        if (!this[NO_DISPOSE_ON_SET])\n          this[DISPOSE](key, item.value)\n      }\n\n      item.now = now\n      item.maxAge = maxAge\n      item.value = value\n      this[LENGTH] += len - item.length\n      item.length = len\n      this.get(key)\n      trim(this)\n      return true\n    }\n\n    const hit = new Entry(key, value, len, now, maxAge)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > this[MAX]) {\n      if (this[DISPOSE])\n        this[DISPOSE](key, value)\n\n      return false\n    }\n\n    this[LENGTH] += hit.length\n    this[LRU_LIST].unshift(hit)\n    this[CACHE].set(key, this[LRU_LIST].head)\n    trim(this)\n    return true\n  }\n\n  has (key) {\n    if (!this[CACHE].has(key)) return false\n    const hit = this[CACHE].get(key).value\n    return !isStale(this, hit)\n  }\n\n  get (key) {\n    return get(this, key, true)\n  }\n\n  peek (key) {\n    return get(this, key, false)\n  }\n\n  pop () {\n    const node = this[LRU_LIST].tail\n    if (!node)\n      return null\n\n    del(this, node)\n    return node.value\n  }\n\n  del (key) {\n    del(this, this[CACHE].get(key))\n  }\n\n  load (arr) {\n    // reset the cache\n    this.reset()\n\n    const now = Date.now()\n    // A previous serialized cache has the most recent items first\n    for (let l = arr.length - 1; l >= 0; l--) {\n      const hit = arr[l]\n      const expiresAt = hit.e || 0\n      if (expiresAt === 0)\n        // the item was created without expiration in a non aged cache\n        this.set(hit.k, hit.v)\n      else {\n        const maxAge = expiresAt - now\n        // dont add already expired items\n        if (maxAge > 0) {\n          this.set(hit.k, hit.v, maxAge)\n        }\n      }\n    }\n  }\n\n  prune () {\n    this[CACHE].forEach((value, key) => get(this, key, false))\n  }\n}\n\nconst get = (self, key, doUse) => {\n  const node = self[CACHE].get(key)\n  if (node) {\n    const hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE])\n        return undefined\n    } else {\n      if (doUse) {\n        if (self[UPDATE_AGE_ON_GET])\n          node.value.now = Date.now()\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    return hit.value\n  }\n}\n\nconst isStale = (self, hit) => {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE]))\n    return false\n\n  const diff = Date.now() - hit.now\n  return hit.maxAge ? diff > hit.maxAge\n    : self[MAX_AGE] && (diff > self[MAX_AGE])\n}\n\nconst trim = self => {\n  if (self[LENGTH] > self[MAX]) {\n    for (let walker = self[LRU_LIST].tail;\n      self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      const prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nconst del = (self, node) => {\n  if (node) {\n    const hit = node.value\n    if (self[DISPOSE])\n      self[DISPOSE](hit.key, hit.value)\n\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\nclass Entry {\n  constructor (key, value, length, now, maxAge) {\n    this.key = key\n    this.value = value\n    this.length = length\n    this.now = now\n    this.maxAge = maxAge || 0\n  }\n}\n\nconst forEachStep = (self, fn, node, thisp) => {\n  let hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE])\n      hit = undefined\n  }\n  if (hit)\n    fn.call(thisp, hit.value, hit.key, self)\n}\n\nmodule.exports = LRUCache\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3REFBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QixrQkFBa0I7QUFDbEIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcz84NTZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld/node_modules/lru-cache/index.js\n");

/***/ })

};
;