/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jsonld-signatures";
exports.ids = ["vendor-chunks/jsonld-signatures"];
exports.modules = {

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/ProofSet.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/ProofSet.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"(ssr)/./node_modules/jsonld/lib/index.js\");\nconst {extendContextLoader, strictDocumentLoader} = __webpack_require__(/*! ./documentLoader */ \"(ssr)/./node_modules/jsonld-signatures/lib/documentLoader.js\");\nconst {serializeError} = __webpack_require__(/*! serialize-error */ \"(ssr)/./node_modules/serialize-error/index.js\");\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document to be signed.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({document});\n\n    // create the new proof\n    const proof = await suite.createProof({\n      document: input, purpose, proofSet, documentLoader\n    });\n\n    jsonld.addValue(document, 'proof', proof);\n\n    return document;\n  }\n\n  /**\n   * Derives a new Linked Data document with a new `proof` from an existing\n   * document with an existing proof set.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object} - JSON-LD Document from which to derive a proof.\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will derive the new document and new `proof`.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<object>} resolves with the new document, with a new\n   *   top-level `proof` property.\n   */\n  async derive(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    // shallow copy document to allow removal of existing proofs\n    const input = {...document};\n    delete input.proof;\n\n    // get existing proof set, if any\n    const proofSet = _getProofs({document});\n\n    // create the new document and proof\n    const newDocument = await suite.derive({\n      document: input, purpose, proofSet, documentLoader\n    });\n\n    return newDocument;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object} document - The JSON-LD document with one or more proofs to\n   *   be verified.\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {suite, purpose, documentLoader} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n\n    try {\n      // shallow copy to allow for removal of proof set prior to canonize\n      document = {...document};\n\n      // get proofs from document\n      const proofSet = _getProofs({document});\n      if(proofSet.length === 0) {\n        // no possible matches\n        throw new Error('No matching proofs found in the given document.');\n      }\n      // clear proofs from shallow copy\n      delete document.proof;\n\n      // verify proofs\n      const results = await _verify(\n        {document, suites, proofSet, purpose, documentLoader});\n      if(results.length === 0) {\n        const error = new Error(\n          'Did not verify any proofs; insufficient proofs matched the ' +\n          'acceptable suite(s) and required purpose(s).');\n        error.name = 'NotFoundError';\n        throw error;\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _makeSerializable(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nfunction _getProofs({document}) {\n  // handle document preprocessing to find proofs\n  let proofSet;\n  proofSet = jsonld.getValues(document, 'proof');\n\n  // shallow copy proofs and add document context or SECURITY_CONTEXT_URL\n  const context = document['@context'] || constants.SECURITY_CONTEXT_URL;\n  proofSet = proofSet.map(proof => {\n    const {cryptosuite} = proof;\n    // JCS Data Integrity Suites require unmodified proofs\n    if(cryptosuite?.includes?.('-jcs-')) {\n      return proof;\n    }\n    return {'@context': context, ...proof};\n  });\n\n  return proofSet;\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose, documentLoader\n}) {\n  // map each purpose to at least one proof to verify\n  const purposes = Array.isArray(purpose) ? purpose : [purpose];\n  const purposeToProofs = new Map();\n  const proofToSuite = new Map();\n  const suiteMatchQueue = new Map();\n  await Promise.all(purposes.map(purpose => _matchProofSet({\n    purposeToProofs, proofToSuite, purpose, proofSet, suites,\n    suiteMatchQueue, document, documentLoader\n  })));\n\n  // every purpose must have at least one matching proof or verify will fail\n  if(purposeToProofs.size < purposes.length) {\n    // insufficient proofs to verify, so don't bother verifying any\n    return [];\n  }\n\n  // verify every proof in `proofToSuite`; these proofs matched a purpose\n  const verifyResults = new Map();\n  await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {\n    let result;\n    try {\n      // create backwards-compatible deferred proof purpose to capture\n      // verification method from old-style suites\n      let vm;\n      const purpose = {\n        async validate(proof, {verificationMethod}) {\n          vm = verificationMethod;\n          return {valid: true};\n        }\n      };\n      const {verified, verificationMethod, error} = await suite.verifyProof(\n        {proof, document, purpose, proofSet, documentLoader});\n      if(!vm) {\n        vm = verificationMethod;\n      }\n      result = {proof, verified, verificationMethod: vm, error};\n    } catch(error) {\n      result = {proof, verified: false, error};\n    }\n\n    if(result.error) {\n      // ensure error is serializable\n      _makeSerializable(result.error);\n    }\n\n    verifyResults.set(proof, result);\n  }));\n\n  // validate proof against each purpose that matched it\n  await Promise.all([...purposeToProofs.entries()].map(\n    async ([purpose, proofs]) => {\n      for(const proof of proofs) {\n        const result = verifyResults.get(proof);\n        if(!result.verified) {\n          // if proof was not verified, so not bother validating purpose\n          continue;\n        }\n\n        // validate purpose\n        const {verificationMethod} = result;\n        const suite = proofToSuite.get(proof);\n        let purposeResult;\n        try {\n          purposeResult = await purpose.validate(proof, {\n            document, suite, verificationMethod, documentLoader\n          });\n        } catch(error) {\n          purposeResult = {valid: false, error};\n        }\n\n        // add `purposeResult` to verification result regardless of validity\n        // to ensure that all purposes are represented\n        if(result.purposeResult) {\n          if(Array.isArray(result.purposeResult)) {\n            result.purposeResult.push(purposeResult);\n          } else {\n            result.purposeResult = [result.purposeResult, purposeResult];\n          }\n        } else {\n          result.purposeResult = purposeResult;\n        }\n\n        if(!purposeResult.valid) {\n          // ensure error is serializable\n          _makeSerializable(purposeResult.error);\n\n          // if no top level error set yet, set it\n          if(!result.error) {\n            result.verified = false;\n            result.error = purposeResult.error;\n          }\n        }\n      }\n    }));\n\n  return [...verifyResults.values()];\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _makeSerializable(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _matchProofSet({\n  purposeToProofs, proofToSuite, purpose, proofSet, suites,\n  suiteMatchQueue, document, documentLoader\n}) {\n  for(const proof of proofSet) {\n    // first check if the proof matches the purpose; if it doesn't continue\n    if(!await purpose.match(proof, {document, documentLoader})) {\n      continue;\n    }\n\n    // next, find the suite that can verify the proof; if found, `matched`\n    // will be set to `true` and the proof will be added to `purposeToProofs`\n    // and `proofToSuite` to be processed -- otherwise it will not be; if\n    // no proofs are added for a given purpose, an exception will be thrown\n    let matched = false;\n    for(const s of suites) {\n      // `matchingProofs` is a map of promises that resolve to whether a\n      // proof matches a suite; multiple purposes and suites may be checked\n      // in parallel so a promise queue is used to prevent duplicate work\n      let matchingProofs = suiteMatchQueue.get(s);\n      if(!matchingProofs) {\n        suiteMatchQueue.set(s, matchingProofs = new Map());\n      }\n      let promise = matchingProofs.get(proof);\n      if(!promise) {\n        promise = s.matchProof({proof, document, documentLoader});\n        matchingProofs.set(proof, promise);\n      }\n      if(await promise) {\n        // found the matching suite for the proof; there should only be one\n        // suite that can verify a particular proof; add the proof to the\n        // map of proofs to be verified along with the matching suite\n        matched = true;\n        proofToSuite.set(proof, s);\n        break;\n      }\n    }\n\n    if(matched) {\n      // note proof was a match for the purpose and an acceptable suite; it\n      // will need to be verified by the suite and then validated against the\n      // purpose\n      const matches = purposeToProofs.get(purpose);\n      if(matches) {\n        matches.push(proof);\n      } else {\n        purposeToProofs.set(purpose, [proof]);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL1Byb29mU2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyx3REFBUTtBQUMvQixPQUFPLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsc0ZBQWtCO0FBQzlFLE9BQU8sZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBaUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQyxJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSxpQ0FBaUMsU0FBUzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0MsSUFBSTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0EsaUNBQWlDLFNBQVM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUyw0Q0FBNEMsR0FBRztBQUN0RTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQWdDLElBQUk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG9EQUFvRDtBQUM3RDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ047QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELFNBQVMsbURBQW1EO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixNQUFNO0FBQ04sZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHFEQUFxRDtBQUNyRCxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7O0FBRUEsdURBQXVEO0FBQ3ZEO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL1Byb29mU2V0LmpzPzM0MGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCBqc29ubGQgPSByZXF1aXJlKCdqc29ubGQnKTtcbmNvbnN0IHtleHRlbmRDb250ZXh0TG9hZGVyLCBzdHJpY3REb2N1bWVudExvYWRlcn0gPSByZXF1aXJlKCcuL2RvY3VtZW50TG9hZGVyJyk7XG5jb25zdCB7c2VyaWFsaXplRXJyb3J9ID0gcmVxdWlyZSgnc2VyaWFsaXplLWVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvb2ZTZXQge1xuICAvKipcbiAgICogQWRkcyBhIExpbmtlZCBEYXRhIHByb29mIHRvIGEgZG9jdW1lbnQuIElmIHRoZSBkb2N1bWVudCBjb250YWlucyBvdGhlclxuICAgKiBwcm9vZnMsIHRoZSBuZXcgcHJvb2Ygd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgZXhpc3Rpbmcgc2V0IG9mIHByb29mcy5cbiAgICpcbiAgICogSW1wb3J0YW50IG5vdGU6IFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdCB0aGUgdGVybSBgcHJvb2ZgIGluIHRoZSBnaXZlblxuICAgKiBkb2N1bWVudCBoYXMgdGhlIHNhbWUgZGVmaW5pdGlvbiBhcyB0aGUgYGh0dHBzOi8vdzNpZC5vcmcvc2VjdXJpdHkvdjJgXG4gICAqIEpTT04tTEQgQGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudCB7b2JqZWN0fSAtIEpTT04tTEQgRG9jdW1lbnQgdG8gYmUgc2lnbmVkLlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fSBPcHRpb25zIGhhc2htYXAuXG4gICAqXG4gICAqIEEgYHN1aXRlYCBvcHRpb24gaXMgcmVxdWlyZWQ6XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnN1aXRlIHtMaW5rZWREYXRhU2lnbmF0dXJlfSBhIHNpZ25hdHVyZSBzdWl0ZSBpbnN0YW5jZVxuICAgKiAgIHRoYXQgd2lsbCBjcmVhdGUgdGhlIHByb29mLlxuICAgKlxuICAgKiBBIGBwdXJwb3NlYCBvcHRpb24gaXMgcmVxdWlyZWQ6XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnB1cnBvc2Uge1Byb29mUHVycG9zZX0gYSBwcm9vZiBwdXJwb3NlIGluc3RhbmNlIHRoYXQgd2lsbFxuICAgKiAgIGF1Z21lbnQgdGhlIHByb29mIHdpdGggaW5mb3JtYXRpb24gZGVzY3JpYmluZyBpdHMgaW50ZW5kZWQgcHVycG9zZS5cbiAgICpcbiAgICogQWR2YW5jZWQgb3B0aW9uYWwgcGFyYW1ldGVycyBhbmQgb3ZlcnJpZGVzOlxuICAgKlxuICAgKiBAcGFyYW0gW2RvY3VtZW50TG9hZGVyXSB7ZnVuY3Rpb259IGEgY3VzdG9tIGRvY3VtZW50IGxvYWRlcixcbiAgICogICBgUHJvbWlzZTxSZW1vdGVEb2N1bWVudD4gZG9jdW1lbnRMb2FkZXIodXJsKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gcmVzb2x2ZXMgd2l0aCB0aGUgc2lnbmVkIGRvY3VtZW50LCB3aXRoXG4gICAqICAgdGhlIHNpZ25hdHVyZSBpbiB0aGUgdG9wLWxldmVsIGBwcm9vZmAgcHJvcGVydHkuXG4gICAqL1xuICBhc3luYyBhZGQoZG9jdW1lbnQsIHtzdWl0ZSwgcHVycG9zZSwgZG9jdW1lbnRMb2FkZXJ9ID0ge30pIHtcbiAgICBpZighc3VpdGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wib3B0aW9ucy5zdWl0ZVwiIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBpZighcHVycG9zZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnB1cnBvc2VcIiBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG5cbiAgICBpZihkb2N1bWVudExvYWRlcikge1xuICAgICAgZG9jdW1lbnRMb2FkZXIgPSBleHRlbmRDb250ZXh0TG9hZGVyKGRvY3VtZW50TG9hZGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnRMb2FkZXIgPSBzdHJpY3REb2N1bWVudExvYWRlcjtcbiAgICB9XG5cbiAgICAvLyBzaGFsbG93IGNvcHkgZG9jdW1lbnQgdG8gYWxsb3cgcmVtb3ZhbCBvZiBleGlzdGluZyBwcm9vZnNcbiAgICBjb25zdCBpbnB1dCA9IHsuLi5kb2N1bWVudH07XG4gICAgZGVsZXRlIGlucHV0LnByb29mO1xuXG4gICAgLy8gZ2V0IGV4aXN0aW5nIHByb29mIHNldCwgaWYgYW55XG4gICAgY29uc3QgcHJvb2ZTZXQgPSBfZ2V0UHJvb2ZzKHtkb2N1bWVudH0pO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBuZXcgcHJvb2ZcbiAgICBjb25zdCBwcm9vZiA9IGF3YWl0IHN1aXRlLmNyZWF0ZVByb29mKHtcbiAgICAgIGRvY3VtZW50OiBpbnB1dCwgcHVycG9zZSwgcHJvb2ZTZXQsIGRvY3VtZW50TG9hZGVyXG4gICAgfSk7XG5cbiAgICBqc29ubGQuYWRkVmFsdWUoZG9jdW1lbnQsICdwcm9vZicsIHByb29mKTtcblxuICAgIHJldHVybiBkb2N1bWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmVzIGEgbmV3IExpbmtlZCBEYXRhIGRvY3VtZW50IHdpdGggYSBuZXcgYHByb29mYCBmcm9tIGFuIGV4aXN0aW5nXG4gICAqIGRvY3VtZW50IHdpdGggYW4gZXhpc3RpbmcgcHJvb2Ygc2V0LlxuICAgKlxuICAgKiBJbXBvcnRhbnQgbm90ZTogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSB0ZXJtIGBwcm9vZmAgaW4gdGhlIGdpdmVuXG4gICAqIGRvY3VtZW50IGhhcyB0aGUgc2FtZSBkZWZpbml0aW9uIGFzIHRoZSBgaHR0cHM6Ly93M2lkLm9yZy9zZWN1cml0eS92MmBcbiAgICogSlNPTi1MRCBAY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIGRvY3VtZW50IHtvYmplY3R9IC0gSlNPTi1MRCBEb2N1bWVudCBmcm9tIHdoaWNoIHRvIGRlcml2ZSBhIHByb29mLlxuICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fSBPcHRpb25zIGhhc2htYXAuXG4gICAqXG4gICAqIEEgYHN1aXRlYCBvcHRpb24gaXMgcmVxdWlyZWQ6XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLnN1aXRlIHtMaW5rZWREYXRhU2lnbmF0dXJlfSBhIHNpZ25hdHVyZSBzdWl0ZSBpbnN0YW5jZVxuICAgKiAgIHRoYXQgd2lsbCBkZXJpdmUgdGhlIG5ldyBkb2N1bWVudCBhbmQgbmV3IGBwcm9vZmAuXG4gICAqXG4gICAqIEEgYHB1cnBvc2VgIG9wdGlvbiBpcyByZXF1aXJlZDpcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMucHVycG9zZSB7UHJvb2ZQdXJwb3NlfSBhIHByb29mIHB1cnBvc2UgaW5zdGFuY2UgdGhhdCB3aWxsXG4gICAqICAgYXVnbWVudCB0aGUgcHJvb2Ygd2l0aCBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIGl0cyBpbnRlbmRlZCBwdXJwb3NlLlxuICAgKlxuICAgKiBBZHZhbmNlZCBvcHRpb25hbCBwYXJhbWV0ZXJzIGFuZCBvdmVycmlkZXM6XG4gICAqXG4gICAqIEBwYXJhbSBbZG9jdW1lbnRMb2FkZXJdIHtmdW5jdGlvbn0gYSBjdXN0b20gZG9jdW1lbnQgbG9hZGVyLFxuICAgKiAgIGBQcm9taXNlPFJlbW90ZURvY3VtZW50PiBkb2N1bWVudExvYWRlcih1cmwpYC5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxvYmplY3Q+fSByZXNvbHZlcyB3aXRoIHRoZSBuZXcgZG9jdW1lbnQsIHdpdGggYSBuZXdcbiAgICogICB0b3AtbGV2ZWwgYHByb29mYCBwcm9wZXJ0eS5cbiAgICovXG4gIGFzeW5jIGRlcml2ZShkb2N1bWVudCwge3N1aXRlLCBwdXJwb3NlLCBkb2N1bWVudExvYWRlcn0gPSB7fSkge1xuICAgIGlmKCFzdWl0ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnN1aXRlXCIgaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuICAgIGlmKCFwdXJwb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMucHVycG9zZVwiIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIGlmKGRvY3VtZW50TG9hZGVyKSB7XG4gICAgICBkb2N1bWVudExvYWRlciA9IGV4dGVuZENvbnRleHRMb2FkZXIoZG9jdW1lbnRMb2FkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudExvYWRlciA9IHN0cmljdERvY3VtZW50TG9hZGVyO1xuICAgIH1cblxuICAgIC8vIHNoYWxsb3cgY29weSBkb2N1bWVudCB0byBhbGxvdyByZW1vdmFsIG9mIGV4aXN0aW5nIHByb29mc1xuICAgIGNvbnN0IGlucHV0ID0gey4uLmRvY3VtZW50fTtcbiAgICBkZWxldGUgaW5wdXQucHJvb2Y7XG5cbiAgICAvLyBnZXQgZXhpc3RpbmcgcHJvb2Ygc2V0LCBpZiBhbnlcbiAgICBjb25zdCBwcm9vZlNldCA9IF9nZXRQcm9vZnMoe2RvY3VtZW50fSk7XG5cbiAgICAvLyBjcmVhdGUgdGhlIG5ldyBkb2N1bWVudCBhbmQgcHJvb2ZcbiAgICBjb25zdCBuZXdEb2N1bWVudCA9IGF3YWl0IHN1aXRlLmRlcml2ZSh7XG4gICAgICBkb2N1bWVudDogaW5wdXQsIHB1cnBvc2UsIHByb29mU2V0LCBkb2N1bWVudExvYWRlclxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ld0RvY3VtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIExpbmtlZCBEYXRhIHByb29mKHMpIG9uIGEgZG9jdW1lbnQuIFRoZSBwcm9vZnMgdG8gYmUgdmVyaWZpZWRcbiAgICogbXVzdCBtYXRjaCB0aGUgZ2l2ZW4gcHJvb2YgcHVycG9zZS5cbiAgICpcbiAgICogSW1wb3J0YW50IG5vdGU6IFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdCB0aGUgdGVybSBgcHJvb2ZgIGluIHRoZSBnaXZlblxuICAgKiBkb2N1bWVudCBoYXMgdGhlIHNhbWUgZGVmaW5pdGlvbiBhcyB0aGUgYGh0dHBzOi8vdzNpZC5vcmcvc2VjdXJpdHkvdjJgXG4gICAqIEpTT04tTEQgQGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudCAtIFRoZSBKU09OLUxEIGRvY3VtZW50IHdpdGggb25lIG9yIG1vcmUgcHJvb2ZzIHRvXG4gICAqICAgYmUgdmVyaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7TGlua2VkRGF0YVNpZ25hdHVyZXxMaW5rZWREYXRhU2lnbmF0dXJlW119IHN1aXRlIC1cbiAgICogICBBY2NlcHRhYmxlIHNpZ25hdHVyZSBzdWl0ZSBpbnN0YW5jZXMgZm9yIHZlcmlmeWluZyB0aGUgcHJvb2YocykuXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvb2ZQdXJwb3NlfSBwdXJwb3NlIC0gQSBwcm9vZiBwdXJwb3NlIGluc3RhbmNlIHRoYXQgd2lsbFxuICAgKiAgIG1hdGNoIHByb29mcyB0byBiZSB2ZXJpZmllZCBhbmQgZW5zdXJlIHRoZXkgd2VyZSBjcmVhdGVkIGFjY29yZGluZyB0b1xuICAgKiAgIHRoZSBhcHByb3ByaWF0ZSBwdXJwb3NlLlxuICAgKlxuICAgKiBBZHZhbmNlZCBvcHRpb25hbCBwYXJhbWV0ZXJzIGFuZCBvdmVycmlkZXM6XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtkb2N1bWVudExvYWRlcl0gIGEgY3VzdG9tIGRvY3VtZW50IGxvYWRlcixcbiAgICogICBgUHJvbWlzZTxSZW1vdGVEb2N1bWVudD4gZG9jdW1lbnRMb2FkZXIodXJsKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8e3ZlcmlmaWVkOiBib29sZWFuLCByZXN1bHRzOiBBcnJheSwgZXJyb3I6ICp9Pn0gcmVzb2x2ZXNcbiAgICogICB3aXRoIGFuIG9iamVjdCB3aXRoIGEgYHZlcmlmaWVkYGJvb2xlYW4gcHJvcGVydHkgdGhhdCBpcyBgdHJ1ZWAgaWYgYXRcbiAgICogICBsZWFzdCBvbmUgcHJvb2YgbWF0Y2hpbmcgdGhlIGdpdmVuIHB1cnBvc2UgYW5kIHN1aXRlIHZlcmlmaWVzIGFuZCBgZmFsc2VgXG4gICAqICAgb3RoZXJ3aXNlOyBhIGByZXN1bHRzYCBwcm9wZXJ0eSB3aXRoIGFuIGFycmF5IG9mIGRldGFpbGVkIHJlc3VsdHM7XG4gICAqICAgaWYgYGZhbHNlYCBhbiBgZXJyb3JgIHByb3BlcnR5IHdpbGwgYmUgcHJlc2VudC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeShkb2N1bWVudCwge3N1aXRlLCBwdXJwb3NlLCBkb2N1bWVudExvYWRlcn0gPSB7fSkge1xuICAgIGlmKCFzdWl0ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJvcHRpb25zLnN1aXRlXCIgaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuICAgIGlmKCFwdXJwb3NlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm9wdGlvbnMucHVycG9zZVwiIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBjb25zdCBzdWl0ZXMgPSBBcnJheS5pc0FycmF5KHN1aXRlKSA/IHN1aXRlIDogW3N1aXRlXTtcbiAgICBpZihzdWl0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgc3VpdGUgaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuXG4gICAgaWYoZG9jdW1lbnRMb2FkZXIpIHtcbiAgICAgIGRvY3VtZW50TG9hZGVyID0gZXh0ZW5kQ29udGV4dExvYWRlcihkb2N1bWVudExvYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50TG9hZGVyID0gc3RyaWN0RG9jdW1lbnRMb2FkZXI7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHNoYWxsb3cgY29weSB0byBhbGxvdyBmb3IgcmVtb3ZhbCBvZiBwcm9vZiBzZXQgcHJpb3IgdG8gY2Fub25pemVcbiAgICAgIGRvY3VtZW50ID0gey4uLmRvY3VtZW50fTtcblxuICAgICAgLy8gZ2V0IHByb29mcyBmcm9tIGRvY3VtZW50XG4gICAgICBjb25zdCBwcm9vZlNldCA9IF9nZXRQcm9vZnMoe2RvY3VtZW50fSk7XG4gICAgICBpZihwcm9vZlNldC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gbm8gcG9zc2libGUgbWF0Y2hlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hdGNoaW5nIHByb29mcyBmb3VuZCBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnQuJyk7XG4gICAgICB9XG4gICAgICAvLyBjbGVhciBwcm9vZnMgZnJvbSBzaGFsbG93IGNvcHlcbiAgICAgIGRlbGV0ZSBkb2N1bWVudC5wcm9vZjtcblxuICAgICAgLy8gdmVyaWZ5IHByb29mc1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IF92ZXJpZnkoXG4gICAgICAgIHtkb2N1bWVudCwgc3VpdGVzLCBwcm9vZlNldCwgcHVycG9zZSwgZG9jdW1lbnRMb2FkZXJ9KTtcbiAgICAgIGlmKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICdEaWQgbm90IHZlcmlmeSBhbnkgcHJvb2ZzOyBpbnN1ZmZpY2llbnQgcHJvb2ZzIG1hdGNoZWQgdGhlICcgK1xuICAgICAgICAgICdhY2NlcHRhYmxlIHN1aXRlKHMpIGFuZCByZXF1aXJlZCBwdXJwb3NlKHMpLicpO1xuICAgICAgICBlcnJvci5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgLy8gY29tYmluZSByZXN1bHRzXG4gICAgICBjb25zdCB2ZXJpZmllZCA9IHJlc3VsdHMuc29tZShyID0+IHIudmVyaWZpZWQpO1xuICAgICAgaWYoIXZlcmlmaWVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdLmNvbmNhdChcbiAgICAgICAgICAuLi5yZXN1bHRzLmZpbHRlcihyID0+IHIuZXJyb3IpLm1hcChyID0+IHIuZXJyb3IpKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge3ZlcmlmaWVkLCByZXN1bHRzfTtcbiAgICAgICAgaWYoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXN1bHQuZXJyb3IgPSBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7dmVyaWZpZWQsIHJlc3VsdHN9O1xuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIF9tYWtlU2VyaWFsaXphYmxlKGVycm9yKTtcbiAgICAgIHJldHVybiB7dmVyaWZpZWQ6IGZhbHNlLCBlcnJvcn07XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfZ2V0UHJvb2ZzKHtkb2N1bWVudH0pIHtcbiAgLy8gaGFuZGxlIGRvY3VtZW50IHByZXByb2Nlc3NpbmcgdG8gZmluZCBwcm9vZnNcbiAgbGV0IHByb29mU2V0O1xuICBwcm9vZlNldCA9IGpzb25sZC5nZXRWYWx1ZXMoZG9jdW1lbnQsICdwcm9vZicpO1xuXG4gIC8vIHNoYWxsb3cgY29weSBwcm9vZnMgYW5kIGFkZCBkb2N1bWVudCBjb250ZXh0IG9yIFNFQ1VSSVRZX0NPTlRFWFRfVVJMXG4gIGNvbnN0IGNvbnRleHQgPSBkb2N1bWVudFsnQGNvbnRleHQnXSB8fCBjb25zdGFudHMuU0VDVVJJVFlfQ09OVEVYVF9VUkw7XG4gIHByb29mU2V0ID0gcHJvb2ZTZXQubWFwKHByb29mID0+IHtcbiAgICBjb25zdCB7Y3J5cHRvc3VpdGV9ID0gcHJvb2Y7XG4gICAgLy8gSkNTIERhdGEgSW50ZWdyaXR5IFN1aXRlcyByZXF1aXJlIHVubW9kaWZpZWQgcHJvb2ZzXG4gICAgaWYoY3J5cHRvc3VpdGU/LmluY2x1ZGVzPy4oJy1qY3MtJykpIHtcbiAgICAgIHJldHVybiBwcm9vZjtcbiAgICB9XG4gICAgcmV0dXJuIHsnQGNvbnRleHQnOiBjb250ZXh0LCAuLi5wcm9vZn07XG4gIH0pO1xuXG4gIHJldHVybiBwcm9vZlNldDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX3ZlcmlmeSh7XG4gIGRvY3VtZW50LCBzdWl0ZXMsIHByb29mU2V0LCBwdXJwb3NlLCBkb2N1bWVudExvYWRlclxufSkge1xuICAvLyBtYXAgZWFjaCBwdXJwb3NlIHRvIGF0IGxlYXN0IG9uZSBwcm9vZiB0byB2ZXJpZnlcbiAgY29uc3QgcHVycG9zZXMgPSBBcnJheS5pc0FycmF5KHB1cnBvc2UpID8gcHVycG9zZSA6IFtwdXJwb3NlXTtcbiAgY29uc3QgcHVycG9zZVRvUHJvb2ZzID0gbmV3IE1hcCgpO1xuICBjb25zdCBwcm9vZlRvU3VpdGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHN1aXRlTWF0Y2hRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwocHVycG9zZXMubWFwKHB1cnBvc2UgPT4gX21hdGNoUHJvb2ZTZXQoe1xuICAgIHB1cnBvc2VUb1Byb29mcywgcHJvb2ZUb1N1aXRlLCBwdXJwb3NlLCBwcm9vZlNldCwgc3VpdGVzLFxuICAgIHN1aXRlTWF0Y2hRdWV1ZSwgZG9jdW1lbnQsIGRvY3VtZW50TG9hZGVyXG4gIH0pKSk7XG5cbiAgLy8gZXZlcnkgcHVycG9zZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG1hdGNoaW5nIHByb29mIG9yIHZlcmlmeSB3aWxsIGZhaWxcbiAgaWYocHVycG9zZVRvUHJvb2ZzLnNpemUgPCBwdXJwb3Nlcy5sZW5ndGgpIHtcbiAgICAvLyBpbnN1ZmZpY2llbnQgcHJvb2ZzIHRvIHZlcmlmeSwgc28gZG9uJ3QgYm90aGVyIHZlcmlmeWluZyBhbnlcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyB2ZXJpZnkgZXZlcnkgcHJvb2YgaW4gYHByb29mVG9TdWl0ZWA7IHRoZXNlIHByb29mcyBtYXRjaGVkIGEgcHVycG9zZVxuICBjb25zdCB2ZXJpZnlSZXN1bHRzID0gbmV3IE1hcCgpO1xuICBhd2FpdCBQcm9taXNlLmFsbChbLi4ucHJvb2ZUb1N1aXRlLmVudHJpZXMoKV0ubWFwKGFzeW5jIChbcHJvb2YsIHN1aXRlXSkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGNyZWF0ZSBiYWNrd2FyZHMtY29tcGF0aWJsZSBkZWZlcnJlZCBwcm9vZiBwdXJwb3NlIHRvIGNhcHR1cmVcbiAgICAgIC8vIHZlcmlmaWNhdGlvbiBtZXRob2QgZnJvbSBvbGQtc3R5bGUgc3VpdGVzXG4gICAgICBsZXQgdm07XG4gICAgICBjb25zdCBwdXJwb3NlID0ge1xuICAgICAgICBhc3luYyB2YWxpZGF0ZShwcm9vZiwge3ZlcmlmaWNhdGlvbk1ldGhvZH0pIHtcbiAgICAgICAgICB2bSA9IHZlcmlmaWNhdGlvbk1ldGhvZDtcbiAgICAgICAgICByZXR1cm4ge3ZhbGlkOiB0cnVlfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHt2ZXJpZmllZCwgdmVyaWZpY2F0aW9uTWV0aG9kLCBlcnJvcn0gPSBhd2FpdCBzdWl0ZS52ZXJpZnlQcm9vZihcbiAgICAgICAge3Byb29mLCBkb2N1bWVudCwgcHVycG9zZSwgcHJvb2ZTZXQsIGRvY3VtZW50TG9hZGVyfSk7XG4gICAgICBpZighdm0pIHtcbiAgICAgICAgdm0gPSB2ZXJpZmljYXRpb25NZXRob2Q7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSB7cHJvb2YsIHZlcmlmaWVkLCB2ZXJpZmljYXRpb25NZXRob2Q6IHZtLCBlcnJvcn07XG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmVzdWx0ID0ge3Byb29mLCB2ZXJpZmllZDogZmFsc2UsIGVycm9yfTtcbiAgICB9XG5cbiAgICBpZihyZXN1bHQuZXJyb3IpIHtcbiAgICAgIC8vIGVuc3VyZSBlcnJvciBpcyBzZXJpYWxpemFibGVcbiAgICAgIF9tYWtlU2VyaWFsaXphYmxlKHJlc3VsdC5lcnJvcik7XG4gICAgfVxuXG4gICAgdmVyaWZ5UmVzdWx0cy5zZXQocHJvb2YsIHJlc3VsdCk7XG4gIH0pKTtcblxuICAvLyB2YWxpZGF0ZSBwcm9vZiBhZ2FpbnN0IGVhY2ggcHVycG9zZSB0aGF0IG1hdGNoZWQgaXRcbiAgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLnB1cnBvc2VUb1Byb29mcy5lbnRyaWVzKCldLm1hcChcbiAgICBhc3luYyAoW3B1cnBvc2UsIHByb29mc10pID0+IHtcbiAgICAgIGZvcihjb25zdCBwcm9vZiBvZiBwcm9vZnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmVyaWZ5UmVzdWx0cy5nZXQocHJvb2YpO1xuICAgICAgICBpZighcmVzdWx0LnZlcmlmaWVkKSB7XG4gICAgICAgICAgLy8gaWYgcHJvb2Ygd2FzIG5vdCB2ZXJpZmllZCwgc28gbm90IGJvdGhlciB2YWxpZGF0aW5nIHB1cnBvc2VcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkYXRlIHB1cnBvc2VcbiAgICAgICAgY29uc3Qge3ZlcmlmaWNhdGlvbk1ldGhvZH0gPSByZXN1bHQ7XG4gICAgICAgIGNvbnN0IHN1aXRlID0gcHJvb2ZUb1N1aXRlLmdldChwcm9vZik7XG4gICAgICAgIGxldCBwdXJwb3NlUmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHB1cnBvc2VSZXN1bHQgPSBhd2FpdCBwdXJwb3NlLnZhbGlkYXRlKHByb29mLCB7XG4gICAgICAgICAgICBkb2N1bWVudCwgc3VpdGUsIHZlcmlmaWNhdGlvbk1ldGhvZCwgZG9jdW1lbnRMb2FkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgIHB1cnBvc2VSZXN1bHQgPSB7dmFsaWQ6IGZhbHNlLCBlcnJvcn07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYHB1cnBvc2VSZXN1bHRgIHRvIHZlcmlmaWNhdGlvbiByZXN1bHQgcmVnYXJkbGVzcyBvZiB2YWxpZGl0eVxuICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCBhbGwgcHVycG9zZXMgYXJlIHJlcHJlc2VudGVkXG4gICAgICAgIGlmKHJlc3VsdC5wdXJwb3NlUmVzdWx0KSB7XG4gICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShyZXN1bHQucHVycG9zZVJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXJwb3NlUmVzdWx0LnB1c2gocHVycG9zZVJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXJwb3NlUmVzdWx0ID0gW3Jlc3VsdC5wdXJwb3NlUmVzdWx0LCBwdXJwb3NlUmVzdWx0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1cnBvc2VSZXN1bHQgPSBwdXJwb3NlUmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXB1cnBvc2VSZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgZXJyb3IgaXMgc2VyaWFsaXphYmxlXG4gICAgICAgICAgX21ha2VTZXJpYWxpemFibGUocHVycG9zZVJlc3VsdC5lcnJvcik7XG5cbiAgICAgICAgICAvLyBpZiBubyB0b3AgbGV2ZWwgZXJyb3Igc2V0IHlldCwgc2V0IGl0XG4gICAgICAgICAgaWYoIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0LnZlcmlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBwdXJwb3NlUmVzdWx0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcblxuICByZXR1cm4gWy4uLnZlcmlmeVJlc3VsdHMudmFsdWVzKCldO1xufVxuXG4vLyBhZGQgYSBgdG9KU09OYCBtZXRob2QgdG8gYW4gZXJyb3Igd2hpY2ggYWxsb3dzIGZvciBlcnJvcnMgaW4gdmFsaWRhdGlvblxuLy8gcmVwb3J0cyB0byBiZSBzZXJpYWxpemVkIHByb3Blcmx5IGJ5IGBKU09OLnN0cmluZ2lmeWAuXG5mdW5jdGlvbiBfbWFrZVNlcmlhbGl6YWJsZShlcnJvcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsICd0b0pTT04nLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZUVycm9yKHRoaXMpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfbWF0Y2hQcm9vZlNldCh7XG4gIHB1cnBvc2VUb1Byb29mcywgcHJvb2ZUb1N1aXRlLCBwdXJwb3NlLCBwcm9vZlNldCwgc3VpdGVzLFxuICBzdWl0ZU1hdGNoUXVldWUsIGRvY3VtZW50LCBkb2N1bWVudExvYWRlclxufSkge1xuICBmb3IoY29uc3QgcHJvb2Ygb2YgcHJvb2ZTZXQpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBpZiB0aGUgcHJvb2YgbWF0Y2hlcyB0aGUgcHVycG9zZTsgaWYgaXQgZG9lc24ndCBjb250aW51ZVxuICAgIGlmKCFhd2FpdCBwdXJwb3NlLm1hdGNoKHByb29mLCB7ZG9jdW1lbnQsIGRvY3VtZW50TG9hZGVyfSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIG5leHQsIGZpbmQgdGhlIHN1aXRlIHRoYXQgY2FuIHZlcmlmeSB0aGUgcHJvb2Y7IGlmIGZvdW5kLCBgbWF0Y2hlZGBcbiAgICAvLyB3aWxsIGJlIHNldCB0byBgdHJ1ZWAgYW5kIHRoZSBwcm9vZiB3aWxsIGJlIGFkZGVkIHRvIGBwdXJwb3NlVG9Qcm9vZnNgXG4gICAgLy8gYW5kIGBwcm9vZlRvU3VpdGVgIHRvIGJlIHByb2Nlc3NlZCAtLSBvdGhlcndpc2UgaXQgd2lsbCBub3QgYmU7IGlmXG4gICAgLy8gbm8gcHJvb2ZzIGFyZSBhZGRlZCBmb3IgYSBnaXZlbiBwdXJwb3NlLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd25cbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIGZvcihjb25zdCBzIG9mIHN1aXRlcykge1xuICAgICAgLy8gYG1hdGNoaW5nUHJvb2ZzYCBpcyBhIG1hcCBvZiBwcm9taXNlcyB0aGF0IHJlc29sdmUgdG8gd2hldGhlciBhXG4gICAgICAvLyBwcm9vZiBtYXRjaGVzIGEgc3VpdGU7IG11bHRpcGxlIHB1cnBvc2VzIGFuZCBzdWl0ZXMgbWF5IGJlIGNoZWNrZWRcbiAgICAgIC8vIGluIHBhcmFsbGVsIHNvIGEgcHJvbWlzZSBxdWV1ZSBpcyB1c2VkIHRvIHByZXZlbnQgZHVwbGljYXRlIHdvcmtcbiAgICAgIGxldCBtYXRjaGluZ1Byb29mcyA9IHN1aXRlTWF0Y2hRdWV1ZS5nZXQocyk7XG4gICAgICBpZighbWF0Y2hpbmdQcm9vZnMpIHtcbiAgICAgICAgc3VpdGVNYXRjaFF1ZXVlLnNldChzLCBtYXRjaGluZ1Byb29mcyA9IG5ldyBNYXAoKSk7XG4gICAgICB9XG4gICAgICBsZXQgcHJvbWlzZSA9IG1hdGNoaW5nUHJvb2ZzLmdldChwcm9vZik7XG4gICAgICBpZighcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gcy5tYXRjaFByb29mKHtwcm9vZiwgZG9jdW1lbnQsIGRvY3VtZW50TG9hZGVyfSk7XG4gICAgICAgIG1hdGNoaW5nUHJvb2ZzLnNldChwcm9vZiwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgICBpZihhd2FpdCBwcm9taXNlKSB7XG4gICAgICAgIC8vIGZvdW5kIHRoZSBtYXRjaGluZyBzdWl0ZSBmb3IgdGhlIHByb29mOyB0aGVyZSBzaG91bGQgb25seSBiZSBvbmVcbiAgICAgICAgLy8gc3VpdGUgdGhhdCBjYW4gdmVyaWZ5IGEgcGFydGljdWxhciBwcm9vZjsgYWRkIHRoZSBwcm9vZiB0byB0aGVcbiAgICAgICAgLy8gbWFwIG9mIHByb29mcyB0byBiZSB2ZXJpZmllZCBhbG9uZyB3aXRoIHRoZSBtYXRjaGluZyBzdWl0ZVxuICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvb2ZUb1N1aXRlLnNldChwcm9vZiwgcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKG1hdGNoZWQpIHtcbiAgICAgIC8vIG5vdGUgcHJvb2Ygd2FzIGEgbWF0Y2ggZm9yIHRoZSBwdXJwb3NlIGFuZCBhbiBhY2NlcHRhYmxlIHN1aXRlOyBpdFxuICAgICAgLy8gd2lsbCBuZWVkIHRvIGJlIHZlcmlmaWVkIGJ5IHRoZSBzdWl0ZSBhbmQgdGhlbiB2YWxpZGF0ZWQgYWdhaW5zdCB0aGVcbiAgICAgIC8vIHB1cnBvc2VcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBwdXJwb3NlVG9Qcm9vZnMuZ2V0KHB1cnBvc2UpO1xuICAgICAgaWYobWF0Y2hlcykge1xuICAgICAgICBtYXRjaGVzLnB1c2gocHJvb2YpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVycG9zZVRvUHJvb2ZzLnNldChwdXJwb3NlLCBbcHJvb2ZdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/ProofSet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/VerificationError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/VerificationError.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/**\n * Used as an umbrella wrapper around multiple verification errors.\n */\nclass VerificationError extends Error {\n  /**\n   * @param {Error|Error[]} errors\n   */\n  constructor(errors) {\n    super('Verification error(s).');\n\n    this.name = 'VerificationError';\n    this.errors = [].concat(errors);\n  }\n}\nmodule.exports = VerificationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL1ZlcmlmaWNhdGlvbkVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL1ZlcmlmaWNhdGlvbkVycm9yLmpzPzMwYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZWQgYXMgYW4gdW1icmVsbGEgd3JhcHBlciBhcm91bmQgbXVsdGlwbGUgdmVyaWZpY2F0aW9uIGVycm9ycy5cbiAqL1xuY2xhc3MgVmVyaWZpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfEVycm9yW119IGVycm9yc1xuICAgKi9cbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgc3VwZXIoJ1ZlcmlmaWNhdGlvbiBlcnJvcihzKS4nKTtcblxuICAgIHRoaXMubmFtZSA9ICdWZXJpZmljYXRpb25FcnJvcic7XG4gICAgdGhpcy5lcnJvcnMgPSBbXS5jb25jYXQoZXJyb3JzKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBWZXJpZmljYXRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/VerificationError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/constants.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst {\n  constants: securityConstants\n} = __webpack_require__(/*! @digitalbazaar/security-context */ \"(ssr)/./node_modules/@digitalbazaar/security-context/dist/context.esm.js\");\n\nmodule.exports = {\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUhBQWlDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9saWIvY29uc3RhbnRzLmpzP2U1YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctMjAyMyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgY29uc3RhbnRzOiBzZWN1cml0eUNvbnN0YW50c1xufSA9IHJlcXVpcmUoJ0BkaWdpdGFsYmF6YWFyL3NlY3VyaXR5LWNvbnRleHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFQ1VSSVRZX0NPTlRFWFRfVVJMOiBzZWN1cml0eUNvbnN0YW50cy5TRUNVUklUWV9DT05URVhUX1YyX1VSTCxcbiAgU0VDVVJJVFlfQ09OVEVYVF9WMV9VUkw6IHNlY3VyaXR5Q29uc3RhbnRzLlNFQ1VSSVRZX0NPTlRFWFRfVjFfVVJMLFxuICBTRUNVUklUWV9DT05URVhUX1YyX1VSTDogc2VjdXJpdHlDb25zdGFudHMuU0VDVVJJVFlfQ09OVEVYVF9WMl9VUkwsXG4gIFNFQ1VSSVRZX1BST09GX1VSTDogJ2h0dHBzOi8vdzNpZC5vcmcvc2VjdXJpdHkjcHJvb2YnLFxuICBTRUNVUklUWV9TSUdOQVRVUkVfVVJMOiAnaHR0cHM6Ly93M2lkLm9yZy9zZWN1cml0eSNzaWduYXR1cmUnXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/contexts.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/contexts.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/jsonld-signatures/lib/constants.js\");\nconst {contexts: securityContexts} = __webpack_require__(/*! @digitalbazaar/security-context */ \"(ssr)/./node_modules/@digitalbazaar/security-context/dist/context.esm.js\");\n\nmodule.exports = new Map([\n  [constants.SECURITY_CONTEXT_V1_URL,\n    securityContexts.get(constants.SECURITY_CONTEXT_V1_URL)],\n  [constants.SECURITY_CONTEXT_V2_URL,\n    securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)]\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL2NvbnRleHRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZDLE9BQU8sNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyxpSEFBaUM7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9saWIvY29udGV4dHMuanM/MTMzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNy0yMDIzIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHtjb250ZXh0czogc2VjdXJpdHlDb250ZXh0c30gPSByZXF1aXJlKCdAZGlnaXRhbGJhemFhci9zZWN1cml0eS1jb250ZXh0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IE1hcChbXG4gIFtjb25zdGFudHMuU0VDVVJJVFlfQ09OVEVYVF9WMV9VUkwsXG4gICAgc2VjdXJpdHlDb250ZXh0cy5nZXQoY29uc3RhbnRzLlNFQ1VSSVRZX0NPTlRFWFRfVjFfVVJMKV0sXG4gIFtjb25zdGFudHMuU0VDVVJJVFlfQ09OVEVYVF9WMl9VUkwsXG4gICAgc2VjdXJpdHlDb250ZXh0cy5nZXQoY29uc3RhbnRzLlNFQ1VSSVRZX0NPTlRFWFRfVjJfVVJMKV1cbl0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/contexts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/documentLoader.js":
/*!**************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/documentLoader.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/*eslint max-len: [\"error\", { \"ignoreComments\": true }]*/\n\n// load locally embedded contexts\nconst contexts = __webpack_require__(/*! ./contexts */ \"(ssr)/./node_modules/jsonld-signatures/lib/contexts.js\");\n\n/**\n * This is a utility module that provides a set of functions for using or\n * extending jsonld-signature's built-in JSON-LD document loader.\n * @see https://www.w3.org/TR/json-ld11-api/#loaddocumentcallback\n */\nconst api = {};\nmodule.exports = api;\n\napi.extendContextLoader = documentLoader => {\n  /**\n   * extendContextLoader extends another JSON-LD document loader.\n   * Given a document loader to extend, this method will return a\n   * new document loader that will first check for a URL in\n   * jsonld-signature's built-in context map and, if not found,\n   * it will fall back to using the passed document loader.\n   * This utility method can be used to ensure that any local,\n   * in-memory, immutable context documents provided by\n   * jsonld-signatures will be used prior to using another\n   * document loader to load other documents.\n   *\n   * @param {Function} documentLoader - A function that fetches a document.\n   * @see [node documentLoader example]{@link https://github.com/digitalbazaar/jsonld.js/blob/master/lib/documentLoaders/node.js}\n   * @see [xhr documentLoader example]{@link https://github.com/digitalbazaar/jsonld.js/blob/master/lib/documentLoaders/xhr.js}\n   *\n   * @returns {Function} A function that accepts a\n   * url then fetches a jsonld document.\n   */\n  return async url => {\n    const context = contexts.get(url);\n    if(context !== undefined) {\n      return {\n        contextUrl: null,\n        documentUrl: url,\n        document: context,\n        tag: 'static'\n      };\n    }\n    return documentLoader(url);\n  };\n};\n\napi.strictDocumentLoader = api.extendContextLoader(url => {\n  /**\n   * strictDocumentLoader extends extendContextLoader.\n   * ensuring no network calls are made so the only documents\n   * available are the built-in contexts.\n   * @see documentLoader.extendContextLoader\n   *\n   * @param {string} url - A valid url to a jsonld context.\n   *\n   * @throws {Error} Always throws an error if the\n   * url is not in the context map\n   * (i.e., not a URL for a locally available context document).\n   * @return {Object} A JSON-LD RemoteDocument\n   * that is a copy of a locally available context.\n   */\n  throw new Error(`${url} not found.`);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL2RvY3VtZW50TG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDhCQUE4Qix3QkFBd0I7O0FBRXREO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2Qix3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL2xpYi9kb2N1bWVudExvYWRlci5qcz8wZmU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE4LTIwMjEgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludCBtYXgtbGVuOiBbXCJlcnJvclwiLCB7IFwiaWdub3JlQ29tbWVudHNcIjogdHJ1ZSB9XSovXG5cbi8vIGxvYWQgbG9jYWxseSBlbWJlZGRlZCBjb250ZXh0c1xuY29uc3QgY29udGV4dHMgPSByZXF1aXJlKCcuL2NvbnRleHRzJyk7XG5cbi8qKlxuICogVGhpcyBpcyBhIHV0aWxpdHkgbW9kdWxlIHRoYXQgcHJvdmlkZXMgYSBzZXQgb2YgZnVuY3Rpb25zIGZvciB1c2luZyBvclxuICogZXh0ZW5kaW5nIGpzb25sZC1zaWduYXR1cmUncyBidWlsdC1pbiBKU09OLUxEIGRvY3VtZW50IGxvYWRlci5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2pzb24tbGQxMS1hcGkvI2xvYWRkb2N1bWVudGNhbGxiYWNrXG4gKi9cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbmFwaS5leHRlbmRDb250ZXh0TG9hZGVyID0gZG9jdW1lbnRMb2FkZXIgPT4ge1xuICAvKipcbiAgICogZXh0ZW5kQ29udGV4dExvYWRlciBleHRlbmRzIGFub3RoZXIgSlNPTi1MRCBkb2N1bWVudCBsb2FkZXIuXG4gICAqIEdpdmVuIGEgZG9jdW1lbnQgbG9hZGVyIHRvIGV4dGVuZCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYVxuICAgKiBuZXcgZG9jdW1lbnQgbG9hZGVyIHRoYXQgd2lsbCBmaXJzdCBjaGVjayBmb3IgYSBVUkwgaW5cbiAgICoganNvbmxkLXNpZ25hdHVyZSdzIGJ1aWx0LWluIGNvbnRleHQgbWFwIGFuZCwgaWYgbm90IGZvdW5kLFxuICAgKiBpdCB3aWxsIGZhbGwgYmFjayB0byB1c2luZyB0aGUgcGFzc2VkIGRvY3VtZW50IGxvYWRlci5cbiAgICogVGhpcyB1dGlsaXR5IG1ldGhvZCBjYW4gYmUgdXNlZCB0byBlbnN1cmUgdGhhdCBhbnkgbG9jYWwsXG4gICAqIGluLW1lbW9yeSwgaW1tdXRhYmxlIGNvbnRleHQgZG9jdW1lbnRzIHByb3ZpZGVkIGJ5XG4gICAqIGpzb25sZC1zaWduYXR1cmVzIHdpbGwgYmUgdXNlZCBwcmlvciB0byB1c2luZyBhbm90aGVyXG4gICAqIGRvY3VtZW50IGxvYWRlciB0byBsb2FkIG90aGVyIGRvY3VtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9jdW1lbnRMb2FkZXIgLSBBIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBhIGRvY3VtZW50LlxuICAgKiBAc2VlIFtub2RlIGRvY3VtZW50TG9hZGVyIGV4YW1wbGVde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9kaWdpdGFsYmF6YWFyL2pzb25sZC5qcy9ibG9iL21hc3Rlci9saWIvZG9jdW1lbnRMb2FkZXJzL25vZGUuanN9XG4gICAqIEBzZWUgW3hociBkb2N1bWVudExvYWRlciBleGFtcGxlXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZGlnaXRhbGJhemFhci9qc29ubGQuanMvYmxvYi9tYXN0ZXIvbGliL2RvY3VtZW50TG9hZGVycy94aHIuanN9XG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYVxuICAgKiB1cmwgdGhlbiBmZXRjaGVzIGEganNvbmxkIGRvY3VtZW50LlxuICAgKi9cbiAgcmV0dXJuIGFzeW5jIHVybCA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IGNvbnRleHRzLmdldCh1cmwpO1xuICAgIGlmKGNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dFVybDogbnVsbCxcbiAgICAgICAgZG9jdW1lbnRVcmw6IHVybCxcbiAgICAgICAgZG9jdW1lbnQ6IGNvbnRleHQsXG4gICAgICAgIHRhZzogJ3N0YXRpYydcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudExvYWRlcih1cmwpO1xuICB9O1xufTtcblxuYXBpLnN0cmljdERvY3VtZW50TG9hZGVyID0gYXBpLmV4dGVuZENvbnRleHRMb2FkZXIodXJsID0+IHtcbiAgLyoqXG4gICAqIHN0cmljdERvY3VtZW50TG9hZGVyIGV4dGVuZHMgZXh0ZW5kQ29udGV4dExvYWRlci5cbiAgICogZW5zdXJpbmcgbm8gbmV0d29yayBjYWxscyBhcmUgbWFkZSBzbyB0aGUgb25seSBkb2N1bWVudHNcbiAgICogYXZhaWxhYmxlIGFyZSB0aGUgYnVpbHQtaW4gY29udGV4dHMuXG4gICAqIEBzZWUgZG9jdW1lbnRMb2FkZXIuZXh0ZW5kQ29udGV4dExvYWRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gQSB2YWxpZCB1cmwgdG8gYSBqc29ubGQgY29udGV4dC5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IEFsd2F5cyB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlXG4gICAqIHVybCBpcyBub3QgaW4gdGhlIGNvbnRleHQgbWFwXG4gICAqIChpLmUuLCBub3QgYSBVUkwgZm9yIGEgbG9jYWxseSBhdmFpbGFibGUgY29udGV4dCBkb2N1bWVudCkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gQSBKU09OLUxEIFJlbW90ZURvY3VtZW50XG4gICAqIHRoYXQgaXMgYSBjb3B5IG9mIGEgbG9jYWxseSBhdmFpbGFibGUgY29udGV4dC5cbiAgICovXG4gIHRocm93IG5ldyBFcnJvcihgJHt1cmx9IG5vdCBmb3VuZC5gKTtcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/documentLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/jsonld-signatures.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/jsonld-signatures.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2010-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/jsonld-signatures/lib/constants.js\");\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = __webpack_require__(/*! ./ProofSet */ \"(ssr)/./node_modules/jsonld-signatures/lib/ProofSet.js\");\nconst VerificationError = __webpack_require__(/*! ./VerificationError */ \"(ssr)/./node_modules/jsonld-signatures/lib/VerificationError.js\");\n\n/**\n * Derives a proof from the provided document, resulting in a new document\n * with a new `proof` on it as generated by the given cryptographic suite.\n *\n * @param {object} document - The JSON-LD document from which to derive a\n *   new proof.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite, containing private key material, with which to sign\n *   the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.derive = async function derive(document, {\n  suite, purpose, documentLoader, addSuiteContext = true\n} = {}) {\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the\n  // `addSuiteContext` flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().derive(\n      document, {suite, purpose, documentLoader});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"derive\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object} document - The JSON-LD document to be signed.\n *\n * @param {object} options - Options hashmap.\n * @param {LinkedDataSignature} options.suite - The linked data signature\n *   cryptographic suite with which to sign the document.\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * @param {function} documentLoader  - A secure document loader (it is\n *   recommended to use one that provides static known documents, instead of\n *   fetching from the web) for returning contexts, controller documents, keys,\n *   and other relevant URLs needed for the proof.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n * @param {boolean} [options.addSuiteContext=true] - Toggles the default\n *   behavior of each signature suite enforcing the presence of its own\n *   `@context` (if it is not present, it's added to the context list).\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, addSuiteContext = true\n} = {}) {\n  if(expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  // Ensure document contains the signature suite specific context URL\n  // or throw an error (in case an advanced user overrides the `addSuiteContext`\n  // flag to false).\n  suite.ensureSuiteContext({document, addSuiteContext});\n\n  try {\n    return await new ProofSet().add(document, {suite, purpose, documentLoader});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object} document - The JSON-LD document with one or more proofs to be\n *   verified.\n *\n * @param {object} options - The options to use.\n * @param {LinkedDataSignature|LinkedDataSignature[]} options.suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [options.documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [options.expansionMap] - NOT SUPPORTED; do not use.\n *\n * @return {Promise<{verified: boolean, results: Array,\n *   error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap\n} = {}) {\n  if(expansionMap) {\n    throw new Error('\"expansionMap\" not supported.');\n  }\n  if(typeof document !== 'object') {\n    throw new TypeError('The \"document\" parameter must be an object.');\n  }\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader});\n  const {error} = result;\n  if(error) {\n    if(!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = (__webpack_require__(/*! ./suites */ \"(ssr)/./node_modules/jsonld-signatures/lib/suites.js\").suites);\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = (__webpack_require__(/*! ./purposes */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes.js\").purposes);\n\n// expose document loader helpers\nObject.assign(api, __webpack_require__(/*! ./documentLoader */ \"(ssr)/./node_modules/jsonld-signatures/lib/documentLoader.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL2pzb25sZC1zaWduYXR1cmVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZDOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVk7QUFDckMsMEJBQTBCLG1CQUFPLENBQUMsNEZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLHdDQUF3QztBQUM3RCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjs7QUFFdEQ7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQsSUFBSTtBQUNKO0FBQ0EsYUFBYSxVQUFVLE1BQU07QUFDN0I7QUFDQSxrQkFBa0IsSUFBSSx3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVLHdDQUF3QztBQUM3RCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjs7QUFFdEQ7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFLElBQUk7QUFDSjtBQUNBLGFBQWEsVUFBVSxNQUFNO0FBQzdCO0FBQ0Esa0JBQWtCLElBQUksd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsMkNBQTJDO0FBQ3REO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFdBQVcsVUFBVSx3Q0FBd0M7QUFDN0Q7QUFDQSxZQUFZLFNBQVM7QUFDckIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhLFVBQVUsTUFBTTtBQUM3QjtBQUNBLGtCQUFrQixJQUFJLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLG9HQUEwQjs7QUFFdkM7QUFDQSxlQUFlLDBHQUE4Qjs7QUFFN0M7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL2pzb25sZC1zaWduYXR1cmVzLmpzPzc1NWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAyMyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qIENvcmUgQVBJICovXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKiBBUEkgQ29uc3RhbnRzICovXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuT2JqZWN0LmFzc2lnbihhcGksIGNvbnN0YW50cyk7XG5cbi8vIFRPRE86IHN1cHBvcnQgYFByb29mQ2hhaW5gXG5jb25zdCBQcm9vZlNldCA9IHJlcXVpcmUoJy4vUHJvb2ZTZXQnKTtcbmNvbnN0IFZlcmlmaWNhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9WZXJpZmljYXRpb25FcnJvcicpO1xuXG4vKipcbiAqIERlcml2ZXMgYSBwcm9vZiBmcm9tIHRoZSBwcm92aWRlZCBkb2N1bWVudCwgcmVzdWx0aW5nIGluIGEgbmV3IGRvY3VtZW50XG4gKiB3aXRoIGEgbmV3IGBwcm9vZmAgb24gaXQgYXMgZ2VuZXJhdGVkIGJ5IHRoZSBnaXZlbiBjcnlwdG9ncmFwaGljIHN1aXRlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudCAtIFRoZSBKU09OLUxEIGRvY3VtZW50IGZyb20gd2hpY2ggdG8gZGVyaXZlIGFcbiAqICAgbmV3IHByb29mLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBoYXNobWFwLlxuICogQHBhcmFtIHtMaW5rZWREYXRhU2lnbmF0dXJlfSBvcHRpb25zLnN1aXRlIC0gVGhlIGxpbmtlZCBkYXRhIHNpZ25hdHVyZVxuICogICBjcnlwdG9ncmFwaGljIHN1aXRlLCBjb250YWluaW5nIHByaXZhdGUga2V5IG1hdGVyaWFsLCB3aXRoIHdoaWNoIHRvIHNpZ25cbiAqICAgdGhlIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7UHJvb2ZQdXJwb3NlfSBwdXJwb3NlIC0gQSBwcm9vZiBwdXJwb3NlIGluc3RhbmNlIHRoYXQgd2lsbFxuICogICBtYXRjaCBwcm9vZnMgdG8gYmUgdmVyaWZpZWQgYW5kIGVuc3VyZSB0aGV5IHdlcmUgY3JlYXRlZCBhY2NvcmRpbmcgdG9cbiAqICAgdGhlIGFwcHJvcHJpYXRlIHB1cnBvc2UuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZG9jdW1lbnRMb2FkZXIgIC0gQSBzZWN1cmUgZG9jdW1lbnQgbG9hZGVyIChpdCBpc1xuICogICByZWNvbW1lbmRlZCB0byB1c2Ugb25lIHRoYXQgcHJvdmlkZXMgc3RhdGljIGtub3duIGRvY3VtZW50cywgaW5zdGVhZCBvZlxuICogICBmZXRjaGluZyBmcm9tIHRoZSB3ZWIpIGZvciByZXR1cm5pbmcgY29udGV4dHMsIGNvbnRyb2xsZXIgZG9jdW1lbnRzLCBrZXlzLFxuICogICBhbmQgb3RoZXIgcmVsZXZhbnQgVVJMcyBuZWVkZWQgZm9yIHRoZSBwcm9vZi5cbiAqXG4gKiBBZHZhbmNlZCBvcHRpb25hbCBwYXJhbWV0ZXJzIGFuZCBvdmVycmlkZXM6XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuZXhwYW5zaW9uTWFwXSAtIE5PVCBTVVBQT1JURUQ7IGRvIG5vdCB1c2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZFN1aXRlQ29udGV4dD10cnVlXSAtIFRvZ2dsZXMgdGhlIGRlZmF1bHRcbiAqICAgYmVoYXZpb3Igb2YgZWFjaCBzaWduYXR1cmUgc3VpdGUgZW5mb3JjaW5nIHRoZSBwcmVzZW5jZSBvZiBpdHMgb3duXG4gKiAgIGBAY29udGV4dGAgKGlmIGl0IGlzIG5vdCBwcmVzZW50LCBpdCdzIGFkZGVkIHRvIHRoZSBjb250ZXh0IGxpc3QpLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFJlc29sdmVzIHdpdGggc2lnbmVkIGRvY3VtZW50LlxuICovXG5hcGkuZGVyaXZlID0gYXN5bmMgZnVuY3Rpb24gZGVyaXZlKGRvY3VtZW50LCB7XG4gIHN1aXRlLCBwdXJwb3NlLCBkb2N1bWVudExvYWRlciwgYWRkU3VpdGVDb250ZXh0ID0gdHJ1ZVxufSA9IHt9KSB7XG4gIGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJkb2N1bWVudFwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuICAvLyBFbnN1cmUgZG9jdW1lbnQgY29udGFpbnMgdGhlIHNpZ25hdHVyZSBzdWl0ZSBzcGVjaWZpYyBjb250ZXh0IFVSTFxuICAvLyBvciB0aHJvdyBhbiBlcnJvciAoaW4gY2FzZSBhbiBhZHZhbmNlZCB1c2VyIG92ZXJyaWRlcyB0aGVcbiAgLy8gYGFkZFN1aXRlQ29udGV4dGAgZmxhZyB0byBmYWxzZSkuXG4gIHN1aXRlLmVuc3VyZVN1aXRlQ29udGV4dCh7ZG9jdW1lbnQsIGFkZFN1aXRlQ29udGV4dH0pO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9vZlNldCgpLmRlcml2ZShcbiAgICAgIGRvY3VtZW50LCB7c3VpdGUsIHB1cnBvc2UsIGRvY3VtZW50TG9hZGVyfSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmKCFkb2N1bWVudExvYWRlciAmJiBlLm5hbWUgPT09ICdqc29ubGQuSW52YWxpZFVybCcpIHtcbiAgICAgIGNvbnN0IHtkZXRhaWxzOiB7dXJsfX0gPSBlO1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICBgQSBVUkwgXCIke3VybH1cIiBjb3VsZCBub3QgYmUgZmV0Y2hlZDsgeW91IG5lZWQgdG8gcGFzcyBgICtcbiAgICAgICAgJ1wiZG9jdW1lbnRMb2FkZXJcIiBvciByZXNvbHZlIHRoZSBVUkwgYmVmb3JlIGNhbGxpbmcgXCJkZXJpdmVcIi4nKTtcbiAgICAgIGVyci5jYXVzZSA9IGU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbn07XG5cbi8qKlxuICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2lnbnMgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGJ5IGFkZGluZyBhIGBwcm9vZmAgc2VjdGlvbixcbiAqIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzdWl0ZSBhbmQgcHJvb2YgcHVycG9zZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZG9jdW1lbnQgLSBUaGUgSlNPTi1MRCBkb2N1bWVudCB0byBiZSBzaWduZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGhhc2htYXAuXG4gKiBAcGFyYW0ge0xpbmtlZERhdGFTaWduYXR1cmV9IG9wdGlvbnMuc3VpdGUgLSBUaGUgbGlua2VkIGRhdGEgc2lnbmF0dXJlXG4gKiAgIGNyeXB0b2dyYXBoaWMgc3VpdGUgd2l0aCB3aGljaCB0byBzaWduIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge1Byb29mUHVycG9zZX0gcHVycG9zZSAtIEEgcHJvb2YgcHVycG9zZSBpbnN0YW5jZSB0aGF0IHdpbGxcbiAqICAgbWF0Y2ggcHJvb2ZzIHRvIGJlIHZlcmlmaWVkIGFuZCBlbnN1cmUgdGhleSB3ZXJlIGNyZWF0ZWQgYWNjb3JkaW5nIHRvXG4gKiAgIHRoZSBhcHByb3ByaWF0ZSBwdXJwb3NlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvY3VtZW50TG9hZGVyICAtIEEgc2VjdXJlIGRvY3VtZW50IGxvYWRlciAoaXQgaXNcbiAqICAgcmVjb21tZW5kZWQgdG8gdXNlIG9uZSB0aGF0IHByb3ZpZGVzIHN0YXRpYyBrbm93biBkb2N1bWVudHMsIGluc3RlYWQgb2ZcbiAqICAgZmV0Y2hpbmcgZnJvbSB0aGUgd2ViKSBmb3IgcmV0dXJuaW5nIGNvbnRleHRzLCBjb250cm9sbGVyIGRvY3VtZW50cywga2V5cyxcbiAqICAgYW5kIG90aGVyIHJlbGV2YW50IFVSTHMgbmVlZGVkIGZvciB0aGUgcHJvb2YuXG4gKlxuICogQWR2YW5jZWQgb3B0aW9uYWwgcGFyYW1ldGVycyBhbmQgb3ZlcnJpZGVzOlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmV4cGFuc2lvbk1hcF0gLSBOT1QgU1VQUE9SVEVEOyBkbyBub3QgdXNlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRTdWl0ZUNvbnRleHQ9dHJ1ZV0gLSBUb2dnbGVzIHRoZSBkZWZhdWx0XG4gKiAgIGJlaGF2aW9yIG9mIGVhY2ggc2lnbmF0dXJlIHN1aXRlIGVuZm9yY2luZyB0aGUgcHJlc2VuY2Ugb2YgaXRzIG93blxuICogICBgQGNvbnRleHRgIChpZiBpdCBpcyBub3QgcHJlc2VudCwgaXQncyBhZGRlZCB0byB0aGUgY29udGV4dCBsaXN0KS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNvbHZlcyB3aXRoIHNpZ25lZCBkb2N1bWVudC5cbiAqL1xuYXBpLnNpZ24gPSBhc3luYyBmdW5jdGlvbiBzaWduKGRvY3VtZW50LCB7XG4gIHN1aXRlLCBwdXJwb3NlLCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwLCBhZGRTdWl0ZUNvbnRleHQgPSB0cnVlXG59ID0ge30pIHtcbiAgaWYoZXhwYW5zaW9uTWFwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImV4cGFuc2lvbk1hcFwiIG5vdCBzdXBwb3J0ZWQuJyk7XG4gIH1cbiAgaWYodHlwZW9mIGRvY3VtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImRvY3VtZW50XCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIC8vIEVuc3VyZSBkb2N1bWVudCBjb250YWlucyB0aGUgc2lnbmF0dXJlIHN1aXRlIHNwZWNpZmljIGNvbnRleHQgVVJMXG4gIC8vIG9yIHRocm93IGFuIGVycm9yIChpbiBjYXNlIGFuIGFkdmFuY2VkIHVzZXIgb3ZlcnJpZGVzIHRoZSBgYWRkU3VpdGVDb250ZXh0YFxuICAvLyBmbGFnIHRvIGZhbHNlKS5cbiAgc3VpdGUuZW5zdXJlU3VpdGVDb250ZXh0KHtkb2N1bWVudCwgYWRkU3VpdGVDb250ZXh0fSk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb29mU2V0KCkuYWRkKGRvY3VtZW50LCB7c3VpdGUsIHB1cnBvc2UsIGRvY3VtZW50TG9hZGVyfSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIGlmKCFkb2N1bWVudExvYWRlciAmJiBlLm5hbWUgPT09ICdqc29ubGQuSW52YWxpZFVybCcpIHtcbiAgICAgIGNvbnN0IHtkZXRhaWxzOiB7dXJsfX0gPSBlO1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICBgQSBVUkwgXCIke3VybH1cIiBjb3VsZCBub3QgYmUgZmV0Y2hlZDsgeW91IG5lZWQgdG8gcGFzcyBgICtcbiAgICAgICAgJ1wiZG9jdW1lbnRMb2FkZXJcIiBvciByZXNvbHZlIHRoZSBVUkwgYmVmb3JlIGNhbGxpbmcgXCJzaWduXCIuJyk7XG4gICAgICBlcnIuY2F1c2UgPSBlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBsaW5rZWQgZGF0YSBzaWduYXR1cmUgb24gdGhlIHByb3ZpZGVkIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb2N1bWVudCAtIFRoZSBKU09OLUxEIGRvY3VtZW50IHdpdGggb25lIG9yIG1vcmUgcHJvb2ZzIHRvIGJlXG4gKiAgIHZlcmlmaWVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxuICogQHBhcmFtIHtMaW5rZWREYXRhU2lnbmF0dXJlfExpbmtlZERhdGFTaWduYXR1cmVbXX0gb3B0aW9ucy5zdWl0ZSAtXG4gKiAgIEFjY2VwdGFibGUgc2lnbmF0dXJlIHN1aXRlIGluc3RhbmNlcyBmb3IgdmVyaWZ5aW5nIHRoZSBwcm9vZihzKS5cbiAqXG4gKiBAcGFyYW0ge1Byb29mUHVycG9zZX0gcHVycG9zZSAtIEEgcHJvb2YgcHVycG9zZSBpbnN0YW5jZSB0aGF0IHdpbGxcbiAqICAgbWF0Y2ggcHJvb2ZzIHRvIGJlIHZlcmlmaWVkIGFuZCBlbnN1cmUgdGhleSB3ZXJlIGNyZWF0ZWQgYWNjb3JkaW5nIHRvXG4gKiAgIHRoZSBhcHByb3ByaWF0ZSBwdXJwb3NlLlxuICpcbiAqIEFkdmFuY2VkIG9wdGlvbmFsIHBhcmFtZXRlcnMgYW5kIG92ZXJyaWRlczpcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5kb2N1bWVudExvYWRlcl0gIC0gQSBjdXN0b20gZG9jdW1lbnQgbG9hZGVyLFxuICogICBgUHJvbWlzZTxSZW1vdGVEb2N1bWVudD4gZG9jdW1lbnRMb2FkZXIodXJsKWAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5leHBhbnNpb25NYXBdIC0gTk9UIFNVUFBPUlRFRDsgZG8gbm90IHVzZS5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlPHt2ZXJpZmllZDogYm9vbGVhbiwgcmVzdWx0czogQXJyYXksXG4gKiAgIGVycm9yOiBWZXJpZmljYXRpb25FcnJvcn0+fVxuICogICByZXNvbHZlcyB3aXRoIGFuIG9iamVjdCB3aXRoIGEgYHZlcmlmaWVkYCBib29sZWFuIHByb3BlcnR5IHRoYXQgaXMgYHRydWVgXG4gKiAgIGlmIGF0IGxlYXN0IG9uZSBwcm9vZiBtYXRjaGluZyB0aGUgZ2l2ZW4gcHVycG9zZSBhbmQgc3VpdGUgdmVyaWZpZXMgYW5kXG4gKiAgIGBmYWxzZWAgb3RoZXJ3aXNlOyBhIGByZXN1bHRzYCBwcm9wZXJ0eSB3aXRoIGFuIGFycmF5IG9mIGRldGFpbGVkIHJlc3VsdHM7XG4gKiAgIGlmIGBmYWxzZWAgYW4gYGVycm9yYCBwcm9wZXJ0eSB3aWxsIGJlIHByZXNlbnQsIHdpdGggYGVycm9yLmVycm9yc2BcbiAqICAgY29udGFpbmluZyBhbGwgb2YgdGhlIGVycm9ycyB0aGF0IG9jY3VycmVkIGR1cmluZyB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuXG4gKi9cbmFwaS52ZXJpZnkgPSBhc3luYyBmdW5jdGlvbiB2ZXJpZnkoZG9jdW1lbnQsIHtcbiAgc3VpdGUsIHB1cnBvc2UsIGRvY3VtZW50TG9hZGVyLCBleHBhbnNpb25NYXBcbn0gPSB7fSkge1xuICBpZihleHBhbnNpb25NYXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXhwYW5zaW9uTWFwXCIgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxuICBpZih0eXBlb2YgZG9jdW1lbnQgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZG9jdW1lbnRcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb29mU2V0KCkudmVyaWZ5KFxuICAgIGRvY3VtZW50LCB7c3VpdGUsIHB1cnBvc2UsIGRvY3VtZW50TG9hZGVyfSk7XG4gIGNvbnN0IHtlcnJvcn0gPSByZXN1bHQ7XG4gIGlmKGVycm9yKSB7XG4gICAgaWYoIWRvY3VtZW50TG9hZGVyICYmIGVycm9yLm5hbWUgPT09ICdqc29ubGQuSW52YWxpZFVybCcpIHtcbiAgICAgIGNvbnN0IHtkZXRhaWxzOiB7dXJsfX0gPSBlcnJvcjtcbiAgICAgIGNvbnN0IHVybEVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgQSBVUkwgXCIke3VybH1cIiBjb3VsZCBub3QgYmUgZmV0Y2hlZDsgeW91IG5lZWQgdG8gcGFzcyBgICtcbiAgICAgICAgJ1wiZG9jdW1lbnRMb2FkZXJcIiBvciByZXNvbHZlIHRoZSBVUkwgYmVmb3JlIGNhbGxpbmcgXCJ2ZXJpZnlcIi4nKTtcbiAgICAgIHJlc3VsdC5lcnJvciA9IG5ldyBWZXJpZmljYXRpb25FcnJvcih1cmxFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5lcnJvciA9IG5ldyBWZXJpZmljYXRpb25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBleHBvc2Ugc3VpdGUgY2xhc3Nlc1xuYXBpLnN1aXRlcyA9IHJlcXVpcmUoJy4vc3VpdGVzJykuc3VpdGVzO1xuXG4vLyBleHBvc2UgUHJvb2ZQdXJwb3NlIGNsYXNzZXMgdG8gZW5hYmxlIGV4dGVuc2lvbnNcbmFwaS5wdXJwb3NlcyA9IHJlcXVpcmUoJy4vcHVycG9zZXMnKS5wdXJwb3NlcztcblxuLy8gZXhwb3NlIGRvY3VtZW50IGxvYWRlciBoZWxwZXJzXG5PYmplY3QuYXNzaWduKGFwaSwgcmVxdWlyZSgnLi9kb2N1bWVudExvYWRlcicpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/jsonld-signatures.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/purposes.js":
/*!********************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.purposes = {\n  AssertionProofPurpose: __webpack_require__(/*! ./purposes/AssertionProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js\"),\n  AuthenticationProofPurpose: __webpack_require__(/*! ./purposes/AuthenticationProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js\"),\n  ControllerProofPurpose: __webpack_require__(/*! ./purposes/ControllerProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\"),\n  ProofPurpose: __webpack_require__(/*! ./purposes/ProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLHNIQUFrQztBQUNuRSw4QkFBOEIsbUJBQU8sQ0FBQyxnSUFBdUM7QUFDN0UsMEJBQTBCLG1CQUFPLENBQUMsd0hBQW1DO0FBQ3JFLGdCQUFnQixtQkFBTyxDQUFDLG9HQUF5QjtBQUNqRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9saWIvcHVycG9zZXMuanM/YmM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxOCBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIFRPRE86IG9ubHkgcmVxdWlyZSBkeW5hbWljYWxseSBhcyBuZWVkZWQgb3IgYWNjb3JkaW5nIHRvIGJ1aWxkXG5hcGkucHVycG9zZXMgPSB7XG4gIEFzc2VydGlvblByb29mUHVycG9zZTogcmVxdWlyZSgnLi9wdXJwb3Nlcy9Bc3NlcnRpb25Qcm9vZlB1cnBvc2UnKSxcbiAgQXV0aGVudGljYXRpb25Qcm9vZlB1cnBvc2U6IHJlcXVpcmUoJy4vcHVycG9zZXMvQXV0aGVudGljYXRpb25Qcm9vZlB1cnBvc2UnKSxcbiAgQ29udHJvbGxlclByb29mUHVycG9zZTogcmVxdWlyZSgnLi9wdXJwb3Nlcy9Db250cm9sbGVyUHJvb2ZQdXJwb3NlJyksXG4gIFByb29mUHVycG9zZTogcmVxdWlyZSgnLi9wdXJwb3Nlcy9Qcm9vZlB1cnBvc2UnKVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/purposes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ControllerProofPurpose = __webpack_require__(/*! ./ControllerProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\");\n\nmodule.exports = class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod', controller,\n    date, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzL0Fzc2VydGlvblByb29mUHVycG9zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBMEI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDLFdBQVcsMENBQTBDO0FBQ3JEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzL0Fzc2VydGlvblByb29mUHVycG9zZS5qcz9kYmFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE4IERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ29udHJvbGxlclByb29mUHVycG9zZSA9IHJlcXVpcmUoJy4vQ29udHJvbGxlclByb29mUHVycG9zZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEFzc2VydGlvblByb29mUHVycG9zZSBleHRlbmRzIENvbnRyb2xsZXJQcm9vZlB1cnBvc2Uge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdGVybSA9ICdhc3NlcnRpb25NZXRob2QnLCBjb250cm9sbGVyLFxuICAgIGRhdGUsIG1heFRpbWVzdGFtcERlbHRhID0gSW5maW5pdHl9ID0ge30pIHtcbiAgICBzdXBlcih7dGVybSwgY29udHJvbGxlciwgZGF0ZSwgbWF4VGltZXN0YW1wRGVsdGF9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst ControllerProofPurpose = __webpack_require__(/*! ./ControllerProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\");\n\nmodule.exports = class AuthenticationProofPurpose extends\n  ControllerProofPurpose {\n  constructor({\n    term = 'authentication', controller,\n    challenge, date, domain, maxTimestampDelta = Infinity} = {}) {\n    super({term, controller, date, maxTimestampDelta});\n    if(typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      // check challenge\n      if(proof.challenge !== this.challenge) {\n        throw new Error(\n          'The challenge is not as expected; ' +\n          `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`);\n      }\n\n      // check domain\n      if(this.domain !== undefined) {\n        // `proof.domain` must equal `this.domain` OR if `proof.domain` is\n        // an array, the array must include `this.domain` as an element\n        const {domain} = proof;\n        if(!(domain === this.domain ||\n          (Array.isArray(domain) && domain.includes(this.domain)))) {\n          throw new Error(\n            'The domain is not as expected; ' +\n            `domain=${JSON.stringify(domain)}, ` +\n            `expected=${JSON.stringify(this.domain)}`);\n        }\n      }\n\n      return super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof = await super.update(\n      proof, {document, suite, documentLoader, expansionMap});\n    proof.challenge = this.challenge;\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzL0F1dGhlbnRpY2F0aW9uUHJvb2ZQdXJwb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLCtCQUErQixtQkFBTyxDQUFDLCtHQUEwQjs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsSUFBSTtBQUMvRCxXQUFXLDBDQUEwQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGlEQUFpRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyx3QkFBd0IsZ0JBQWdCLGVBQWUsZUFBZTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsc0JBQXNCLHVCQUF1QjtBQUM3Qyx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFLE1BQU07QUFDTixjQUFjO0FBQ2Q7QUFDQTs7QUFFQSx1QkFBdUIsOENBQThDO0FBQ3JFO0FBQ0EsY0FBYyw4Q0FBOEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzL0F1dGhlbnRpY2F0aW9uUHJvb2ZQdXJwb3NlLmpzPzJiMjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDb250cm9sbGVyUHJvb2ZQdXJwb3NlID0gcmVxdWlyZSgnLi9Db250cm9sbGVyUHJvb2ZQdXJwb3NlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQXV0aGVudGljYXRpb25Qcm9vZlB1cnBvc2UgZXh0ZW5kc1xuICBDb250cm9sbGVyUHJvb2ZQdXJwb3NlIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRlcm0gPSAnYXV0aGVudGljYXRpb24nLCBjb250cm9sbGVyLFxuICAgIGNoYWxsZW5nZSwgZGF0ZSwgZG9tYWluLCBtYXhUaW1lc3RhbXBEZWx0YSA9IEluZmluaXR5fSA9IHt9KSB7XG4gICAgc3VwZXIoe3Rlcm0sIGNvbnRyb2xsZXIsIGRhdGUsIG1heFRpbWVzdGFtcERlbHRhfSk7XG4gICAgaWYodHlwZW9mIGNoYWxsZW5nZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2hhbGxlbmdlXCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgaWYoZG9tYWluICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRvbWFpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZG9tYWluXCIgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG4gICAgdGhpcy5jaGFsbGVuZ2UgPSBjaGFsbGVuZ2U7XG4gICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZShwcm9vZiwge3ZlcmlmaWNhdGlvbk1ldGhvZCwgZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcH0pIHtcbiAgICB0cnkge1xuICAgICAgLy8gY2hlY2sgY2hhbGxlbmdlXG4gICAgICBpZihwcm9vZi5jaGFsbGVuZ2UgIT09IHRoaXMuY2hhbGxlbmdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIGNoYWxsZW5nZSBpcyBub3QgYXMgZXhwZWN0ZWQ7ICcgK1xuICAgICAgICAgIGBjaGFsbGVuZ2U9XCIke3Byb29mLmNoYWxsZW5nZX1cIiwgZXhwZWN0ZWQ9XCIke3RoaXMuY2hhbGxlbmdlfVwiYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGRvbWFpblxuICAgICAgaWYodGhpcy5kb21haW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBgcHJvb2YuZG9tYWluYCBtdXN0IGVxdWFsIGB0aGlzLmRvbWFpbmAgT1IgaWYgYHByb29mLmRvbWFpbmAgaXNcbiAgICAgICAgLy8gYW4gYXJyYXksIHRoZSBhcnJheSBtdXN0IGluY2x1ZGUgYHRoaXMuZG9tYWluYCBhcyBhbiBlbGVtZW50XG4gICAgICAgIGNvbnN0IHtkb21haW59ID0gcHJvb2Y7XG4gICAgICAgIGlmKCEoZG9tYWluID09PSB0aGlzLmRvbWFpbiB8fFxuICAgICAgICAgIChBcnJheS5pc0FycmF5KGRvbWFpbikgJiYgZG9tYWluLmluY2x1ZGVzKHRoaXMuZG9tYWluKSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkb21haW4gaXMgbm90IGFzIGV4cGVjdGVkOyAnICtcbiAgICAgICAgICAgIGBkb21haW49JHtKU09OLnN0cmluZ2lmeShkb21haW4pfSwgYCArXG4gICAgICAgICAgICBgZXhwZWN0ZWQ9JHtKU09OLnN0cmluZ2lmeSh0aGlzLmRvbWFpbil9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1cGVyLnZhbGlkYXRlKFxuICAgICAgICBwcm9vZiwge3ZlcmlmaWNhdGlvbk1ldGhvZCwgZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcH0pO1xuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiB7dmFsaWQ6IGZhbHNlLCBlcnJvcn07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlKHByb29mLCB7ZG9jdW1lbnQsIHN1aXRlLCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSkge1xuICAgIHByb29mID0gYXdhaXQgc3VwZXIudXBkYXRlKFxuICAgICAgcHJvb2YsIHtkb2N1bWVudCwgc3VpdGUsIGRvY3VtZW50TG9hZGVyLCBleHBhbnNpb25NYXB9KTtcbiAgICBwcm9vZi5jaGFsbGVuZ2UgPSB0aGlzLmNoYWxsZW5nZTtcbiAgICBpZih0aGlzLmRvbWFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9vZi5kb21haW4gPSB0aGlzLmRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIHByb29mO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ../constants */ \"(ssr)/./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"(ssr)/./node_modules/jsonld/lib/index.js\");\nconst ProofPurpose = __webpack_require__(/*! ./ProofPurpose */ \"(ssr)/./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\");\n\n// DID documents can be specially optimized\nconst DID_CONTEXT_V1 = 'https://www.w3.org/ns/did/v1';\n// verification relationship terms that are known to appear in DID documents\nconst DID_VR_TERMS = [\n  'assertionMethod',\n  'authentication',\n  'capabilityInvocation',\n  'capabilityDelegation',\n  'keyAgreement',\n  'verificationMethod'\n];\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n    this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n      if(typeof verificationId !== 'string') {\n        throw new Error(\n          `Verification method ID \"${verificationMethod.id}\" ` +\n          'must be a string.');\n      }\n      const {term, _termDefinedByDIDContext} = this;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        const {controller} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        }\n\n        // apply optimization to controller documents that are DID documents;\n        // if `term` is one of those defined by the DID context\n        let {document} = await documentLoader(controllerId);\n        const mustFrame = !(_termDefinedByDIDContext &&\n          document['@context'] === DID_CONTEXT_V1 ||\n          (Array.isArray(document['@context']) &&\n          document['@context'][0] === DID_CONTEXT_V1));\n        if(mustFrame) {\n          // Note: `expansionMap` is intentionally not passed; we can safely\n          // drop properties here and must allow for it\n          document = await jsonld.frame(document, {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // this term must be in the JSON-LD controller document or\n            // verification will fail\n            [term]: {\n              '@embed': '@never',\n              id: verificationId\n            }\n          }, {documentLoader, compactToRelative: false, safe: true});\n        }\n        result.controller = document;\n      }\n\n      const verificationMethods = jsonld.getValues(result.controller, term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzL0NvbnRyb2xsZXJQcm9vZlB1cnBvc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWM7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHdEQUFRO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFnQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQSxlQUFlLHNEQUFzRCxJQUFJO0FBQ3pFLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQSxlQUFlLFNBQVMsNkJBQTZCO0FBQ3JEO0FBQ0EseUJBQXlCLGlEQUFpRDtBQUMxRTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDOztBQUU3QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRyxxREFBcUQ7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBLE1BQU07QUFDTixjQUFjO0FBQ2Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL2xpYi9wdXJwb3Nlcy9Db250cm9sbGVyUHJvb2ZQdXJwb3NlLmpzPzczMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTgtMjAyMiBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuY29uc3QganNvbmxkID0gcmVxdWlyZSgnanNvbmxkJyk7XG5jb25zdCBQcm9vZlB1cnBvc2UgPSByZXF1aXJlKCcuL1Byb29mUHVycG9zZScpO1xuXG4vLyBESUQgZG9jdW1lbnRzIGNhbiBiZSBzcGVjaWFsbHkgb3B0aW1pemVkXG5jb25zdCBESURfQ09OVEVYVF9WMSA9ICdodHRwczovL3d3dy53My5vcmcvbnMvZGlkL3YxJztcbi8vIHZlcmlmaWNhdGlvbiByZWxhdGlvbnNoaXAgdGVybXMgdGhhdCBhcmUga25vd24gdG8gYXBwZWFyIGluIERJRCBkb2N1bWVudHNcbmNvbnN0IERJRF9WUl9URVJNUyA9IFtcbiAgJ2Fzc2VydGlvbk1ldGhvZCcsXG4gICdhdXRoZW50aWNhdGlvbicsXG4gICdjYXBhYmlsaXR5SW52b2NhdGlvbicsXG4gICdjYXBhYmlsaXR5RGVsZWdhdGlvbicsXG4gICdrZXlBZ3JlZW1lbnQnLFxuICAndmVyaWZpY2F0aW9uTWV0aG9kJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBDb250cm9sbGVyUHJvb2ZQdXJwb3NlIGV4dGVuZHMgUHJvb2ZQdXJwb3NlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBwcm9vZiBwdXJwb3NlIHRoYXQgd2lsbCB2YWxpZGF0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgdmVyaWZpY2F0aW9uXG4gICAqIG1ldGhvZCBpbiBhIHByb29mIHdhcyBhdXRob3JpemVkIGJ5IGl0cyBkZWNsYXJlZCBjb250cm9sbGVyIGZvciB0aGVcbiAgICogcHJvb2YncyBwdXJwb3NlLlxuICAgKlxuICAgKiBAcGFyYW0gdGVybSB7c3RyaW5nfSB0aGUgYHByb29mUHVycG9zZWAgdGVybSwgYXMgZGVmaW5lZCBpbiB0aGVcbiAgICogICAgU0VDVVJJVFlfQ09OVEVYVF9VUkwgYEBjb250ZXh0YCBvciBhIFVSSSBpZiBub3QgZGVmaW5lZCBpbiBzdWNoLlxuICAgKiBAcGFyYW0gW2NvbnRyb2xsZXJdIHtvYmplY3R9IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgY29udHJvbGxlciwgaWYgaXRcbiAgICogICBpcyBub3QgdG8gYmUgZGVyZWZlcmVuY2VkIHZpYSBhIGBkb2N1bWVudExvYWRlcmAuXG4gICAqIEBwYXJhbSBbZGF0ZV0ge3N0cmluZyBvciBEYXRlIG9yIGludGVnZXJ9IHRoZSBleHBlY3RlZCBkYXRlIGZvclxuICAgKiAgIHRoZSBjcmVhdGlvbiBvZiB0aGUgcHJvb2YuXG4gICAqIEBwYXJhbSBbbWF4VGltZXN0YW1wRGVsdGFdIHtpbnRlZ2VyfSBhIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdGhhdFxuICAgKiAgIHRoZSBkYXRlIG9uIHRoZSBzaWduYXR1cmUgY2FuIGRldmlhdGUgZnJvbSwgZGVmYXVsdHMgdG8gYEluZmluaXR5YC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0ZXJtLCBjb250cm9sbGVyLCBkYXRlLCBtYXhUaW1lc3RhbXBEZWx0YSA9IEluZmluaXR5fSA9IHt9KSB7XG4gICAgc3VwZXIoe3Rlcm0sIGRhdGUsIG1heFRpbWVzdGFtcERlbHRhfSk7XG4gICAgaWYoY29udHJvbGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZih0eXBlb2YgY29udHJvbGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjb250cm9sbGVyXCIgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgICB0aGlzLl90ZXJtRGVmaW5lZEJ5RElEQ29udGV4dCA9IERJRF9WUl9URVJNUy5pbmNsdWRlcyh0ZXJtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIHB1cnBvc2Ugb2YgYSBwcm9vZi4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZ1xuICAgKiBwcm9vZiB2ZXJpZmljYXRpb24sIGFmdGVyIHRoZSBwcm9vZiB2YWx1ZSBoYXMgYmVlbiBjaGVja2VkIGFnYWluc3QgdGhlXG4gICAqIGdpdmVuIHZlcmlmaWNhdGlvbiBtZXRob2QgKGUuZy4gaW4gdGhlIGNhc2Ugb2YgYSBkaWdpdGFsIHNpZ25hdHVyZSwgdGhlXG4gICAqIHNpZ25hdHVyZSBoYXMgYmVlbiBjcnlwdG9ncmFwaGljYWxseSB2ZXJpZmllZCBhZ2FpbnN0IHRoZSBwdWJsaWMga2V5KS5cbiAgICpcbiAgICogQHBhcmFtIHByb29mXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25NZXRob2RcbiAgICogQHBhcmFtIGRvY3VtZW50TG9hZGVyXG4gICAqIEBwYXJhbSBleHBhbnNpb25NYXBcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZlcmlmaWNhdGlvbiBtZXRob2Qgbm90IGF1dGhvcml6ZWQgYnkgY29udHJvbGxlclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcHJvb2YncyBjcmVhdGVkIHRpbWVzdGFtcCBpcyBvdXQgb2YgcmFuZ2VcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8e3ZhbGlkOiBib29sZWFuLCBlcnJvcjogRXJyb3J9Pn1cbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlKHByb29mLCB7dmVyaWZpY2F0aW9uTWV0aG9kLCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdXBlci52YWxpZGF0ZShcbiAgICAgICAgcHJvb2YsIHt2ZXJpZmljYXRpb25NZXRob2QsIGRvY3VtZW50TG9hZGVyLCBleHBhbnNpb25NYXB9KTtcbiAgICAgIGlmKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7aWQ6IHZlcmlmaWNhdGlvbklkfSA9IHZlcmlmaWNhdGlvbk1ldGhvZDtcbiAgICAgIGlmKHR5cGVvZiB2ZXJpZmljYXRpb25JZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBWZXJpZmljYXRpb24gbWV0aG9kIElEIFwiJHt2ZXJpZmljYXRpb25NZXRob2QuaWR9XCIgYCArXG4gICAgICAgICAgJ211c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB7dGVybSwgX3Rlcm1EZWZpbmVkQnlESURDb250ZXh0fSA9IHRoaXM7XG5cbiAgICAgIC8vIGlmIG5vIGBjb250cm9sbGVyYCBzcGVjaWZpZWQsIHVzZSB2ZXJpZmljYXRpb24gbWV0aG9kJ3NcbiAgICAgIGlmKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICByZXN1bHQuY29udHJvbGxlciA9IHRoaXMuY29udHJvbGxlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHZlcmlmaWNhdGlvbk1ldGhvZDtcbiAgICAgICAgbGV0IGNvbnRyb2xsZXJJZDtcbiAgICAgICAgaWYoY29udHJvbGxlcikge1xuICAgICAgICAgIGlmKHR5cGVvZiBjb250cm9sbGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29udHJvbGxlcklkID0gY29udHJvbGxlci5pZDtcbiAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mIGNvbnRyb2xsZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAnXCJjb250cm9sbGVyXCIgbXVzdCBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwuJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXJJZCA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbHkgb3B0aW1pemF0aW9uIHRvIGNvbnRyb2xsZXIgZG9jdW1lbnRzIHRoYXQgYXJlIERJRCBkb2N1bWVudHM7XG4gICAgICAgIC8vIGlmIGB0ZXJtYCBpcyBvbmUgb2YgdGhvc2UgZGVmaW5lZCBieSB0aGUgRElEIGNvbnRleHRcbiAgICAgICAgbGV0IHtkb2N1bWVudH0gPSBhd2FpdCBkb2N1bWVudExvYWRlcihjb250cm9sbGVySWQpO1xuICAgICAgICBjb25zdCBtdXN0RnJhbWUgPSAhKF90ZXJtRGVmaW5lZEJ5RElEQ29udGV4dCAmJlxuICAgICAgICAgIGRvY3VtZW50WydAY29udGV4dCddID09PSBESURfQ09OVEVYVF9WMSB8fFxuICAgICAgICAgIChBcnJheS5pc0FycmF5KGRvY3VtZW50WydAY29udGV4dCddKSAmJlxuICAgICAgICAgIGRvY3VtZW50WydAY29udGV4dCddWzBdID09PSBESURfQ09OVEVYVF9WMSkpO1xuICAgICAgICBpZihtdXN0RnJhbWUpIHtcbiAgICAgICAgICAvLyBOb3RlOiBgZXhwYW5zaW9uTWFwYCBpcyBpbnRlbnRpb25hbGx5IG5vdCBwYXNzZWQ7IHdlIGNhbiBzYWZlbHlcbiAgICAgICAgICAvLyBkcm9wIHByb3BlcnRpZXMgaGVyZSBhbmQgbXVzdCBhbGxvdyBmb3IgaXRcbiAgICAgICAgICBkb2N1bWVudCA9IGF3YWl0IGpzb25sZC5mcmFtZShkb2N1bWVudCwge1xuICAgICAgICAgICAgJ0Bjb250ZXh0JzogY29uc3RhbnRzLlNFQ1VSSVRZX0NPTlRFWFRfVVJMLFxuICAgICAgICAgICAgaWQ6IGNvbnRyb2xsZXJJZCxcbiAgICAgICAgICAgIC8vIHRoaXMgdGVybSBtdXN0IGJlIGluIHRoZSBKU09OLUxEIGNvbnRyb2xsZXIgZG9jdW1lbnQgb3JcbiAgICAgICAgICAgIC8vIHZlcmlmaWNhdGlvbiB3aWxsIGZhaWxcbiAgICAgICAgICAgIFt0ZXJtXToge1xuICAgICAgICAgICAgICAnQGVtYmVkJzogJ0BuZXZlcicsXG4gICAgICAgICAgICAgIGlkOiB2ZXJpZmljYXRpb25JZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHtkb2N1bWVudExvYWRlciwgY29tcGFjdFRvUmVsYXRpdmU6IGZhbHNlLCBzYWZlOiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmNvbnRyb2xsZXIgPSBkb2N1bWVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmVyaWZpY2F0aW9uTWV0aG9kcyA9IGpzb25sZC5nZXRWYWx1ZXMocmVzdWx0LmNvbnRyb2xsZXIsIHRlcm0pO1xuICAgICAgcmVzdWx0LnZhbGlkID0gdmVyaWZpY2F0aW9uTWV0aG9kcy5zb21lKHZtID0+XG4gICAgICAgIHZtID09PSB2ZXJpZmljYXRpb25JZCB8fFxuICAgICAgICAodHlwZW9mIHZtID09PSAnb2JqZWN0JyAmJiB2bS5pZCA9PT0gdmVyaWZpY2F0aW9uSWQpKTtcbiAgICAgIGlmKCFyZXN1bHQudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBWZXJpZmljYXRpb24gbWV0aG9kIFwiJHt2ZXJpZmljYXRpb25NZXRob2QuaWR9XCIgbm90IGF1dGhvcml6ZWQgYCArXG4gICAgICAgICAgYGJ5IGNvbnRyb2xsZXIgZm9yIHByb29mIHB1cnBvc2UgXCIke3RoaXMudGVybX1cIi5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIHt2YWxpZDogZmFsc2UsIGVycm9yfTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {/*document, suite, verificationMethod,\n      documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {/*document, suite, documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {/* document, documentLoader,*/ expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return proof.proofPurpose === this.term;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3B1cnBvc2VzL1Byb29mUHVycG9zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBLGVBQWUsMENBQTBDLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0EsWUFBWTtBQUNaLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ04sY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQWtEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBLHNCQUFzQiw0Q0FBNEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL2xpYi9wdXJwb3Nlcy9Qcm9vZlB1cnBvc2UuanM/NDdjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxOCBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUHJvb2ZQdXJwb3NlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0ZXJtIHtzdHJpbmd9IHRoZSBgcHJvb2ZQdXJwb3NlYCB0ZXJtLCBhcyBkZWZpbmVkIGluIHRoZVxuICAgKiAgICBTRUNVUklUWV9DT05URVhUX1VSTCBgQGNvbnRleHRgIG9yIGEgVVJJIGlmIG5vdCBkZWZpbmVkIGluIHN1Y2guXG4gICAqIEBwYXJhbSBbZGF0ZV0ge3N0cmluZyBvciBEYXRlIG9yIGludGVnZXJ9IHRoZSBleHBlY3RlZCBkYXRlIGZvclxuICAgKiAgIHRoZSBjcmVhdGlvbiBvZiB0aGUgcHJvb2YuXG4gICAqIEBwYXJhbSBbbWF4VGltZXN0YW1wRGVsdGFdIHtpbnRlZ2VyfSBhIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdGhhdFxuICAgKiAgIHRoZSBkYXRlIG9uIHRoZSBzaWduYXR1cmUgY2FuIGRldmlhdGUgZnJvbSwgZGVmYXVsdHMgdG8gYEluZmluaXR5YC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHt0ZXJtLCBkYXRlLCBtYXhUaW1lc3RhbXBEZWx0YSA9IEluZmluaXR5fSA9IHt9KSB7XG4gICAgaWYodGVybSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGVybVwiIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBpZihtYXhUaW1lc3RhbXBEZWx0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICB0eXBlb2YgbWF4VGltZXN0YW1wRGVsdGEgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm1heFRpbWVzdGFtcERlbHRhXCIgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgdGhpcy50ZXJtID0gdGVybTtcbiAgICBpZihkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgaWYoaXNOYU4odGhpcy5kYXRlKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYFwiZGF0ZVwiIFwiJHtkYXRlfVwiIGlzIG5vdCBhIHZhbGlkIGRhdGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWF4VGltZXN0YW1wRGVsdGEgPSBtYXhUaW1lc3RhbXBEZWx0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gdmFsaWRhdGUgdGhlIHB1cnBvc2Ugb2YgYSBwcm9vZi4gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGR1cmluZ1xuICAgKiBwcm9vZiB2ZXJpZmljYXRpb24sIGFmdGVyIHRoZSBwcm9vZiB2YWx1ZSBoYXMgYmVlbiBjaGVja2VkIGFnYWluc3QgdGhlXG4gICAqIGdpdmVuIHZlcmlmaWNhdGlvbiBtZXRob2QgKGUuZy4gaW4gdGhlIGNhc2Ugb2YgYSBkaWdpdGFsIHNpZ25hdHVyZSwgdGhlXG4gICAqIHNpZ25hdHVyZSBoYXMgYmVlbiBjcnlwdG9ncmFwaGljYWxseSB2ZXJpZmllZCBhZ2FpbnN0IHRoZSBwdWJsaWMga2V5KS5cbiAgICpcbiAgICogQHBhcmFtIHByb29mIHtvYmplY3R9IHRoZSBwcm9vZiwgaW4gdGhlIGBjb25zdGFudHMuU0VDVVJJVFlfQ09OVEVYVF9VUkxgLFxuICAgKiAgIHdpdGggdGhlIG1hdGNoaW5nIHB1cnBvc2UgdG8gdmFsaWRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gcmVzb2x2ZXMgdG8gYW4gb2JqZWN0IHdpdGggYHZhbGlkYCBhbmQgYGVycm9yYC5cbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlKFxuICAgIHByb29mLCB7Lypkb2N1bWVudCwgc3VpdGUsIHZlcmlmaWNhdGlvbk1ldGhvZCxcbiAgICAgIGRvY3VtZW50TG9hZGVyLCovIGV4cGFuc2lvbk1hcH0pIHtcbiAgICBpZihleHBhbnNpb25NYXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJleHBhbnNpb25NYXBcIiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBjaGVjayBleHBpcmF0aW9uXG4gICAgICBpZih0aGlzLm1heFRpbWVzdGFtcERlbHRhICE9PSBJbmZpbml0eSkge1xuICAgICAgICBjb25zdCBleHBlY3RlZCA9ICh0aGlzLmRhdGUgfHwgbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMubWF4VGltZXN0YW1wRGVsdGEgKiAxMDAwO1xuICAgICAgICBjb25zdCBjcmVhdGVkID0gbmV3IERhdGUocHJvb2YuY3JlYXRlZCkuZ2V0VGltZSgpO1xuICAgICAgICAvLyBjb21wYXJpbmcgdGhpcyB3YXkgaGFuZGxlcyBOYU4gY2FzZSB3aGVyZSBgY3JlYXRlZGAgaXMgaW52YWxpZFxuICAgICAgICBpZighKGNyZWF0ZWQgPj0gKGV4cGVjdGVkIC0gZGVsdGEpICYmIGNyZWF0ZWQgPD0gKGV4cGVjdGVkICsgZGVsdGEpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb29mXFwncyBjcmVhdGVkIHRpbWVzdGFtcCBpcyBvdXQgb2YgcmFuZ2UuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7dmFsaWQ6IHRydWV9O1xuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiB7dmFsaWQ6IGZhbHNlLCBlcnJvcn07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byB1cGRhdGUgYSBwcm9vZiB3aGVuIGl0IGlzIGJlaW5nIGNyZWF0ZWQsIGFkZGluZyBhbnkgcHJvcGVydGllc1xuICAgKiBzcGVjaWZpYyB0byB0aGlzIHB1cnBvc2UuIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBwcmlvciB0byB0aGUgcHJvb2ZcbiAgICogdmFsdWUgYmVpbmcgZ2VuZXJhdGVkIHN1Y2ggdGhhdCBhbnkgcHJvcGVydGllcyBhZGRlZCBtYXkgYmUsIGZvciBleGFtcGxlLFxuICAgKiBpbmNsdWRlZCBpbiBhIGRpZ2l0YWwgc2lnbmF0dXJlIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvb2Yge29iamVjdH0gdGhlIHByb29mLCBpbiB0aGUgYGNvbnN0YW50cy5TRUNVUklUWV9DT05URVhUX1VSTGBcbiAgICogICB0byB1cGRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8b2JqZWN0Pn0gcmVzb2x2ZXMgdG8gdGhlIHByb29mIGluc3RhbmNlIChpbiB0aGVcbiAgICogICBgY29uc3RhbnRzLlNFQ1VSSVRZX0NPTlRFWFRfVVJMYC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZShwcm9vZiwgey8qZG9jdW1lbnQsIHN1aXRlLCBkb2N1bWVudExvYWRlciwqLyBleHBhbnNpb25NYXB9KSB7XG4gICAgaWYoZXhwYW5zaW9uTWFwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXhwYW5zaW9uTWFwXCIgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgcHJvb2YucHJvb2ZQdXJwb3NlID0gdGhpcy50ZXJtO1xuICAgIHJldHVybiBwcm9vZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBwcm9vZiBoYXMgYSBwdXJwb3NlIHRoYXQgbWF0Y2hlcyB0aGlzIGluc3RhbmNlLFxuICAgKiBpLmUuIHRoaXMgUHJvb2ZQdXJwb3NlIGluc3RhbmNlIHNob3VsZCBiZSB1c2VkIHRvIHZhbGlkYXRlIHRoZSBnaXZlblxuICAgKiBwcm9vZi5cbiAgICpcbiAgICogQHBhcmFtIHByb29mIHtvYmplY3R9IHRoZSBwcm9vZiB0byBjaGVjay5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gYHRydWVgIGlmIHRoZXJlJ3MgYSBtYXRjaCwgYGZhbHNlYCBpZiBub3QuXG4gICAqL1xuICBhc3luYyBtYXRjaChwcm9vZiwgey8qIGRvY3VtZW50LCBkb2N1bWVudExvYWRlciwqLyBleHBhbnNpb25NYXB9KSB7XG4gICAgaWYoZXhwYW5zaW9uTWFwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXhwYW5zaW9uTWFwXCIgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb29mLnByb29mUHVycG9zZSA9PT0gdGhpcy50ZXJtO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/sha256digest.js":
/*!************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/sha256digest.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2021 Digital Bazaar, Inc. All rights reserved.\n */\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nmodule.exports = {\n  /**\n   * Hashes a string of data using SHA-256.\n   *\n   * @param {string} string - the string to hash.\n   *\n   * @return {Uint8Array} the hash digest.\n   */\n  async sha256digest({string}) {\n    return new Uint8Array(\n      crypto.createHash('sha256').update(string).digest()\n    );\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3NoYTI1NmRpZ2VzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL2xpYi9zaGEyNTZkaWdlc3QuanM/ZDc0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDIxIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEhhc2hlcyBhIHN0cmluZyBvZiBkYXRhIHVzaW5nIFNIQS0yNTYuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSB0aGUgc3RyaW5nIHRvIGhhc2guXG4gICAqXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBoYXNoIGRpZ2VzdC5cbiAgICovXG4gIGFzeW5jIHNoYTI1NmRpZ2VzdCh7c3RyaW5nfSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShcbiAgICAgIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyaW5nKS5kaWdlc3QoKVxuICAgICk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/sha256digest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/suites.js":
/*!******************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n// TODO: only require dynamically as needed or according to build\napi.suites = {\n  LinkedDataProof: __webpack_require__(/*! ./suites/LinkedDataProof */ \"(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\"),\n  LinkedDataSignature: __webpack_require__(/*! ./suites/LinkedDataSignature */ \"(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3N1aXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMsOEdBQThCO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL2xpYi9zdWl0ZXMuanM/ZDIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxOCBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFwaSA9IHt9O1xubW9kdWxlLmV4cG9ydHMgPSBhcGk7XG5cbi8vIFRPRE86IG9ubHkgcmVxdWlyZSBkeW5hbWljYWxseSBhcyBuZWVkZWQgb3IgYWNjb3JkaW5nIHRvIGJ1aWxkXG5hcGkuc3VpdGVzID0ge1xuICBMaW5rZWREYXRhUHJvb2Y6IHJlcXVpcmUoJy4vc3VpdGVzL0xpbmtlZERhdGFQcm9vZicpLFxuICBMaW5rZWREYXRhU2lnbmF0dXJlOiByZXF1aXJlKCcuL3N1aXRlcy9MaW5rZWREYXRhU2lnbmF0dXJlJylcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/suites.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2018-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    /* document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document from which to derive\n   *   a new document and proof.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   *\n   * @returns {Promise<object>} Resolves with the new document with a new\n   *   `proof` field.\n   */\n  async derive({\n    /* document, purpose, proofSet, documentLoader */\n  }) {\n    throw new Error('\"deriveProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    /* proof, document, purpose, proofSet, documentLoader, expansionMap */\n  }) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * Checks whether a given proof exists in the document.\n   *\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to match.\n   *\n   * @returns {Promise<boolean>} Whether a match for the proof was found.\n   */\n  async matchProof({\n    proof /*, document, purpose, documentLoader, expansionMap */\n  }) {\n    return proof.type === this.type;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3N1aXRlcy9MaW5rZWREYXRhUHJvb2YuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxlQUFlLE1BQU0sSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVUsc0NBQXNDO0FBQzdEO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVLHNDQUFzQztBQUM3RDtBQUNBLGVBQWUsU0FBUyxPQUFPLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3N1aXRlcy9MaW5rZWREYXRhUHJvb2YuanM/OWVkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxOC0yMDIzIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBMaW5rZWREYXRhUHJvb2Yge1xuICBjb25zdHJ1Y3Rvcih7dHlwZX0gPSB7fSkge1xuICAgIGlmKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBMaW5rZWREYXRhUHJvb2YgbXVzdCBoYXZlIGEgXCJ0eXBlXCIuJyk7XG4gICAgfVxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGJlIHNpZ25lZC5cbiAgICogQHBhcmFtIHtQcm9vZlB1cnBvc2V9IG9wdGlvbnMucHVycG9zZSAtIFRoZSBwcm9vZiBwdXJwb3NlIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnByb29mU2V0IC0gQW55IGV4aXN0aW5nIHByb29mIHNldC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5kb2N1bWVudExvYWRlciAtIFRoZSBkb2N1bWVudCBsb2FkZXIgdG8gdXNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmV4cGFuc2lvbk1hcCAtIE5PVCBTVVBQT1JURUQ7IGRvIG5vdCB1c2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFJlc29sdmVzIHdpdGggdGhlIGNyZWF0ZWQgcHJvb2Ygb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlUHJvb2Yoe1xuICAgIC8qIGRvY3VtZW50LCBwdXJwb3NlLCBwcm9vZlNldCwgZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcCAqL1xuICB9KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImNyZWF0ZVByb29mXCIgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGRlcml2ZWQgY2xhc3MuJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRvY3VtZW50IC0gVGhlIGRvY3VtZW50IGZyb20gd2hpY2ggdG8gZGVyaXZlXG4gICAqICAgYSBuZXcgZG9jdW1lbnQgYW5kIHByb29mLlxuICAgKiBAcGFyYW0ge1Byb29mUHVycG9zZX0gb3B0aW9ucy5wdXJwb3NlIC0gVGhlIHByb29mIHB1cnBvc2UgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMucHJvb2ZTZXQgLSBBbnkgZXhpc3RpbmcgcHJvb2Ygc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmRvY3VtZW50TG9hZGVyIC0gVGhlIGRvY3VtZW50IGxvYWRlciB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFJlc29sdmVzIHdpdGggdGhlIG5ldyBkb2N1bWVudCB3aXRoIGEgbmV3XG4gICAqICAgYHByb29mYCBmaWVsZC5cbiAgICovXG4gIGFzeW5jIGRlcml2ZSh7XG4gICAgLyogZG9jdW1lbnQsIHB1cnBvc2UsIHByb29mU2V0LCBkb2N1bWVudExvYWRlciAqL1xuICB9KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcImRlcml2ZVByb29mXCIgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGRlcml2ZWQgY2xhc3MuJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnByb29mIC0gVGhlIHByb29mIHRvIGJlIHZlcmlmaWVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5kb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0aGUgcHJvb2YgYXBwbGllcyB0by5cbiAgICogQHBhcmFtIHtQcm9vZlB1cnBvc2V9IG9wdGlvbnMucHVycG9zZSAtIFRoZSBwcm9vZiBwdXJwb3NlIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnByb29mU2V0IC0gQW55IGV4aXN0aW5nIHByb29mIHNldC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5kb2N1bWVudExvYWRlciAtIFRoZSBkb2N1bWVudCBsb2FkZXIgdG8gdXNlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmV4cGFuc2lvbk1hcCAtIE5PVCBTVVBQT1JURUQ7IGRvIG5vdCB1c2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtvYmplY3R9Pn0gUmVzb2x2ZXMgd2l0aCB0aGUgdmVyaWZpY2F0aW9uIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIHZlcmlmeVByb29mKHtcbiAgICAvKiBwcm9vZiwgZG9jdW1lbnQsIHB1cnBvc2UsIHByb29mU2V0LCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwICovXG4gIH0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1widmVyaWZ5UHJvb2ZcIiBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgZGVyaXZlZCBjbGFzcy4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIHByb29mIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5wcm9vZiAtIFRoZSBwcm9vZiB0byBtYXRjaC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFdoZXRoZXIgYSBtYXRjaCBmb3IgdGhlIHByb29mIHdhcyBmb3VuZC5cbiAgICovXG4gIGFzeW5jIG1hdGNoUHJvb2Yoe1xuICAgIHByb29mIC8qLCBkb2N1bWVudCwgcHVycG9zZSwgZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcCAqL1xuICB9KSB7XG4gICAgcmV0dXJuIHByb29mLnR5cGUgPT09IHRoaXMudHlwZTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2017-2024 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst constants = __webpack_require__(/*! ../constants */ \"(ssr)/./node_modules/jsonld-signatures/lib/constants.js\");\nconst jsonld = __webpack_require__(/*! jsonld */ \"(ssr)/./node_modules/jsonld/lib/index.js\");\nconst rdfCanonize = __webpack_require__(/*! rdf-canonize */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/index.js\");\nconst util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/jsonld-signatures/lib/util.js\");\nconst {sha256digest} = __webpack_require__(/*! ../sha256digest */ \"(ssr)/./node_modules/jsonld-signatures/lib/sha256digest.js\");\nconst LinkedDataProof = __webpack_require__(/*! ./LinkedDataProof */ \"(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js\");\n\nmodule.exports = class LinkedDataSignature extends LinkedDataProof {\n  /**\n   * Parent class from which the various LinkDataSignature suites (such as\n   * `Ed25519Signature2020`) inherit.\n   * NOTE: Developers are never expected to use this class directly, but to\n   * only work with individual suites.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {string} options.type - Suite name, provided by subclass.\n   * @typedef LDKeyPair\n   * @param {LDKeyPair} LDKeyClass - The crypto-ld key class that this suite\n   *   will use to sign/verify signatures. Provided by subclass. Used\n   *   during the `verifySignature` operation, to create an instance (containing\n   *   a `verifier()` property) of a public key fetched via a `documentLoader`.\n   *\n   * @param {string} contextUrl - JSON-LD context URL that corresponds to this\n   *   signature suite. Provided by subclass. Used for enforcing suite context\n   *   during the `sign()` operation.\n   *\n   * For `sign()` operations, either a `key` OR a `signer` is required.\n   * For `verify()` operations, you can pass in a verifier (from KMS), or\n   * the public key will be fetched via documentLoader.\n   *\n   * @param {object} [options.key] - An optional key object (containing an\n   *   `id` property, and either `signer` or `verifier`, depending on the\n   *   intended operation. Useful for when the application is managing keys\n   *   itself (when using a KMS, you never have access to the private key,\n   *   and so should use the `signer` param instead).\n   *\n   * @param {{sign: Function, id: string}} [options.signer] - Signer object\n   *   that has two properties: an async `sign()` method, and an `id`. This is\n   *   useful when interfacing with a KMS (since you don't get access to the\n   *   private key and its `signer`, the KMS client gives you only the signer\n   *   object to use).\n   *\n   * @param {{verify: Function, id: string}} [options.verifier] - Verifier\n   *   object that has two properties: an async `verify()` method, and an `id`.\n   *   Useful when working with a KMS-provided verifier.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {object} [options.proof] - A JSON-LD document with options to use\n   *   for the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2). If not provided, this is\n   *   constructed during signing.\n   * @param {string|Date} [options.date] - Signing date to use (otherwise\n   *   defaults to `now()`).\n   * @param {boolean} [options.useNativeCanonize] - Whether to use a native\n   *   canonize algorithm.\n   * @param {object} [options.canonizeOptions] - Options to pass to\n   *   canonize algorithm.\n   */\n  constructor({\n    type, proof, LDKeyClass, date, key, signer, verifier, useNativeCanonize,\n    canonizeOptions, contextUrl\n  } = {}) {\n    super({type});\n    this.LDKeyClass = LDKeyClass;\n    this.contextUrl = contextUrl;\n    this.proof = proof;\n    const vm = _processSignatureParams({key, signer, verifier});\n    this.verificationMethod = vm.verificationMethod;\n    this.key = vm.key;\n    this.signer = vm.signer;\n    this.verifier = vm.verifier;\n    this.canonizeOptions = canonizeOptions;\n    if(date) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.useNativeCanonize = useNativeCanonize;\n    this._hashCache = null;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof({\n    document, purpose, proofSet, documentLoader, expansionMap\n  }) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if(this.proof) {\n      // shallow copy\n      proof = {...this.proof};\n    } else {\n      // create proof JSON-LD document\n      proof = {};\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if(proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if(date && typeof date !== 'string') {\n      date = util.w3cDate(date);\n    }\n\n    // add API overrides\n    if(date) {\n      proof.created = date;\n    }\n\n    proof.verificationMethod = this.verificationMethod;\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof(\n      {document, proof, proofSet, purpose, documentLoader});\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(\n      proof, {document, suite: this, documentLoader});\n\n    // create data to sign\n    const verifyData = await this.createVerifyData(\n      {document, proof, proofSet, documentLoader});\n\n    // sign data\n    proof = await this.sign({verifyData, document, proof, documentLoader});\n\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be updated.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // extending classes may do more\n    return proof;\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {object} options.document - The document the proof applies to.\n   * @param {ProofPurpose} options.purpose - The proof purpose instance.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, proofSet, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData(\n        {document, proof, proofSet, documentLoader, expansionMap});\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod(\n        {proof, document, documentLoader, expansionMap});\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData, verificationMethod, document, proof,\n        documentLoader, expansionMap});\n      if(!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      return {verified: true, verificationMethod};\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  async canonize(input, {documentLoader, expansionMap, skipExpansion}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    return _canonize(input, {\n      algorithm: 'RDFC-1.0',\n      // do not resolve any relative URLs or terms, throw errors instead\n      base: null,\n      format: 'application/n-quads',\n      documentLoader,\n      // throw errors if any values would be dropped due to missing\n      // definitions or relative URLs\n      safe: true,\n      skipExpansion,\n      useNative: this.useNativeCanonize,\n      ...this.canonizeOptions\n    });\n  }\n\n  async canonizeProof(proof, {document, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = {\n      '@context': document['@context'] || constants.SECURITY_CONTEXT_URL,\n      ...proof\n    };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false,\n      ...this.canonizeOptions\n    });\n  }\n\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document to be signed/verified.\n   * @param {object} options.proof - The proof to be verified.\n   * @param {Array} options.proofSet - Any existing proof set.\n   * @param {function} options.documentLoader - The document loader to use.\n   * @param {function} options.expansionMap - NOT SUPPORTED; do not use.\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({document, proof, documentLoader, expansionMap}) {\n    if(expansionMap) {\n      throw new Error('\"expansionMap\" not supported.');\n    }\n    // get cached document hash\n    let cachedDocHash;\n    const {_hashCache} = this;\n    if(_hashCache && _hashCache.document === document) {\n      cachedDocHash = _hashCache.hash;\n    } else {\n      this._hashCache = {\n        document,\n        // canonize and hash document\n        hash: cachedDocHash =\n          this.canonize(document, {documentLoader, expansionMap})\n            .then(c14nDocument => sha256digest({string: c14nDocument}))\n      };\n    }\n\n    // await both c14n proof hash and c14n document hash\n    const [proofHash, docHash] = await Promise.all([\n      // canonize and hash proof\n      this.canonizeProof(\n        proof, {document, documentLoader, expansionMap})\n        .then(c14nProofOptions => sha256digest({string: c14nProofOptions})),\n      cachedDocHash\n    ]);\n\n    // concatenate hash of c14n proof options and hash of c14n document\n    return util.concat(proofHash, docHash);\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} document from which to derive a new document\n   *   and proof.\n   * @param proof {object}\n   * @param proofSet {Array}\n   * @param documentLoader {function}\n   *\n   * @returns {Promise<{object}>} The new document with `proof`.\n   */\n  async derive() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   */\n  async getVerificationMethod({proof, documentLoader}) {\n    let {verificationMethod} = proof;\n\n    if(typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if(!verificationMethod) {\n      throw new Error('No \"verificationMethod\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(verificationMethod, {\n      '@context': constants.SECURITY_CONTEXT_URL,\n      '@embed': '@always',\n      id: verificationMethod\n    }, {documentLoader, compactToRelative: false, safe: true});\n    if(!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if(framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} to be signed.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<boolean>}\n   */\n  async verifySignature() {\n    throw new Error('Must be implemented by a derived class.');\n  }\n\n  /**\n   * Ensures the document to be signed contains the required signature suite\n   * specific `@context`, by either adding it (if `addSuiteContext` is true),\n   * or throwing an error if it's missing.\n   *\n   * @param {object} options - Options hashmap.\n   * @param {object} options.document - JSON-LD document to be signed.\n   * @param {boolean} options.addSuiteContext - Add suite context?\n   */\n  ensureSuiteContext({document, addSuiteContext}) {\n    const {contextUrl} = this;\n\n    if(_includesContext({document, contextUrl})) {\n      // document already includes the required context\n      return;\n    }\n\n    if(!addSuiteContext) {\n      throw new TypeError(\n        `The document to be signed must contain this suite's @context, ` +\n        `\"${contextUrl}\".`);\n    }\n\n    // enforce the suite's context by adding it to the document\n    const existingContext = document['@context'] || [];\n\n    document['@context'] = Array.isArray(existingContext) ?\n      [...existingContext, contextUrl] : [existingContext, contextUrl];\n  }\n};\n\n/**\n * Tests whether a provided JSON-LD document includes a context URL in its\n * `@context` property.\n *\n * @param {object} options - Options hashmap.\n * @param {object} options.document - A JSON-LD document.\n * @param {string} options.contextUrl - A context URL.\n *\n * @returns {boolean} Returns true if document includes context.\n */\nfunction _includesContext({document, contextUrl}) {\n  const context = document['@context'];\n  return context === contextUrl ||\n    (Array.isArray(context) && context.includes(contextUrl));\n}\n\n/**\n * See constructor docstring for param details.\n *\n * @returns {{verificationMethod: string, key: LDKeyPair,\n *   signer: {sign: Function, id: string},\n *   verifier: {verify: Function, id: string}}} - Validated and initialized\n *   key-related parameters.\n */\nfunction _processSignatureParams({key, signer, verifier}) {\n  // We are explicitly not requiring a key or signer/verifier param to be\n  // present, to support the verify() use case where the verificationMethod\n  // is being fetched by the documentLoader\n\n  const vm = {};\n  if(key) {\n    vm.key = key;\n    vm.verificationMethod = key.id;\n    if(typeof key.signer === 'function') {\n      vm.signer = key.signer();\n    }\n    if(typeof key.verifier === 'function') {\n      vm.verifier = key.verifier();\n    }\n    if(!(vm.signer || vm.verifier)) {\n      throw new TypeError(\n        'The \"key\" parameter must contain a \"signer\" or \"verifier\" method.');\n    }\n  } else {\n    vm.verificationMethod = (signer && signer.id) ||\n      (verifier && verifier.id);\n    vm.signer = signer;\n    vm.verifier = verifier;\n  }\n\n  if(vm.signer) {\n    if(typeof vm.signer.sign !== 'function') {\n      throw new TypeError('A signer API has not been specified.');\n    }\n  }\n  if(vm.verifier) {\n    if(typeof vm.verifier.verify !== 'function') {\n      throw new TypeError('A verifier API has not been specified.');\n    }\n  }\n\n  return vm;\n}\n\nasync function _canonize(input, options) {\n  // convert to RDF dataset and do canonicalization\n  const opts = {\n    rdfDirection: 'i18n-datatype', ...options, produceGeneralizedRdf: false,\n  };\n  delete opts.format;\n  const dataset = await jsonld.toRDF(input, opts);\n  return rdfCanonize.canonize(dataset, options);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3N1aXRlcy9MaW5rZWREYXRhU2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDZFQUFjO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyx3REFBUTtBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQywrRkFBYztBQUMxQyxhQUFhLG1CQUFPLENBQUMsbUVBQVM7QUFDOUIsT0FBTyxjQUFjLEVBQUUsbUJBQU8sQ0FBQyxtRkFBaUI7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsK0ZBQW1COztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1IsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsY0FBYztBQUMzQixhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVSxzQ0FBc0M7QUFDN0Q7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLG1EQUFtRDs7QUFFMUQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0NBQXNDOztBQUVwRDtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7O0FBRWpEO0FBQ0EsNkJBQTZCLDRDQUE0Qzs7QUFFekU7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVSxzQ0FBc0M7QUFDN0Q7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVLHNDQUFzQztBQUM3RDtBQUNBLGVBQWUsU0FBUyxPQUFPLEdBQUc7QUFDbEM7QUFDQSxxQkFBcUIsd0RBQXdEO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUF3RDs7QUFFakU7QUFDQTtBQUNBLFNBQVMsOENBQThDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxNQUFNO0FBQ04sY0FBYztBQUNkO0FBQ0E7O0FBRUEseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsOEJBQThCLHVDQUF1QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVUsc0NBQXNDO0FBQzdEO0FBQ0EsZUFBZSxTQUFTLFdBQVcsRUFBRTtBQUNyQztBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZCQUE2QjtBQUNoRSxnREFBZ0QscUJBQXFCO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZELGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsV0FBVztBQUNuQyxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCO0FBQ0EsZUFBZSxTQUFTLE9BQU8sR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCLG1CQUFtQjtBQUNuQiw0QkFBNEI7QUFDNUI7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JELFNBQVMsb0JBQW9COztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHFEQUFxRDtBQUM3RDtBQUNBLDZDQUE2QyxvQkFBb0I7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLHNCQUFzQixRQUFRO0FBQzlCLG1CQUFtQjtBQUNuQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCO0FBQ0EsZUFBZSxTQUFTLE9BQU8sR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLGdDQUFnQyxPQUFPO0FBQ3ZDLHNCQUFzQixRQUFRO0FBQzlCLG1CQUFtQjtBQUNuQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQsV0FBVyxZQUFZOztBQUV2Qix5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYywyQkFBMkI7QUFDekMsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL2xpYi9zdWl0ZXMvTGlua2VkRGF0YVNpZ25hdHVyZS5qcz9jZmU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjQgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKTtcbmNvbnN0IGpzb25sZCA9IHJlcXVpcmUoJ2pzb25sZCcpO1xuY29uc3QgcmRmQ2Fub25pemUgPSByZXF1aXJlKCdyZGYtY2Fub25pemUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCB7c2hhMjU2ZGlnZXN0fSA9IHJlcXVpcmUoJy4uL3NoYTI1NmRpZ2VzdCcpO1xuY29uc3QgTGlua2VkRGF0YVByb29mID0gcmVxdWlyZSgnLi9MaW5rZWREYXRhUHJvb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBMaW5rZWREYXRhU2lnbmF0dXJlIGV4dGVuZHMgTGlua2VkRGF0YVByb29mIHtcbiAgLyoqXG4gICAqIFBhcmVudCBjbGFzcyBmcm9tIHdoaWNoIHRoZSB2YXJpb3VzIExpbmtEYXRhU2lnbmF0dXJlIHN1aXRlcyAoc3VjaCBhc1xuICAgKiBgRWQyNTUxOVNpZ25hdHVyZTIwMjBgKSBpbmhlcml0LlxuICAgKiBOT1RFOiBEZXZlbG9wZXJzIGFyZSBuZXZlciBleHBlY3RlZCB0byB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSwgYnV0IHRvXG4gICAqIG9ubHkgd29yayB3aXRoIGluZGl2aWR1YWwgc3VpdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgaGFzaG1hcC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudHlwZSAtIFN1aXRlIG5hbWUsIHByb3ZpZGVkIGJ5IHN1YmNsYXNzLlxuICAgKiBAdHlwZWRlZiBMREtleVBhaXJcbiAgICogQHBhcmFtIHtMREtleVBhaXJ9IExES2V5Q2xhc3MgLSBUaGUgY3J5cHRvLWxkIGtleSBjbGFzcyB0aGF0IHRoaXMgc3VpdGVcbiAgICogICB3aWxsIHVzZSB0byBzaWduL3ZlcmlmeSBzaWduYXR1cmVzLiBQcm92aWRlZCBieSBzdWJjbGFzcy4gVXNlZFxuICAgKiAgIGR1cmluZyB0aGUgYHZlcmlmeVNpZ25hdHVyZWAgb3BlcmF0aW9uLCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgKGNvbnRhaW5pbmdcbiAgICogICBhIGB2ZXJpZmllcigpYCBwcm9wZXJ0eSkgb2YgYSBwdWJsaWMga2V5IGZldGNoZWQgdmlhIGEgYGRvY3VtZW50TG9hZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRVcmwgLSBKU09OLUxEIGNvbnRleHQgVVJMIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhpc1xuICAgKiAgIHNpZ25hdHVyZSBzdWl0ZS4gUHJvdmlkZWQgYnkgc3ViY2xhc3MuIFVzZWQgZm9yIGVuZm9yY2luZyBzdWl0ZSBjb250ZXh0XG4gICAqICAgZHVyaW5nIHRoZSBgc2lnbigpYCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEZvciBgc2lnbigpYCBvcGVyYXRpb25zLCBlaXRoZXIgYSBga2V5YCBPUiBhIGBzaWduZXJgIGlzIHJlcXVpcmVkLlxuICAgKiBGb3IgYHZlcmlmeSgpYCBvcGVyYXRpb25zLCB5b3UgY2FuIHBhc3MgaW4gYSB2ZXJpZmllciAoZnJvbSBLTVMpLCBvclxuICAgKiB0aGUgcHVibGljIGtleSB3aWxsIGJlIGZldGNoZWQgdmlhIGRvY3VtZW50TG9hZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMua2V5XSAtIEFuIG9wdGlvbmFsIGtleSBvYmplY3QgKGNvbnRhaW5pbmcgYW5cbiAgICogICBgaWRgIHByb3BlcnR5LCBhbmQgZWl0aGVyIGBzaWduZXJgIG9yIGB2ZXJpZmllcmAsIGRlcGVuZGluZyBvbiB0aGVcbiAgICogICBpbnRlbmRlZCBvcGVyYXRpb24uIFVzZWZ1bCBmb3Igd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgbWFuYWdpbmcga2V5c1xuICAgKiAgIGl0c2VsZiAod2hlbiB1c2luZyBhIEtNUywgeW91IG5ldmVyIGhhdmUgYWNjZXNzIHRvIHRoZSBwcml2YXRlIGtleSxcbiAgICogICBhbmQgc28gc2hvdWxkIHVzZSB0aGUgYHNpZ25lcmAgcGFyYW0gaW5zdGVhZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7e3NpZ246IEZ1bmN0aW9uLCBpZDogc3RyaW5nfX0gW29wdGlvbnMuc2lnbmVyXSAtIFNpZ25lciBvYmplY3RcbiAgICogICB0aGF0IGhhcyB0d28gcHJvcGVydGllczogYW4gYXN5bmMgYHNpZ24oKWAgbWV0aG9kLCBhbmQgYW4gYGlkYC4gVGhpcyBpc1xuICAgKiAgIHVzZWZ1bCB3aGVuIGludGVyZmFjaW5nIHdpdGggYSBLTVMgKHNpbmNlIHlvdSBkb24ndCBnZXQgYWNjZXNzIHRvIHRoZVxuICAgKiAgIHByaXZhdGUga2V5IGFuZCBpdHMgYHNpZ25lcmAsIHRoZSBLTVMgY2xpZW50IGdpdmVzIHlvdSBvbmx5IHRoZSBzaWduZXJcbiAgICogICBvYmplY3QgdG8gdXNlKS5cbiAgICpcbiAgICogQHBhcmFtIHt7dmVyaWZ5OiBGdW5jdGlvbiwgaWQ6IHN0cmluZ319IFtvcHRpb25zLnZlcmlmaWVyXSAtIFZlcmlmaWVyXG4gICAqICAgb2JqZWN0IHRoYXQgaGFzIHR3byBwcm9wZXJ0aWVzOiBhbiBhc3luYyBgdmVyaWZ5KClgIG1ldGhvZCwgYW5kIGFuIGBpZGAuXG4gICAqICAgVXNlZnVsIHdoZW4gd29ya2luZyB3aXRoIGEgS01TLXByb3ZpZGVkIHZlcmlmaWVyLlxuICAgKlxuICAgKiBBZHZhbmNlZCBvcHRpb25hbCBwYXJhbWV0ZXJzIGFuZCBvdmVycmlkZXM6XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5wcm9vZl0gLSBBIEpTT04tTEQgZG9jdW1lbnQgd2l0aCBvcHRpb25zIHRvIHVzZVxuICAgKiAgIGZvciB0aGUgYHByb29mYCBub2RlIChlLmcuIGFueSBvdGhlciBjdXN0b20gZmllbGRzIGNhbiBiZSBwcm92aWRlZCBoZXJlXG4gICAqICAgdXNpbmcgYSBjb250ZXh0IGRpZmZlcmVudCBmcm9tIHNlY3VyaXR5LXYyKS4gSWYgbm90IHByb3ZpZGVkLCB0aGlzIGlzXG4gICAqICAgY29uc3RydWN0ZWQgZHVyaW5nIHNpZ25pbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfERhdGV9IFtvcHRpb25zLmRhdGVdIC0gU2lnbmluZyBkYXRlIHRvIHVzZSAob3RoZXJ3aXNlXG4gICAqICAgZGVmYXVsdHMgdG8gYG5vdygpYCkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNlTmF0aXZlQ2Fub25pemVdIC0gV2hldGhlciB0byB1c2UgYSBuYXRpdmVcbiAgICogICBjYW5vbml6ZSBhbGdvcml0aG0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5jYW5vbml6ZU9wdGlvbnNdIC0gT3B0aW9ucyB0byBwYXNzIHRvXG4gICAqICAgY2Fub25pemUgYWxnb3JpdGhtLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHR5cGUsIHByb29mLCBMREtleUNsYXNzLCBkYXRlLCBrZXksIHNpZ25lciwgdmVyaWZpZXIsIHVzZU5hdGl2ZUNhbm9uaXplLFxuICAgIGNhbm9uaXplT3B0aW9ucywgY29udGV4dFVybFxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7dHlwZX0pO1xuICAgIHRoaXMuTERLZXlDbGFzcyA9IExES2V5Q2xhc3M7XG4gICAgdGhpcy5jb250ZXh0VXJsID0gY29udGV4dFVybDtcbiAgICB0aGlzLnByb29mID0gcHJvb2Y7XG4gICAgY29uc3Qgdm0gPSBfcHJvY2Vzc1NpZ25hdHVyZVBhcmFtcyh7a2V5LCBzaWduZXIsIHZlcmlmaWVyfSk7XG4gICAgdGhpcy52ZXJpZmljYXRpb25NZXRob2QgPSB2bS52ZXJpZmljYXRpb25NZXRob2Q7XG4gICAgdGhpcy5rZXkgPSB2bS5rZXk7XG4gICAgdGhpcy5zaWduZXIgPSB2bS5zaWduZXI7XG4gICAgdGhpcy52ZXJpZmllciA9IHZtLnZlcmlmaWVyO1xuICAgIHRoaXMuY2Fub25pemVPcHRpb25zID0gY2Fub25pemVPcHRpb25zO1xuICAgIGlmKGRhdGUpIHtcbiAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgaWYoaXNOYU4odGhpcy5kYXRlKSkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoYFwiZGF0ZVwiIFwiJHtkYXRlfVwiIGlzIG5vdCBhIHZhbGlkIGRhdGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXNlTmF0aXZlQ2Fub25pemUgPSB1c2VOYXRpdmVDYW5vbml6ZTtcbiAgICB0aGlzLl9oYXNoQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5kb2N1bWVudCAtIFRoZSBkb2N1bWVudCB0byBiZSBzaWduZWQuXG4gICAqIEBwYXJhbSB7UHJvb2ZQdXJwb3NlfSBvcHRpb25zLnB1cnBvc2UgLSBUaGUgcHJvb2YgcHVycG9zZSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5wcm9vZlNldCAtIEFueSBleGlzdGluZyBwcm9vZiBzZXQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZG9jdW1lbnRMb2FkZXIgLSBUaGUgZG9jdW1lbnQgbG9hZGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5leHBhbnNpb25NYXAgLSBOT1QgU1VQUE9SVEVEOyBkbyBub3QgdXNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNvbHZlcyB3aXRoIHRoZSBjcmVhdGVkIHByb29mIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVByb29mKHtcbiAgICBkb2N1bWVudCwgcHVycG9zZSwgcHJvb2ZTZXQsIGRvY3VtZW50TG9hZGVyLCBleHBhbnNpb25NYXBcbiAgfSkge1xuICAgIGlmKGV4cGFuc2lvbk1hcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImV4cGFuc2lvbk1hcFwiIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgcHJvb2YgKGN1cnJlbnRseSBrbm93biBhcyBgc2lnbmF0dXJlIG9wdGlvbnNgIGluIHNwZWMpXG4gICAgbGV0IHByb29mO1xuICAgIGlmKHRoaXMucHJvb2YpIHtcbiAgICAgIC8vIHNoYWxsb3cgY29weVxuICAgICAgcHJvb2YgPSB7Li4udGhpcy5wcm9vZn07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNyZWF0ZSBwcm9vZiBKU09OLUxEIGRvY3VtZW50XG4gICAgICBwcm9vZiA9IHt9O1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwcm9vZiB0eXBlIGlzIHNldFxuICAgIHByb29mLnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBgbm93YCBkYXRlIGlmIG5vdCBnaXZlbiBpbiBgcHJvb2ZgIG9yIGBvcHRpb25zYFxuICAgIGxldCBkYXRlID0gdGhpcy5kYXRlO1xuICAgIGlmKHByb29mLmNyZWF0ZWQgPT09IHVuZGVmaW5lZCAmJiBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBkYXRlIGlzIGluIHN0cmluZyBmb3JtYXRcbiAgICBpZihkYXRlICYmIHR5cGVvZiBkYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgZGF0ZSA9IHV0aWwudzNjRGF0ZShkYXRlKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgQVBJIG92ZXJyaWRlc1xuICAgIGlmKGRhdGUpIHtcbiAgICAgIHByb29mLmNyZWF0ZWQgPSBkYXRlO1xuICAgIH1cblxuICAgIHByb29mLnZlcmlmaWNhdGlvbk1ldGhvZCA9IHRoaXMudmVyaWZpY2F0aW9uTWV0aG9kO1xuXG4gICAgLy8gYWRkIGFueSBleHRlbnNpb25zIHRvIHByb29mIChtb3N0bHkgZm9yIGxlZ2FjeSBzdXBwb3J0KVxuICAgIHByb29mID0gYXdhaXQgdGhpcy51cGRhdGVQcm9vZihcbiAgICAgIHtkb2N1bWVudCwgcHJvb2YsIHByb29mU2V0LCBwdXJwb3NlLCBkb2N1bWVudExvYWRlcn0pO1xuXG4gICAgLy8gYWxsb3cgcHVycG9zZSB0byB1cGRhdGUgdGhlIHByb29mOyB0aGUgYHByb29mYCBpcyBpbiB0aGVcbiAgICAvLyBTRUNVUklUWV9DT05URVhUX1VSTCBgQGNvbnRleHRgIC0tIHRoZXJlZm9yZSB0aGUgYHB1cnBvc2VgIG11c3RcbiAgICAvLyBlbnN1cmUgYW55IGFkZGVkIGZpZWxkcyBhcmUgYWxzbyByZXByZXNlbnRlZCBpbiB0aGF0IHNhbWUgYEBjb250ZXh0YFxuICAgIHByb29mID0gYXdhaXQgcHVycG9zZS51cGRhdGUoXG4gICAgICBwcm9vZiwge2RvY3VtZW50LCBzdWl0ZTogdGhpcywgZG9jdW1lbnRMb2FkZXJ9KTtcblxuICAgIC8vIGNyZWF0ZSBkYXRhIHRvIHNpZ25cbiAgICBjb25zdCB2ZXJpZnlEYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVWZXJpZnlEYXRhKFxuICAgICAge2RvY3VtZW50LCBwcm9vZiwgcHJvb2ZTZXQsIGRvY3VtZW50TG9hZGVyfSk7XG5cbiAgICAvLyBzaWduIGRhdGFcbiAgICBwcm9vZiA9IGF3YWl0IHRoaXMuc2lnbih7dmVyaWZ5RGF0YSwgZG9jdW1lbnQsIHByb29mLCBkb2N1bWVudExvYWRlcn0pO1xuXG4gICAgcmV0dXJuIHByb29mO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5wcm9vZiAtIFRoZSBwcm9vZiB0byBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnByb29mU2V0IC0gQW55IGV4aXN0aW5nIHByb29mIHNldC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5leHBhbnNpb25NYXAgLSBOT1QgU1VQUE9SVEVEOyBkbyBub3QgdXNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBSZXNvbHZlcyB3aXRoIHRoZSBjcmVhdGVkIHByb29mIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVByb29mKHtwcm9vZiwgZXhwYW5zaW9uTWFwfSkge1xuICAgIGlmKGV4cGFuc2lvbk1hcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImV4cGFuc2lvbk1hcFwiIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIC8vIGV4dGVuZGluZyBjbGFzc2VzIG1heSBkbyBtb3JlXG4gICAgcmV0dXJuIHByb29mO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5wcm9vZiAtIFRoZSBwcm9vZiB0byBiZSB2ZXJpZmllZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdGhlIHByb29mIGFwcGxpZXMgdG8uXG4gICAqIEBwYXJhbSB7UHJvb2ZQdXJwb3NlfSBvcHRpb25zLnB1cnBvc2UgLSBUaGUgcHJvb2YgcHVycG9zZSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtBcnJheX0gb3B0aW9ucy5wcm9vZlNldCAtIEFueSBleGlzdGluZyBwcm9vZiBzZXQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZG9jdW1lbnRMb2FkZXIgLSBUaGUgZG9jdW1lbnQgbG9hZGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5leHBhbnNpb25NYXAgLSBOT1QgU1VQUE9SVEVEOyBkbyBub3QgdXNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7b2JqZWN0fT59IFJlc29sdmVzIHdpdGggdGhlIHZlcmlmaWNhdGlvbiByZXN1bHQuXG4gICAqL1xuICBhc3luYyB2ZXJpZnlQcm9vZih7cHJvb2YsIGRvY3VtZW50LCBwcm9vZlNldCwgZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcH0pIHtcbiAgICBpZihleHBhbnNpb25NYXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJleHBhbnNpb25NYXBcIiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBjcmVhdGUgZGF0YSB0byB2ZXJpZnlcbiAgICAgIGNvbnN0IHZlcmlmeURhdGEgPSBhd2FpdCB0aGlzLmNyZWF0ZVZlcmlmeURhdGEoXG4gICAgICAgIHtkb2N1bWVudCwgcHJvb2YsIHByb29mU2V0LCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSk7XG5cbiAgICAgIC8vIGZldGNoIHZlcmlmaWNhdGlvbiBtZXRob2RcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvbk1ldGhvZCA9IGF3YWl0IHRoaXMuZ2V0VmVyaWZpY2F0aW9uTWV0aG9kKFxuICAgICAgICB7cHJvb2YsIGRvY3VtZW50LCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSk7XG5cbiAgICAgIC8vIHZlcmlmeSBzaWduYXR1cmUgb24gZGF0YVxuICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCB0aGlzLnZlcmlmeVNpZ25hdHVyZSh7XG4gICAgICAgIHZlcmlmeURhdGEsIHZlcmlmaWNhdGlvbk1ldGhvZCwgZG9jdW1lbnQsIHByb29mLFxuICAgICAgICBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSk7XG4gICAgICBpZighdmVyaWZpZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZS4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHt2ZXJpZmllZDogdHJ1ZSwgdmVyaWZpY2F0aW9uTWV0aG9kfTtcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4ge3ZlcmlmaWVkOiBmYWxzZSwgZXJyb3J9O1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNhbm9uaXplKGlucHV0LCB7ZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcCwgc2tpcEV4cGFuc2lvbn0pIHtcbiAgICBpZihleHBhbnNpb25NYXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJleHBhbnNpb25NYXBcIiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gX2Nhbm9uaXplKGlucHV0LCB7XG4gICAgICBhbGdvcml0aG06ICdSREZDLTEuMCcsXG4gICAgICAvLyBkbyBub3QgcmVzb2x2ZSBhbnkgcmVsYXRpdmUgVVJMcyBvciB0ZXJtcywgdGhyb3cgZXJyb3JzIGluc3RlYWRcbiAgICAgIGJhc2U6IG51bGwsXG4gICAgICBmb3JtYXQ6ICdhcHBsaWNhdGlvbi9uLXF1YWRzJyxcbiAgICAgIGRvY3VtZW50TG9hZGVyLFxuICAgICAgLy8gdGhyb3cgZXJyb3JzIGlmIGFueSB2YWx1ZXMgd291bGQgYmUgZHJvcHBlZCBkdWUgdG8gbWlzc2luZ1xuICAgICAgLy8gZGVmaW5pdGlvbnMgb3IgcmVsYXRpdmUgVVJMc1xuICAgICAgc2FmZTogdHJ1ZSxcbiAgICAgIHNraXBFeHBhbnNpb24sXG4gICAgICB1c2VOYXRpdmU6IHRoaXMudXNlTmF0aXZlQ2Fub25pemUsXG4gICAgICAuLi50aGlzLmNhbm9uaXplT3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgY2Fub25pemVQcm9vZihwcm9vZiwge2RvY3VtZW50LCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSkge1xuICAgIGlmKGV4cGFuc2lvbk1hcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImV4cGFuc2lvbk1hcFwiIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIC8vIGBqd3NgLGBzaWduYXR1cmVWYWx1ZWAsYHByb29mVmFsdWVgIG11c3Qgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBwcm9vZlxuICAgIC8vIG9wdGlvbnNcbiAgICBwcm9vZiA9IHtcbiAgICAgICdAY29udGV4dCc6IGRvY3VtZW50WydAY29udGV4dCddIHx8IGNvbnN0YW50cy5TRUNVUklUWV9DT05URVhUX1VSTCxcbiAgICAgIC4uLnByb29mXG4gICAgfTtcbiAgICBkZWxldGUgcHJvb2YuandzO1xuICAgIGRlbGV0ZSBwcm9vZi5zaWduYXR1cmVWYWx1ZTtcbiAgICBkZWxldGUgcHJvb2YucHJvb2ZWYWx1ZTtcbiAgICByZXR1cm4gdGhpcy5jYW5vbml6ZShwcm9vZiwge1xuICAgICAgZG9jdW1lbnRMb2FkZXIsXG4gICAgICBleHBhbnNpb25NYXAsXG4gICAgICBza2lwRXhwYW5zaW9uOiBmYWxzZSxcbiAgICAgIC4uLnRoaXMuY2Fub25pemVPcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIGJlIHNpZ25lZC92ZXJpZmllZC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucHJvb2YgLSBUaGUgcHJvb2YgdG8gYmUgdmVyaWZpZWQuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMucHJvb2ZTZXQgLSBBbnkgZXhpc3RpbmcgcHJvb2Ygc2V0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmRvY3VtZW50TG9hZGVyIC0gVGhlIGRvY3VtZW50IGxvYWRlciB0byB1c2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZXhwYW5zaW9uTWFwIC0gTk9UIFNVUFBPUlRFRDsgZG8gbm90IHVzZS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8e1VpbnQ4QXJyYXl9Pn0uXG4gICAqL1xuICBhc3luYyBjcmVhdGVWZXJpZnlEYXRhKHtkb2N1bWVudCwgcHJvb2YsIGRvY3VtZW50TG9hZGVyLCBleHBhbnNpb25NYXB9KSB7XG4gICAgaWYoZXhwYW5zaW9uTWFwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXhwYW5zaW9uTWFwXCIgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgLy8gZ2V0IGNhY2hlZCBkb2N1bWVudCBoYXNoXG4gICAgbGV0IGNhY2hlZERvY0hhc2g7XG4gICAgY29uc3Qge19oYXNoQ2FjaGV9ID0gdGhpcztcbiAgICBpZihfaGFzaENhY2hlICYmIF9oYXNoQ2FjaGUuZG9jdW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICBjYWNoZWREb2NIYXNoID0gX2hhc2hDYWNoZS5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYXNoQ2FjaGUgPSB7XG4gICAgICAgIGRvY3VtZW50LFxuICAgICAgICAvLyBjYW5vbml6ZSBhbmQgaGFzaCBkb2N1bWVudFxuICAgICAgICBoYXNoOiBjYWNoZWREb2NIYXNoID1cbiAgICAgICAgICB0aGlzLmNhbm9uaXplKGRvY3VtZW50LCB7ZG9jdW1lbnRMb2FkZXIsIGV4cGFuc2lvbk1hcH0pXG4gICAgICAgICAgICAudGhlbihjMTRuRG9jdW1lbnQgPT4gc2hhMjU2ZGlnZXN0KHtzdHJpbmc6IGMxNG5Eb2N1bWVudH0pKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBhd2FpdCBib3RoIGMxNG4gcHJvb2YgaGFzaCBhbmQgYzE0biBkb2N1bWVudCBoYXNoXG4gICAgY29uc3QgW3Byb29mSGFzaCwgZG9jSGFzaF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAvLyBjYW5vbml6ZSBhbmQgaGFzaCBwcm9vZlxuICAgICAgdGhpcy5jYW5vbml6ZVByb29mKFxuICAgICAgICBwcm9vZiwge2RvY3VtZW50LCBkb2N1bWVudExvYWRlciwgZXhwYW5zaW9uTWFwfSlcbiAgICAgICAgLnRoZW4oYzE0blByb29mT3B0aW9ucyA9PiBzaGEyNTZkaWdlc3Qoe3N0cmluZzogYzE0blByb29mT3B0aW9uc30pKSxcbiAgICAgIGNhY2hlZERvY0hhc2hcbiAgICBdKTtcblxuICAgIC8vIGNvbmNhdGVuYXRlIGhhc2ggb2YgYzE0biBwcm9vZiBvcHRpb25zIGFuZCBoYXNoIG9mIGMxNG4gZG9jdW1lbnRcbiAgICByZXR1cm4gdXRpbC5jb25jYXQocHJvb2ZIYXNoLCBkb2NIYXNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdmVyaWZ5RGF0YSB7VWludDhBcnJheX0uXG4gICAqIEBwYXJhbSBkb2N1bWVudCB7b2JqZWN0fSBkb2N1bWVudCBmcm9tIHdoaWNoIHRvIGRlcml2ZSBhIG5ldyBkb2N1bWVudFxuICAgKiAgIGFuZCBwcm9vZi5cbiAgICogQHBhcmFtIHByb29mIHtvYmplY3R9XG4gICAqIEBwYXJhbSBwcm9vZlNldCB7QXJyYXl9XG4gICAqIEBwYXJhbSBkb2N1bWVudExvYWRlciB7ZnVuY3Rpb259XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtvYmplY3R9Pn0gVGhlIG5ldyBkb2N1bWVudCB3aXRoIGBwcm9vZmAuXG4gICAqL1xuICBhc3luYyBkZXJpdmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgZGVyaXZlZCBjbGFzcy4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZG9jdW1lbnQge29iamVjdH0gdG8gYmUgc2lnbmVkLlxuICAgKiBAcGFyYW0gcHJvb2Yge29iamVjdH1cbiAgICogQHBhcmFtIGRvY3VtZW50TG9hZGVyIHtmdW5jdGlvbn1cbiAgICovXG4gIGFzeW5jIGdldFZlcmlmaWNhdGlvbk1ldGhvZCh7cHJvb2YsIGRvY3VtZW50TG9hZGVyfSkge1xuICAgIGxldCB7dmVyaWZpY2F0aW9uTWV0aG9kfSA9IHByb29mO1xuXG4gICAgaWYodHlwZW9mIHZlcmlmaWNhdGlvbk1ldGhvZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZlcmlmaWNhdGlvbk1ldGhvZCA9IHZlcmlmaWNhdGlvbk1ldGhvZC5pZDtcbiAgICB9XG5cbiAgICBpZighdmVyaWZpY2F0aW9uTWV0aG9kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwidmVyaWZpY2F0aW9uTWV0aG9kXCIgZm91bmQgaW4gcHJvb2YuJyk7XG4gICAgfVxuXG4gICAgLy8gTm90ZTogYGV4cGFuc2lvbk1hcGAgaXMgaW50ZW50aW9uYWxseSBub3QgcGFzc2VkOyB3ZSBjYW4gc2FmZWx5IGRyb3BcbiAgICAvLyBwcm9wZXJ0aWVzIGhlcmUgYW5kIG11c3QgYWxsb3cgZm9yIGl0XG4gICAgY29uc3QgZnJhbWVkID0gYXdhaXQganNvbmxkLmZyYW1lKHZlcmlmaWNhdGlvbk1ldGhvZCwge1xuICAgICAgJ0Bjb250ZXh0JzogY29uc3RhbnRzLlNFQ1VSSVRZX0NPTlRFWFRfVVJMLFxuICAgICAgJ0BlbWJlZCc6ICdAYWx3YXlzJyxcbiAgICAgIGlkOiB2ZXJpZmljYXRpb25NZXRob2RcbiAgICB9LCB7ZG9jdW1lbnRMb2FkZXIsIGNvbXBhY3RUb1JlbGF0aXZlOiBmYWxzZSwgc2FmZTogdHJ1ZX0pO1xuICAgIGlmKCFmcmFtZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyaWZpY2F0aW9uIG1ldGhvZCAke3ZlcmlmaWNhdGlvbk1ldGhvZH0gbm90IGZvdW5kLmApO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSB2ZXJpZmljYXRpb24gbWV0aG9kIGhhcyBub3QgYmVlbiByZXZva2VkXG4gICAgaWYoZnJhbWVkLnJldm9rZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmVyaWZpY2F0aW9uIG1ldGhvZCBoYXMgYmVlbiByZXZva2VkLicpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFtZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHZlcmlmeURhdGEge1VpbnQ4QXJyYXl9LlxuICAgKiBAcGFyYW0gZG9jdW1lbnQge29iamVjdH0gdG8gYmUgc2lnbmVkLlxuICAgKiBAcGFyYW0gcHJvb2Yge29iamVjdH1cbiAgICogQHBhcmFtIGRvY3VtZW50TG9hZGVyIHtmdW5jdGlvbn1cbiAgICogQHBhcmFtIGV4cGFuc2lvbk1hcCB7ZnVuY3Rpb259XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHtvYmplY3R9Pn0gdGhlIHByb29mIGNvbnRhaW5pbmcgdGhlIHNpZ25hdHVyZSB2YWx1ZS5cbiAgICovXG4gIGFzeW5jIHNpZ24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgZGVyaXZlZCBjbGFzcy4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdmVyaWZ5RGF0YSB7VWludDhBcnJheX0uXG4gICAqIEBwYXJhbSB2ZXJpZmljYXRpb25NZXRob2Qge29iamVjdH0uXG4gICAqIEBwYXJhbSBkb2N1bWVudCB7b2JqZWN0fSB0byBiZSBzaWduZWQuXG4gICAqIEBwYXJhbSBwcm9vZiB7b2JqZWN0fVxuICAgKiBAcGFyYW0gZG9jdW1lbnRMb2FkZXIge2Z1bmN0aW9ufVxuICAgKiBAcGFyYW0gZXhwYW5zaW9uTWFwIHtmdW5jdGlvbn1cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyB2ZXJpZnlTaWduYXR1cmUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgZGVyaXZlZCBjbGFzcy4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBkb2N1bWVudCB0byBiZSBzaWduZWQgY29udGFpbnMgdGhlIHJlcXVpcmVkIHNpZ25hdHVyZSBzdWl0ZVxuICAgKiBzcGVjaWZpYyBgQGNvbnRleHRgLCBieSBlaXRoZXIgYWRkaW5nIGl0IChpZiBgYWRkU3VpdGVDb250ZXh0YCBpcyB0cnVlKSxcbiAgICogb3IgdGhyb3dpbmcgYW4gZXJyb3IgaWYgaXQncyBtaXNzaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgaGFzaG1hcC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuZG9jdW1lbnQgLSBKU09OLUxEIGRvY3VtZW50IHRvIGJlIHNpZ25lZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmFkZFN1aXRlQ29udGV4dCAtIEFkZCBzdWl0ZSBjb250ZXh0P1xuICAgKi9cbiAgZW5zdXJlU3VpdGVDb250ZXh0KHtkb2N1bWVudCwgYWRkU3VpdGVDb250ZXh0fSkge1xuICAgIGNvbnN0IHtjb250ZXh0VXJsfSA9IHRoaXM7XG5cbiAgICBpZihfaW5jbHVkZXNDb250ZXh0KHtkb2N1bWVudCwgY29udGV4dFVybH0pKSB7XG4gICAgICAvLyBkb2N1bWVudCBhbHJlYWR5IGluY2x1ZGVzIHRoZSByZXF1aXJlZCBjb250ZXh0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIWFkZFN1aXRlQ29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFRoZSBkb2N1bWVudCB0byBiZSBzaWduZWQgbXVzdCBjb250YWluIHRoaXMgc3VpdGUncyBAY29udGV4dCwgYCArXG4gICAgICAgIGBcIiR7Y29udGV4dFVybH1cIi5gKTtcbiAgICB9XG5cbiAgICAvLyBlbmZvcmNlIHRoZSBzdWl0ZSdzIGNvbnRleHQgYnkgYWRkaW5nIGl0IHRvIHRoZSBkb2N1bWVudFxuICAgIGNvbnN0IGV4aXN0aW5nQ29udGV4dCA9IGRvY3VtZW50WydAY29udGV4dCddIHx8IFtdO1xuXG4gICAgZG9jdW1lbnRbJ0Bjb250ZXh0J10gPSBBcnJheS5pc0FycmF5KGV4aXN0aW5nQ29udGV4dCkgP1xuICAgICAgWy4uLmV4aXN0aW5nQ29udGV4dCwgY29udGV4dFVybF0gOiBbZXhpc3RpbmdDb250ZXh0LCBjb250ZXh0VXJsXTtcbiAgfVxufTtcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGEgcHJvdmlkZWQgSlNPTi1MRCBkb2N1bWVudCBpbmNsdWRlcyBhIGNvbnRleHQgVVJMIGluIGl0c1xuICogYEBjb250ZXh0YCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgaGFzaG1hcC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRvY3VtZW50IC0gQSBKU09OLUxEIGRvY3VtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29udGV4dFVybCAtIEEgY29udGV4dCBVUkwuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBkb2N1bWVudCBpbmNsdWRlcyBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBfaW5jbHVkZXNDb250ZXh0KHtkb2N1bWVudCwgY29udGV4dFVybH0pIHtcbiAgY29uc3QgY29udGV4dCA9IGRvY3VtZW50WydAY29udGV4dCddO1xuICByZXR1cm4gY29udGV4dCA9PT0gY29udGV4dFVybCB8fFxuICAgIChBcnJheS5pc0FycmF5KGNvbnRleHQpICYmIGNvbnRleHQuaW5jbHVkZXMoY29udGV4dFVybCkpO1xufVxuXG4vKipcbiAqIFNlZSBjb25zdHJ1Y3RvciBkb2NzdHJpbmcgZm9yIHBhcmFtIGRldGFpbHMuXG4gKlxuICogQHJldHVybnMge3t2ZXJpZmljYXRpb25NZXRob2Q6IHN0cmluZywga2V5OiBMREtleVBhaXIsXG4gKiAgIHNpZ25lcjoge3NpZ246IEZ1bmN0aW9uLCBpZDogc3RyaW5nfSxcbiAqICAgdmVyaWZpZXI6IHt2ZXJpZnk6IEZ1bmN0aW9uLCBpZDogc3RyaW5nfX19IC0gVmFsaWRhdGVkIGFuZCBpbml0aWFsaXplZFxuICogICBrZXktcmVsYXRlZCBwYXJhbWV0ZXJzLlxuICovXG5mdW5jdGlvbiBfcHJvY2Vzc1NpZ25hdHVyZVBhcmFtcyh7a2V5LCBzaWduZXIsIHZlcmlmaWVyfSkge1xuICAvLyBXZSBhcmUgZXhwbGljaXRseSBub3QgcmVxdWlyaW5nIGEga2V5IG9yIHNpZ25lci92ZXJpZmllciBwYXJhbSB0byBiZVxuICAvLyBwcmVzZW50LCB0byBzdXBwb3J0IHRoZSB2ZXJpZnkoKSB1c2UgY2FzZSB3aGVyZSB0aGUgdmVyaWZpY2F0aW9uTWV0aG9kXG4gIC8vIGlzIGJlaW5nIGZldGNoZWQgYnkgdGhlIGRvY3VtZW50TG9hZGVyXG5cbiAgY29uc3Qgdm0gPSB7fTtcbiAgaWYoa2V5KSB7XG4gICAgdm0ua2V5ID0ga2V5O1xuICAgIHZtLnZlcmlmaWNhdGlvbk1ldGhvZCA9IGtleS5pZDtcbiAgICBpZih0eXBlb2Yga2V5LnNpZ25lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdm0uc2lnbmVyID0ga2V5LnNpZ25lcigpO1xuICAgIH1cbiAgICBpZih0eXBlb2Yga2V5LnZlcmlmaWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2bS52ZXJpZmllciA9IGtleS52ZXJpZmllcigpO1xuICAgIH1cbiAgICBpZighKHZtLnNpZ25lciB8fCB2bS52ZXJpZmllcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJrZXlcIiBwYXJhbWV0ZXIgbXVzdCBjb250YWluIGEgXCJzaWduZXJcIiBvciBcInZlcmlmaWVyXCIgbWV0aG9kLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2bS52ZXJpZmljYXRpb25NZXRob2QgPSAoc2lnbmVyICYmIHNpZ25lci5pZCkgfHxcbiAgICAgICh2ZXJpZmllciAmJiB2ZXJpZmllci5pZCk7XG4gICAgdm0uc2lnbmVyID0gc2lnbmVyO1xuICAgIHZtLnZlcmlmaWVyID0gdmVyaWZpZXI7XG4gIH1cblxuICBpZih2bS5zaWduZXIpIHtcbiAgICBpZih0eXBlb2Ygdm0uc2lnbmVyLnNpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Egc2lnbmVyIEFQSSBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgfVxuICBpZih2bS52ZXJpZmllcikge1xuICAgIGlmKHR5cGVvZiB2bS52ZXJpZmllci52ZXJpZnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgdmVyaWZpZXIgQVBJIGhhcyBub3QgYmVlbiBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZtO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfY2Fub25pemUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgLy8gY29udmVydCB0byBSREYgZGF0YXNldCBhbmQgZG8gY2Fub25pY2FsaXphdGlvblxuICBjb25zdCBvcHRzID0ge1xuICAgIHJkZkRpcmVjdGlvbjogJ2kxOG4tZGF0YXR5cGUnLCAuLi5vcHRpb25zLCBwcm9kdWNlR2VuZXJhbGl6ZWRSZGY6IGZhbHNlLFxuICB9O1xuICBkZWxldGUgb3B0cy5mb3JtYXQ7XG4gIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCBqc29ubGQudG9SREYoaW5wdXQsIG9wdHMpO1xuICByZXR1cm4gcmRmQ2Fub25pemUuY2Fub25pemUoZGF0YXNldCwgb3B0aW9ucyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/lib/util.js":
/*!****************************************************!*\
  !*** ./node_modules/jsonld-signatures/lib/util.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts the given date into W3C datetime format (eg: 2011-03-09T21:55:41Z).\n *\n * @param date the date to convert.\n *\n * @return the date in W3C datetime format.\n */\napi.w3cDate = date => {\n  if(date === undefined || date === null) {\n    date = new Date();\n  } else if(typeof date === 'number' || typeof date === 'string') {\n    date = new Date(date);\n  }\n  const str = date.toISOString();\n  return str.substr(0, str.length - 5) + 'Z';\n};\n\n/**\n * Concatenates two Uint8Arrays.\n *\n * @param b1 {Uint8Array}.\n * @param b2 {Uint8Array}.\n *\n * @return {Uint8Array} the result.\n */\napi.concat = (b1, b2) => {\n  const rval = new Uint8Array(b1.length + b2.length);\n  rval.set(b1, 0);\n  rval.set(b2, b1.length);\n  return rval;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QixjQUFjLFdBQVc7QUFDekI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbGliL3V0aWwuanM/NjJiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3LTIwMjEgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcGkgPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBkYXRlIGludG8gVzNDIGRhdGV0aW1lIGZvcm1hdCAoZWc6IDIwMTEtMDMtMDlUMjE6NTU6NDFaKS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBjb252ZXJ0LlxuICpcbiAqIEByZXR1cm4gdGhlIGRhdGUgaW4gVzNDIGRhdGV0aW1lIGZvcm1hdC5cbiAqL1xuYXBpLnczY0RhdGUgPSBkYXRlID0+IHtcbiAgaWYoZGF0ZSA9PT0gdW5kZWZpbmVkIHx8IGRhdGUgPT09IG51bGwpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIH1cbiAgY29uc3Qgc3RyID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gNSkgKyAnWic7XG59O1xuXG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gVWludDhBcnJheXMuXG4gKlxuICogQHBhcmFtIGIxIHtVaW50OEFycmF5fS5cbiAqIEBwYXJhbSBiMiB7VWludDhBcnJheX0uXG4gKlxuICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIHJlc3VsdC5cbiAqL1xuYXBpLmNvbmNhdCA9IChiMSwgYjIpID0+IHtcbiAgY29uc3QgcnZhbCA9IG5ldyBVaW50OEFycmF5KGIxLmxlbmd0aCArIGIyLmxlbmd0aCk7XG4gIHJ2YWwuc2V0KGIxLCAwKTtcbiAgcnZhbC5zZXQoYjIsIGIxLmxlbmd0aCk7XG4gIHJldHVybiBydmFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/lib/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * An implementation of the RDF Dataset Normalization specification.\n *\n * @author Dave Longley\n *\n * Copyright 2010-2021 Digital Bazaar, Inc.\n */\nmodule.exports = __webpack_require__(/*! ./lib */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtJQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9ub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2luZGV4LmpzPzRmZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUkRGIERhdGFzZXQgTm9ybWFsaXphdGlvbiBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIEBhdXRob3IgRGF2ZSBMb25nbGV5XG4gKlxuICogQ29weXJpZ2h0IDIwMTAtMjAyMSBEaWdpdGFsIEJhemFhciwgSW5jLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js ***!
  \******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class IdentifierIssuer {\n  /**\n   * Creates a new IdentifierIssuer. A IdentifierIssuer issues unique\n   * identifiers, keeping track of any previously issued identifiers.\n   *\n   * @param {string} prefix - The prefix to use ('<prefix><counter>').\n   * @param {Map} [existing] - An existing Map to use.\n   * @param {number} [counter] - The counter to use.\n   */\n  constructor(prefix, existing = new Map(), counter = 0) {\n    this.prefix = prefix;\n    this._existing = existing;\n    this.counter = counter;\n  }\n\n  /**\n   * Copies this IdentifierIssuer.\n   *\n   * @returns {object} - A copy of this IdentifierIssuer.\n   */\n  clone() {\n    const {prefix, _existing, counter} = this;\n    return new IdentifierIssuer(prefix, new Map(_existing), counter);\n  }\n\n  /**\n   * Gets the new identifier for the given old identifier, where if no old\n   * identifier is given a new identifier will be generated.\n   *\n   * @param {string} [old] - The old identifier to get the new identifier for.\n   *\n   * @returns {string} - The new identifier.\n   */\n  getId(old) {\n    // return existing old identifier\n    const existing = old && this._existing.get(old);\n    if(existing) {\n      return existing;\n    }\n\n    // get next identifier\n    const identifier = this.prefix + this.counter;\n    this.counter++;\n\n    // save mapping\n    if(old) {\n      this._existing.set(old, identifier);\n    }\n\n    return identifier;\n  }\n\n  /**\n   * Returns true if the given old identifer has already been assigned a new\n   * identifier.\n   *\n   * @param {string} old - The old identifier to check.\n   *\n   * @returns {boolean} - True if the old identifier has been assigned a new\n   *   identifier, false if not.\n   */\n  hasId(old) {\n    return this._existing.has(old);\n  }\n\n  /**\n   * Returns all of the IDs that have been issued new IDs in the order in\n   * which they were issued new IDs.\n   *\n   * @returns {Array} - The list of old IDs that has been issued new IDs in\n   *   order.\n   */\n  getOldIds() {\n    return [...this._existing.keys()];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvSWRlbnRpZmllcklzc3Vlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9ub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9JZGVudGlmaWVySXNzdWVyLmpzPzEyMDgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIxIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJZGVudGlmaWVySXNzdWVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSWRlbnRpZmllcklzc3Vlci4gQSBJZGVudGlmaWVySXNzdWVyIGlzc3VlcyB1bmlxdWVcbiAgICogaWRlbnRpZmllcnMsIGtlZXBpbmcgdHJhY2sgb2YgYW55IHByZXZpb3VzbHkgaXNzdWVkIGlkZW50aWZpZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gVGhlIHByZWZpeCB0byB1c2UgKCc8cHJlZml4Pjxjb3VudGVyPicpLlxuICAgKiBAcGFyYW0ge01hcH0gW2V4aXN0aW5nXSAtIEFuIGV4aXN0aW5nIE1hcCB0byB1c2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRlcl0gLSBUaGUgY291bnRlciB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwcmVmaXgsIGV4aXN0aW5nID0gbmV3IE1hcCgpLCBjb3VudGVyID0gMCkge1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuX2V4aXN0aW5nID0gZXhpc3Rpbmc7XG4gICAgdGhpcy5jb3VudGVyID0gY291bnRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhpcyBJZGVudGlmaWVySXNzdWVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIEEgY29weSBvZiB0aGlzIElkZW50aWZpZXJJc3N1ZXIuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCB7cHJlZml4LCBfZXhpc3RpbmcsIGNvdW50ZXJ9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IElkZW50aWZpZXJJc3N1ZXIocHJlZml4LCBuZXcgTWFwKF9leGlzdGluZyksIGNvdW50ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5ldyBpZGVudGlmaWVyIGZvciB0aGUgZ2l2ZW4gb2xkIGlkZW50aWZpZXIsIHdoZXJlIGlmIG5vIG9sZFxuICAgKiBpZGVudGlmaWVyIGlzIGdpdmVuIGEgbmV3IGlkZW50aWZpZXIgd2lsbCBiZSBnZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb2xkXSAtIFRoZSBvbGQgaWRlbnRpZmllciB0byBnZXQgdGhlIG5ldyBpZGVudGlmaWVyIGZvci5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbmV3IGlkZW50aWZpZXIuXG4gICAqL1xuICBnZXRJZChvbGQpIHtcbiAgICAvLyByZXR1cm4gZXhpc3Rpbmcgb2xkIGlkZW50aWZpZXJcbiAgICBjb25zdCBleGlzdGluZyA9IG9sZCAmJiB0aGlzLl9leGlzdGluZy5nZXQob2xkKTtcbiAgICBpZihleGlzdGluZykge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cblxuICAgIC8vIGdldCBuZXh0IGlkZW50aWZpZXJcbiAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy5wcmVmaXggKyB0aGlzLmNvdW50ZXI7XG4gICAgdGhpcy5jb3VudGVyKys7XG5cbiAgICAvLyBzYXZlIG1hcHBpbmdcbiAgICBpZihvbGQpIHtcbiAgICAgIHRoaXMuX2V4aXN0aW5nLnNldChvbGQsIGlkZW50aWZpZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBpZGVudGlmaWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2xkIGlkZW50aWZlciBoYXMgYWxyZWFkeSBiZWVuIGFzc2lnbmVkIGEgbmV3XG4gICAqIGlkZW50aWZpZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGQgLSBUaGUgb2xkIGlkZW50aWZpZXIgdG8gY2hlY2suXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIG9sZCBpZGVudGlmaWVyIGhhcyBiZWVuIGFzc2lnbmVkIGEgbmV3XG4gICAqICAgaWRlbnRpZmllciwgZmFsc2UgaWYgbm90LlxuICAgKi9cbiAgaGFzSWQob2xkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4aXN0aW5nLmhhcyhvbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBJRHMgdGhhdCBoYXZlIGJlZW4gaXNzdWVkIG5ldyBJRHMgaW4gdGhlIG9yZGVyIGluXG4gICAqIHdoaWNoIHRoZXkgd2VyZSBpc3N1ZWQgbmV3IElEcy5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSAtIFRoZSBsaXN0IG9mIG9sZCBJRHMgdGhhdCBoYXMgYmVlbiBpc3N1ZWQgbmV3IElEcyBpblxuICAgKiAgIG9yZGVyLlxuICAgKi9cbiAgZ2V0T2xkSWRzKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5fZXhpc3Rpbmcua2V5cygpXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * Copyright (c) 2016-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst algorithmMap = new Map([\n  ['sha256', 'sha256'],\n  ['SHA256', 'sha256'],\n  ['SHA-256', 'sha256'],\n  ['sha384', 'sha384'],\n  ['SHA384', 'sha384'],\n  ['SHA-384', 'sha384'],\n  ['sha512', 'sha512'],\n  ['SHA512', 'sha512'],\n  ['SHA-512', 'sha512'],\n]);\n\nmodule.exports = class MessageDigest {\n  /**\n   * Creates a new MessageDigest.\n   *\n   * @param {string} algorithm - The algorithm to use.\n   */\n  constructor(algorithm) {\n    if(!algorithmMap.has(algorithm)) {\n      throw new Error(`Unsupported algorithm \"${algorithm}\".`);\n    }\n    this.md = crypto.createHash(algorithmMap.get(algorithm));\n  }\n\n  update(msg) {\n    this.md.update(msg, 'utf8');\n  }\n\n  // async code awaits this but it is not async to support\n  // the sync code\n  digest() {\n    return this.md.digest('hex');\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvTWVzc2FnZURpZ2VzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvTWVzc2FnZURpZ2VzdC5qcz80OWM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMyBEaWdpdGFsIEJhemFhciwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBhbGdvcml0aG1NYXAgPSBuZXcgTWFwKFtcbiAgWydzaGEyNTYnLCAnc2hhMjU2J10sXG4gIFsnU0hBMjU2JywgJ3NoYTI1NiddLFxuICBbJ1NIQS0yNTYnLCAnc2hhMjU2J10sXG4gIFsnc2hhMzg0JywgJ3NoYTM4NCddLFxuICBbJ1NIQTM4NCcsICdzaGEzODQnXSxcbiAgWydTSEEtMzg0JywgJ3NoYTM4NCddLFxuICBbJ3NoYTUxMicsICdzaGE1MTInXSxcbiAgWydTSEE1MTInLCAnc2hhNTEyJ10sXG4gIFsnU0hBLTUxMicsICdzaGE1MTInXSxcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1lc3NhZ2VEaWdlc3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlRGlnZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnb3JpdGhtIC0gVGhlIGFsZ29yaXRobSB0byB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhbGdvcml0aG0pIHtcbiAgICBpZighYWxnb3JpdGhtTWFwLmhhcyhhbGdvcml0aG0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFsZ29yaXRobSBcIiR7YWxnb3JpdGhtfVwiLmApO1xuICAgIH1cbiAgICB0aGlzLm1kID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtTWFwLmdldChhbGdvcml0aG0pKTtcbiAgfVxuXG4gIHVwZGF0ZShtc2cpIHtcbiAgICB0aGlzLm1kLnVwZGF0ZShtc2csICd1dGY4Jyk7XG4gIH1cblxuICAvLyBhc3luYyBjb2RlIGF3YWl0cyB0aGlzIGJ1dCBpdCBpcyBub3QgYXN5bmMgdG8gc3VwcG9ydFxuICAvLyB0aGUgc3luYyBjb2RlXG4gIGRpZ2VzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZC5kaWdlc3QoJ2hleCcpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\n// eslint-disable-next-line no-unused-vars\nconst TERMS = ['subject', 'predicate', 'object', 'graph'];\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst RDF_LANGSTRING = RDF + 'langString';\nconst XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nconst TYPE_NAMED_NODE = 'NamedNode';\nconst TYPE_BLANK_NODE = 'BlankNode';\nconst TYPE_LITERAL = 'Literal';\nconst TYPE_DEFAULT_GRAPH = 'DefaultGraph';\n\n// build regexes\nconst REGEX = {};\n(() => {\n  // https://www.w3.org/TR/n-quads/#sec-grammar\n  // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n  const PN_CHARS_BASE =\n    'A-Z' + 'a-z' +\n    '\\u00C0-\\u00D6' +\n    '\\u00D8-\\u00F6' +\n    '\\u00F8-\\u02FF' +\n    '\\u0370-\\u037D' +\n    '\\u037F-\\u1FFF' +\n    '\\u200C-\\u200D' +\n    '\\u2070-\\u218F' +\n    '\\u2C00-\\u2FEF' +\n    '\\u3001-\\uD7FF' +\n    '\\uF900-\\uFDCF' +\n    '\\uFDF0-\\uFFFD';\n    // TODO:\n    //'\\u10000-\\uEFFFF';\n  const PN_CHARS_U =\n    PN_CHARS_BASE +\n    '_';\n  const PN_CHARS =\n    PN_CHARS_U +\n    '0-9' +\n    '-' +\n    '\\u00B7' +\n    '\\u0300-\\u036F' +\n    '\\u203F-\\u2040';\n  const BLANK_NODE_LABEL =\n    '_:(' +\n      '(?:[' + PN_CHARS_U + '0-9])' +\n      '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' +\n    ')';\n  // Older simple regex: const IRI = '(?:<([^:]+:[^>]*)>)';\n  const UCHAR4 = '\\\\\\\\u[0-9A-Fa-f]{4}';\n  const UCHAR8 = '\\\\\\\\U[0-9A-Fa-f]{8}';\n  const IRI = '(?:<((?:' +\n    '[^\\u0000-\\u0020<>\"{}|^`\\\\\\\\]' + '|' +\n    UCHAR4 + '|' +\n    UCHAR8 +\n    ')*)>)';\n  const bnode = BLANK_NODE_LABEL;\n  const plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  const datatype = '(?:\\\\^\\\\^' + IRI + ')';\n  const language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  const literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  const ws = '[ \\\\t]+';\n  const wso = '[ \\\\t]*';\n\n  // define quad part regexes\n  const subject = '(?:' + IRI + '|' + bnode + ')' + ws;\n  const property = IRI + ws;\n  const object = '(?:' + IRI + '|' + bnode + '|' + literal + ')' + wso;\n  const graphName = '(?:\\\\.|(?:(?:' + IRI + '|' + bnode + ')' + wso + '\\\\.))';\n\n  // end of line and empty regexes\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$');\n\n  // full quad regex\n  REGEX.quad = new RegExp(\n    '^' + wso + subject + property + object + graphName + wso + '$');\n})();\n\nmodule.exports = class NQuads {\n  /**\n   * Parses RDF in the form of N-Quads.\n   *\n   * @param {string} input - The N-Quads input to parse.\n   *\n   * @returns {Array} - An RDF dataset (an array of quads per\n   *   https://rdf.js.org/).\n   */\n  static parse(input) {\n    // build RDF dataset\n    const dataset = [];\n\n    const graphs = {};\n\n    // split N-Quad input into lines\n    const lines = input.split(REGEX.eoln);\n    let lineNumber = 0;\n    for(const line of lines) {\n      lineNumber++;\n\n      // skip empty lines\n      if(REGEX.empty.test(line)) {\n        continue;\n      }\n\n      // parse quad\n      const match = line.match(REGEX.quad);\n      if(match === null) {\n        throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n      }\n\n      // create RDF quad\n      const quad = {subject: null, predicate: null, object: null, graph: null};\n\n      // get subject\n      if(match[1] !== undefined) {\n        quad.subject = {\n          termType: TYPE_NAMED_NODE,\n          value: _iriUnescape(match[1])\n        };\n      } else {\n        quad.subject = {\n          termType: TYPE_BLANK_NODE,\n          value: match[2]\n        };\n      }\n\n      // get predicate\n      quad.predicate = {\n        termType: TYPE_NAMED_NODE,\n        value: _iriUnescape(match[3])\n      };\n\n      // get object\n      if(match[4] !== undefined) {\n        quad.object = {\n          termType: TYPE_NAMED_NODE,\n          value: _iriUnescape(match[4])\n        };\n      } else if(match[5] !== undefined) {\n        quad.object = {\n          termType: TYPE_BLANK_NODE,\n          value: match[5]\n        };\n      } else {\n        quad.object = {\n          termType: TYPE_LITERAL,\n          value: undefined,\n          datatype: {\n            termType: TYPE_NAMED_NODE\n          }\n        };\n        if(match[7] !== undefined) {\n          quad.object.datatype.value = _iriUnescape(match[7]);\n        } else if(match[8] !== undefined) {\n          quad.object.datatype.value = RDF_LANGSTRING;\n          quad.object.language = match[8];\n        } else {\n          quad.object.datatype.value = XSD_STRING;\n        }\n        quad.object.value = _stringLiteralUnescape(match[6]);\n      }\n\n      // get graph\n      if(match[9] !== undefined) {\n        quad.graph = {\n          termType: TYPE_NAMED_NODE,\n          value: _iriUnescape(match[9])\n        };\n      } else if(match[10] !== undefined) {\n        quad.graph = {\n          termType: TYPE_BLANK_NODE,\n          value: match[10]\n        };\n      } else {\n        quad.graph = {\n          termType: TYPE_DEFAULT_GRAPH,\n          value: ''\n        };\n      }\n\n      // only add quad if it is unique in its graph\n      if(!(quad.graph.value in graphs)) {\n        graphs[quad.graph.value] = [quad];\n        dataset.push(quad);\n      } else {\n        let unique = true;\n        const quads = graphs[quad.graph.value];\n        for(const q of quads) {\n          if(_compareTriples(q, quad)) {\n            unique = false;\n            break;\n          }\n        }\n        if(unique) {\n          quads.push(quad);\n          dataset.push(quad);\n        }\n      }\n    }\n\n    return dataset;\n  }\n\n  /**\n   * Converts an RDF dataset to N-Quads.\n   *\n   * @param {Array} dataset - The Array of quads RDF dataset to convert.\n   *\n   * @returns {string} - The N-Quads string.\n   */\n  static serialize(dataset) {\n    const quads = [];\n    for(const quad of dataset) {\n      quads.push(NQuads.serializeQuad(quad));\n    }\n    return quads.sort().join('');\n  }\n\n  /**\n   * Converts RDF quad components to an N-Quad string (a single quad).\n   *\n   * @param {object} s - N-Quad subject component.\n   * @param {object} p - N-Quad predicate component.\n   * @param {object} o - N-Quad object component.\n   * @param {object} g - N-Quad graph component.\n   *\n   * @returns {string} - The N-Quad.\n   */\n  static serializeQuadComponents(s, p, o, g) {\n    let nquad = '';\n\n    // subject can only be NamedNode or BlankNode\n    if(s.termType === TYPE_NAMED_NODE) {\n      nquad += `<${_iriEscape(s.value)}>`;\n    } else {\n      nquad += `_:${s.value}`;\n    }\n\n    // predicate normally a NamedNode, can be a BlankNode in generalized RDF\n    if(p.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${_iriEscape(p.value)}> `;\n    } else {\n      nquad += ` _:${p.value} `;\n    }\n\n    // object is NamedNode, BlankNode, or Literal\n    if(o.termType === TYPE_NAMED_NODE) {\n      nquad += `<${_iriEscape(o.value)}>`;\n    } else if(o.termType === TYPE_BLANK_NODE) {\n      nquad += `_:${o.value}`;\n    } else {\n      nquad += `\"${_stringLiteralEscape(o.value)}\"`;\n      if(o.datatype.value === RDF_LANGSTRING) {\n        if(o.language) {\n          nquad += `@${o.language}`;\n        }\n      } else if(o.datatype.value !== XSD_STRING) {\n        nquad += `^^<${_iriEscape(o.datatype.value)}>`;\n      }\n    }\n\n    // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n    // does not add to `nquad`)\n    if(g.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${_iriEscape(g.value)}>`;\n    } else if(g.termType === TYPE_BLANK_NODE) {\n      nquad += ` _:${g.value}`;\n    }\n\n    nquad += ' .\\n';\n    return nquad;\n  }\n\n  /**\n   * Converts an RDF quad to an N-Quad string (a single quad).\n   *\n   * @param {object} quad - The RDF quad convert.\n   *\n   * @returns {string} - The N-Quad string.\n   */\n  static serializeQuad(quad) {\n    return NQuads.serializeQuadComponents(\n      quad.subject, quad.predicate, quad.object, quad.graph);\n  }\n};\n\n/**\n * Compares two RDF triples for equality.\n *\n * @param {object} t1 - The first triple.\n * @param {object} t2 - The second triple.\n *\n * @returns {boolean} - True if the triples are the same, false if not.\n */\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if(!(t1.subject.termType === t2.subject.termType &&\n    t1.object.termType === t2.object.termType)) {\n    return false;\n  }\n  // compare values\n  if(!(t1.subject.value === t2.subject.value &&\n    t1.predicate.value === t2.predicate.value &&\n    t1.object.value === t2.object.value)) {\n    return false;\n  }\n  if(t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n  return (\n    (t1.object.datatype.termType === t2.object.datatype.termType) &&\n    (t1.object.language === t2.object.language) &&\n    (t1.object.datatype.value === t2.object.datatype.value)\n  );\n}\n\nconst _stringLiteralEscapeRegex = /[\\u0000-\\u001F\\u007F\"\\\\]/g;\nconst _stringLiteralEscapeMap = [];\nfor(let n = 0; n <= 0x7f; ++n) {\n  if(_stringLiteralEscapeRegex.test(String.fromCharCode(n))) {\n    // default UCHAR mapping\n    _stringLiteralEscapeMap[n] =\n      '\\\\u' + n.toString(16).toUpperCase().padStart(4, '0');\n    // reset regex\n    _stringLiteralEscapeRegex.lastIndex = 0;\n  }\n}\n// special ECHAR mappings\n_stringLiteralEscapeMap['\\b'.codePointAt(0)] = '\\\\b';\n_stringLiteralEscapeMap['\\t'.codePointAt(0)] = '\\\\t';\n_stringLiteralEscapeMap['\\n'.codePointAt(0)] = '\\\\n';\n_stringLiteralEscapeMap['\\f'.codePointAt(0)] = '\\\\f';\n_stringLiteralEscapeMap['\\r'.codePointAt(0)] = '\\\\r';\n_stringLiteralEscapeMap['\"' .codePointAt(0)] = '\\\\\"';\n_stringLiteralEscapeMap['\\\\'.codePointAt(0)] = '\\\\\\\\';\n\n/**\n * Escape string to N-Quads literal.\n *\n * @param {string} s - String to escape.\n *\n * @returns {string} - Escaped N-Quads literal.\n */\nfunction _stringLiteralEscape(s) {\n  if(!_stringLiteralEscapeRegex.test(s)) {\n    return s;\n  }\n  return s.replace(_stringLiteralEscapeRegex, function(match) {\n    return _stringLiteralEscapeMap[match.codePointAt(0)];\n  });\n}\n\nconst _stringLiteralUnescapeRegex =\n  /(?:\\\\([btnfr\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n\n/**\n * Unescape N-Quads literal to string.\n *\n * @param {string} s - String to unescape.\n *\n * @returns {string} - Unescaped N-Quads literal.\n */\nfunction _stringLiteralUnescape(s) {\n  if(!_stringLiteralUnescapeRegex.test(s)) {\n    return s;\n  }\n  return s.replace(_stringLiteralUnescapeRegex, function(match, code, u, U) {\n    if(code) {\n      switch(code) {\n        case 'b': return '\\b';\n        case 't': return '\\t';\n        case 'n': return '\\n';\n        case 'f': return '\\f';\n        case 'r': return '\\r';\n        case '\"': return '\"';\n        case '\\'': return '\\'';\n        case '\\\\': return '\\\\';\n      }\n    }\n    if(u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if(U) {\n      return String.fromCodePoint(parseInt(U, 16));\n    }\n  });\n}\n\nconst _iriEscapeRegex = /[\\u0000-\\u0020<>\"{}|^`\\\\]/g;\nconst _iriEscapeRegexMap = [];\nfor(let n = 0; n <= 0x7f; ++n) {\n  if(_iriEscapeRegex.test(String.fromCharCode(n))) {\n    // UCHAR mapping\n    _iriEscapeRegexMap[n] =\n      '\\\\u' + n.toString(16).toUpperCase().padStart(4, '0');\n    // reset regex\n    _iriEscapeRegex.lastIndex = 0;\n  }\n}\n\n/**\n * Escape IRI to N-Quads IRI.\n *\n * @param {string} s - IRI to escape.\n *\n * @returns {string} - Escaped N-Quads IRI.\n */\nfunction _iriEscape(s) {\n  if(!_iriEscapeRegex.test(s)) {\n    return s;\n  }\n  return s.replace(_iriEscapeRegex, function(match) {\n    return _iriEscapeRegexMap[match.codePointAt(0)];\n  });\n}\n\nconst _iriUnescapeRegex =\n  /(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n\n/**\n * Unescape N-Quads IRI to IRI.\n *\n * @param {string} s - IRI to unescape.\n *\n * @returns {string} - Unescaped N-Quads IRI.\n */\nfunction _iriUnescape(s) {\n  if(!_iriUnescapeRegex.test(s)) {\n    return s;\n  }\n  return s.replace(_iriUnescapeRegex, function(match, u, U) {\n    if(u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if(U) {\n      return String.fromCodePoint(parseInt(U, 16));\n    }\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvTlF1YWRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsbUNBQW1DLEVBQUU7QUFDckM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsTUFBTTtBQUNOLG9CQUFvQixRQUFRO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLE1BQU07QUFDTixxQkFBcUIsU0FBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QyxNQUFNO0FBQ04sb0JBQW9CLFFBQVE7QUFDNUIsTUFBTTtBQUNOLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0EsUUFBUTtBQUNSLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDLE1BQU07QUFDTixxQkFBcUIsUUFBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwwQ0FBMEMsRUFBRSxzQkFBc0IsRUFBRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxzQkFBc0IsRUFBRSxzQkFBc0IsRUFBRTs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9ub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9OUXVhZHMuanM/M2RjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIyIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5jb25zdCBURVJNUyA9IFsnc3ViamVjdCcsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgJ2dyYXBoJ107XG5jb25zdCBSREYgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc7XG5jb25zdCBSREZfTEFOR1NUUklORyA9IFJERiArICdsYW5nU3RyaW5nJztcbmNvbnN0IFhTRF9TVFJJTkcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjc3RyaW5nJztcblxuY29uc3QgVFlQRV9OQU1FRF9OT0RFID0gJ05hbWVkTm9kZSc7XG5jb25zdCBUWVBFX0JMQU5LX05PREUgPSAnQmxhbmtOb2RlJztcbmNvbnN0IFRZUEVfTElURVJBTCA9ICdMaXRlcmFsJztcbmNvbnN0IFRZUEVfREVGQVVMVF9HUkFQSCA9ICdEZWZhdWx0R3JhcGgnO1xuXG4vLyBidWlsZCByZWdleGVzXG5jb25zdCBSRUdFWCA9IHt9O1xuKCgpID0+IHtcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL24tcXVhZHMvI3NlYy1ncmFtbWFyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi90dXJ0bGUvI2dyYW1tYXItcHJvZHVjdGlvbi1CTEFOS19OT0RFX0xBQkVMXG4gIGNvbnN0IFBOX0NIQVJTX0JBU0UgPVxuICAgICdBLVonICsgJ2EteicgK1xuICAgICdcXHUwMEMwLVxcdTAwRDYnICtcbiAgICAnXFx1MDBEOC1cXHUwMEY2JyArXG4gICAgJ1xcdTAwRjgtXFx1MDJGRicgK1xuICAgICdcXHUwMzcwLVxcdTAzN0QnICtcbiAgICAnXFx1MDM3Ri1cXHUxRkZGJyArXG4gICAgJ1xcdTIwMEMtXFx1MjAwRCcgK1xuICAgICdcXHUyMDcwLVxcdTIxOEYnICtcbiAgICAnXFx1MkMwMC1cXHUyRkVGJyArXG4gICAgJ1xcdTMwMDEtXFx1RDdGRicgK1xuICAgICdcXHVGOTAwLVxcdUZEQ0YnICtcbiAgICAnXFx1RkRGMC1cXHVGRkZEJztcbiAgICAvLyBUT0RPOlxuICAgIC8vJ1xcdTEwMDAwLVxcdUVGRkZGJztcbiAgY29uc3QgUE5fQ0hBUlNfVSA9XG4gICAgUE5fQ0hBUlNfQkFTRSArXG4gICAgJ18nO1xuICBjb25zdCBQTl9DSEFSUyA9XG4gICAgUE5fQ0hBUlNfVSArXG4gICAgJzAtOScgK1xuICAgICctJyArXG4gICAgJ1xcdTAwQjcnICtcbiAgICAnXFx1MDMwMC1cXHUwMzZGJyArXG4gICAgJ1xcdTIwM0YtXFx1MjA0MCc7XG4gIGNvbnN0IEJMQU5LX05PREVfTEFCRUwgPVxuICAgICdfOignICtcbiAgICAgICcoPzpbJyArIFBOX0NIQVJTX1UgKyAnMC05XSknICtcbiAgICAgICcoPzooPzpbJyArIFBOX0NIQVJTICsgJy5dKSooPzpbJyArIFBOX0NIQVJTICsgJ10pKT8nICtcbiAgICAnKSc7XG4gIC8vIE9sZGVyIHNpbXBsZSByZWdleDogY29uc3QgSVJJID0gJyg/OjwoW146XSs6W14+XSopPiknO1xuICBjb25zdCBVQ0hBUjQgPSAnXFxcXFxcXFx1WzAtOUEtRmEtZl17NH0nO1xuICBjb25zdCBVQ0hBUjggPSAnXFxcXFxcXFxVWzAtOUEtRmEtZl17OH0nO1xuICBjb25zdCBJUkkgPSAnKD86PCgoPzonICtcbiAgICAnW15cXHUwMDAwLVxcdTAwMjA8Plwie318XmBcXFxcXFxcXF0nICsgJ3wnICtcbiAgICBVQ0hBUjQgKyAnfCcgK1xuICAgIFVDSEFSOCArXG4gICAgJykqKT4pJztcbiAgY29uc3QgYm5vZGUgPSBCTEFOS19OT0RFX0xBQkVMO1xuICBjb25zdCBwbGFpbiA9ICdcIihbXlwiXFxcXFxcXFxdKig/OlxcXFxcXFxcLlteXCJcXFxcXFxcXF0qKSopXCInO1xuICBjb25zdCBkYXRhdHlwZSA9ICcoPzpcXFxcXlxcXFxeJyArIElSSSArICcpJztcbiAgY29uc3QgbGFuZ3VhZ2UgPSAnKD86QChbYS16QS1aXSsoPzotW2EtekEtWjAtOV0rKSopKSc7XG4gIGNvbnN0IGxpdGVyYWwgPSAnKD86JyArIHBsYWluICsgJyg/OicgKyBkYXRhdHlwZSArICd8JyArIGxhbmd1YWdlICsgJyk/KSc7XG4gIGNvbnN0IHdzID0gJ1sgXFxcXHRdKyc7XG4gIGNvbnN0IHdzbyA9ICdbIFxcXFx0XSonO1xuXG4gIC8vIGRlZmluZSBxdWFkIHBhcnQgcmVnZXhlc1xuICBjb25zdCBzdWJqZWN0ID0gJyg/OicgKyBJUkkgKyAnfCcgKyBibm9kZSArICcpJyArIHdzO1xuICBjb25zdCBwcm9wZXJ0eSA9IElSSSArIHdzO1xuICBjb25zdCBvYmplY3QgPSAnKD86JyArIElSSSArICd8JyArIGJub2RlICsgJ3wnICsgbGl0ZXJhbCArICcpJyArIHdzbztcbiAgY29uc3QgZ3JhcGhOYW1lID0gJyg/OlxcXFwufCg/Oig/OicgKyBJUkkgKyAnfCcgKyBibm9kZSArICcpJyArIHdzbyArICdcXFxcLikpJztcblxuICAvLyBlbmQgb2YgbGluZSBhbmQgZW1wdHkgcmVnZXhlc1xuICBSRUdFWC5lb2xuID0gLyg/Olxcclxcbil8KD86XFxuKXwoPzpcXHIpL2c7XG4gIFJFR0VYLmVtcHR5ID0gbmV3IFJlZ0V4cCgnXicgKyB3c28gKyAnJCcpO1xuXG4gIC8vIGZ1bGwgcXVhZCByZWdleFxuICBSRUdFWC5xdWFkID0gbmV3IFJlZ0V4cChcbiAgICAnXicgKyB3c28gKyBzdWJqZWN0ICsgcHJvcGVydHkgKyBvYmplY3QgKyBncmFwaE5hbWUgKyB3c28gKyAnJCcpO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBOUXVhZHMge1xuICAvKipcbiAgICogUGFyc2VzIFJERiBpbiB0aGUgZm9ybSBvZiBOLVF1YWRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBUaGUgTi1RdWFkcyBpbnB1dCB0byBwYXJzZS5cbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSAtIEFuIFJERiBkYXRhc2V0IChhbiBhcnJheSBvZiBxdWFkcyBwZXJcbiAgICogICBodHRwczovL3JkZi5qcy5vcmcvKS5cbiAgICovXG4gIHN0YXRpYyBwYXJzZShpbnB1dCkge1xuICAgIC8vIGJ1aWxkIFJERiBkYXRhc2V0XG4gICAgY29uc3QgZGF0YXNldCA9IFtdO1xuXG4gICAgY29uc3QgZ3JhcGhzID0ge307XG5cbiAgICAvLyBzcGxpdCBOLVF1YWQgaW5wdXQgaW50byBsaW5lc1xuICAgIGNvbnN0IGxpbmVzID0gaW5wdXQuc3BsaXQoUkVHRVguZW9sbik7XG4gICAgbGV0IGxpbmVOdW1iZXIgPSAwO1xuICAgIGZvcihjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBsaW5lTnVtYmVyKys7XG5cbiAgICAgIC8vIHNraXAgZW1wdHkgbGluZXNcbiAgICAgIGlmKFJFR0VYLmVtcHR5LnRlc3QobGluZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHF1YWRcbiAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChSRUdFWC5xdWFkKTtcbiAgICAgIGlmKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTi1RdWFkcyBwYXJzZSBlcnJvciBvbiBsaW5lICcgKyBsaW5lTnVtYmVyICsgJy4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIFJERiBxdWFkXG4gICAgICBjb25zdCBxdWFkID0ge3N1YmplY3Q6IG51bGwsIHByZWRpY2F0ZTogbnVsbCwgb2JqZWN0OiBudWxsLCBncmFwaDogbnVsbH07XG5cbiAgICAgIC8vIGdldCBzdWJqZWN0XG4gICAgICBpZihtYXRjaFsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQuc3ViamVjdCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogVFlQRV9OQU1FRF9OT0RFLFxuICAgICAgICAgIHZhbHVlOiBfaXJpVW5lc2NhcGUobWF0Y2hbMV0pXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWFkLnN1YmplY3QgPSB7XG4gICAgICAgICAgdGVybVR5cGU6IFRZUEVfQkxBTktfTk9ERSxcbiAgICAgICAgICB2YWx1ZTogbWF0Y2hbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IHByZWRpY2F0ZVxuICAgICAgcXVhZC5wcmVkaWNhdGUgPSB7XG4gICAgICAgIHRlcm1UeXBlOiBUWVBFX05BTUVEX05PREUsXG4gICAgICAgIHZhbHVlOiBfaXJpVW5lc2NhcGUobWF0Y2hbM10pXG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgb2JqZWN0XG4gICAgICBpZihtYXRjaFs0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQub2JqZWN0ID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiBUWVBFX05BTUVEX05PREUsXG4gICAgICAgICAgdmFsdWU6IF9pcmlVbmVzY2FwZShtYXRjaFs0XSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZihtYXRjaFs1XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1YWQub2JqZWN0ID0ge1xuICAgICAgICAgIHRlcm1UeXBlOiBUWVBFX0JMQU5LX05PREUsXG4gICAgICAgICAgdmFsdWU6IG1hdGNoWzVdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWFkLm9iamVjdCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogVFlQRV9MSVRFUkFMLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGF0YXR5cGU6IHtcbiAgICAgICAgICAgIHRlcm1UeXBlOiBUWVBFX05BTUVEX05PREVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmKG1hdGNoWzddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBxdWFkLm9iamVjdC5kYXRhdHlwZS52YWx1ZSA9IF9pcmlVbmVzY2FwZShtYXRjaFs3XSk7XG4gICAgICAgIH0gZWxzZSBpZihtYXRjaFs4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcXVhZC5vYmplY3QuZGF0YXR5cGUudmFsdWUgPSBSREZfTEFOR1NUUklORztcbiAgICAgICAgICBxdWFkLm9iamVjdC5sYW5ndWFnZSA9IG1hdGNoWzhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1YWQub2JqZWN0LmRhdGF0eXBlLnZhbHVlID0gWFNEX1NUUklORztcbiAgICAgICAgfVxuICAgICAgICBxdWFkLm9iamVjdC52YWx1ZSA9IF9zdHJpbmdMaXRlcmFsVW5lc2NhcGUobWF0Y2hbNl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZ3JhcGhcbiAgICAgIGlmKG1hdGNoWzldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogVFlQRV9OQU1FRF9OT0RFLFxuICAgICAgICAgIHZhbHVlOiBfaXJpVW5lc2NhcGUobWF0Y2hbOV0pXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYobWF0Y2hbMTBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcXVhZC5ncmFwaCA9IHtcbiAgICAgICAgICB0ZXJtVHlwZTogVFlQRV9CTEFOS19OT0RFLFxuICAgICAgICAgIHZhbHVlOiBtYXRjaFsxMF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1YWQuZ3JhcGggPSB7XG4gICAgICAgICAgdGVybVR5cGU6IFRZUEVfREVGQVVMVF9HUkFQSCxcbiAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBhZGQgcXVhZCBpZiBpdCBpcyB1bmlxdWUgaW4gaXRzIGdyYXBoXG4gICAgICBpZighKHF1YWQuZ3JhcGgudmFsdWUgaW4gZ3JhcGhzKSkge1xuICAgICAgICBncmFwaHNbcXVhZC5ncmFwaC52YWx1ZV0gPSBbcXVhZF07XG4gICAgICAgIGRhdGFzZXQucHVzaChxdWFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB1bmlxdWUgPSB0cnVlO1xuICAgICAgICBjb25zdCBxdWFkcyA9IGdyYXBoc1txdWFkLmdyYXBoLnZhbHVlXTtcbiAgICAgICAgZm9yKGNvbnN0IHEgb2YgcXVhZHMpIHtcbiAgICAgICAgICBpZihfY29tcGFyZVRyaXBsZXMocSwgcXVhZCkpIHtcbiAgICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHVuaXF1ZSkge1xuICAgICAgICAgIHF1YWRzLnB1c2gocXVhZCk7XG4gICAgICAgICAgZGF0YXNldC5wdXNoKHF1YWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gUkRGIGRhdGFzZXQgdG8gTi1RdWFkcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gZGF0YXNldCAtIFRoZSBBcnJheSBvZiBxdWFkcyBSREYgZGF0YXNldCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBOLVF1YWRzIHN0cmluZy5cbiAgICovXG4gIHN0YXRpYyBzZXJpYWxpemUoZGF0YXNldCkge1xuICAgIGNvbnN0IHF1YWRzID0gW107XG4gICAgZm9yKGNvbnN0IHF1YWQgb2YgZGF0YXNldCkge1xuICAgICAgcXVhZHMucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZChxdWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBxdWFkcy5zb3J0KCkuam9pbignJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgUkRGIHF1YWQgY29tcG9uZW50cyB0byBhbiBOLVF1YWQgc3RyaW5nIChhIHNpbmdsZSBxdWFkKS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHMgLSBOLVF1YWQgc3ViamVjdCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwIC0gTi1RdWFkIHByZWRpY2F0ZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvIC0gTi1RdWFkIG9iamVjdCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnIC0gTi1RdWFkIGdyYXBoIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgTi1RdWFkLlxuICAgKi9cbiAgc3RhdGljIHNlcmlhbGl6ZVF1YWRDb21wb25lbnRzKHMsIHAsIG8sIGcpIHtcbiAgICBsZXQgbnF1YWQgPSAnJztcblxuICAgIC8vIHN1YmplY3QgY2FuIG9ubHkgYmUgTmFtZWROb2RlIG9yIEJsYW5rTm9kZVxuICAgIGlmKHMudGVybVR5cGUgPT09IFRZUEVfTkFNRURfTk9ERSkge1xuICAgICAgbnF1YWQgKz0gYDwke19pcmlFc2NhcGUocy52YWx1ZSl9PmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5xdWFkICs9IGBfOiR7cy52YWx1ZX1gO1xuICAgIH1cblxuICAgIC8vIHByZWRpY2F0ZSBub3JtYWxseSBhIE5hbWVkTm9kZSwgY2FuIGJlIGEgQmxhbmtOb2RlIGluIGdlbmVyYWxpemVkIFJERlxuICAgIGlmKHAudGVybVR5cGUgPT09IFRZUEVfTkFNRURfTk9ERSkge1xuICAgICAgbnF1YWQgKz0gYCA8JHtfaXJpRXNjYXBlKHAudmFsdWUpfT4gYDtcbiAgICB9IGVsc2Uge1xuICAgICAgbnF1YWQgKz0gYCBfOiR7cC52YWx1ZX0gYDtcbiAgICB9XG5cbiAgICAvLyBvYmplY3QgaXMgTmFtZWROb2RlLCBCbGFua05vZGUsIG9yIExpdGVyYWxcbiAgICBpZihvLnRlcm1UeXBlID09PSBUWVBFX05BTUVEX05PREUpIHtcbiAgICAgIG5xdWFkICs9IGA8JHtfaXJpRXNjYXBlKG8udmFsdWUpfT5gO1xuICAgIH0gZWxzZSBpZihvLnRlcm1UeXBlID09PSBUWVBFX0JMQU5LX05PREUpIHtcbiAgICAgIG5xdWFkICs9IGBfOiR7by52YWx1ZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBucXVhZCArPSBgXCIke19zdHJpbmdMaXRlcmFsRXNjYXBlKG8udmFsdWUpfVwiYDtcbiAgICAgIGlmKG8uZGF0YXR5cGUudmFsdWUgPT09IFJERl9MQU5HU1RSSU5HKSB7XG4gICAgICAgIGlmKG8ubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBucXVhZCArPSBgQCR7by5sYW5ndWFnZX1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoby5kYXRhdHlwZS52YWx1ZSAhPT0gWFNEX1NUUklORykge1xuICAgICAgICBucXVhZCArPSBgXl48JHtfaXJpRXNjYXBlKG8uZGF0YXR5cGUudmFsdWUpfT5gO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdyYXBoIGNhbiBvbmx5IGJlIE5hbWVkTm9kZSBvciBCbGFua05vZGUgKG9yIERlZmF1bHRHcmFwaCwgYnV0IHRoYXRcbiAgICAvLyBkb2VzIG5vdCBhZGQgdG8gYG5xdWFkYClcbiAgICBpZihnLnRlcm1UeXBlID09PSBUWVBFX05BTUVEX05PREUpIHtcbiAgICAgIG5xdWFkICs9IGAgPCR7X2lyaUVzY2FwZShnLnZhbHVlKX0+YDtcbiAgICB9IGVsc2UgaWYoZy50ZXJtVHlwZSA9PT0gVFlQRV9CTEFOS19OT0RFKSB7XG4gICAgICBucXVhZCArPSBgIF86JHtnLnZhbHVlfWA7XG4gICAgfVxuXG4gICAgbnF1YWQgKz0gJyAuXFxuJztcbiAgICByZXR1cm4gbnF1YWQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gUkRGIHF1YWQgdG8gYW4gTi1RdWFkIHN0cmluZyAoYSBzaW5nbGUgcXVhZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBxdWFkIC0gVGhlIFJERiBxdWFkIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIE4tUXVhZCBzdHJpbmcuXG4gICAqL1xuICBzdGF0aWMgc2VyaWFsaXplUXVhZChxdWFkKSB7XG4gICAgcmV0dXJuIE5RdWFkcy5zZXJpYWxpemVRdWFkQ29tcG9uZW50cyhcbiAgICAgIHF1YWQuc3ViamVjdCwgcXVhZC5wcmVkaWNhdGUsIHF1YWQub2JqZWN0LCBxdWFkLmdyYXBoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb21wYXJlcyB0d28gUkRGIHRyaXBsZXMgZm9yIGVxdWFsaXR5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0MSAtIFRoZSBmaXJzdCB0cmlwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdDIgLSBUaGUgc2Vjb25kIHRyaXBsZS5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSB0cmlwbGVzIGFyZSB0aGUgc2FtZSwgZmFsc2UgaWYgbm90LlxuICovXG5mdW5jdGlvbiBfY29tcGFyZVRyaXBsZXModDEsIHQyKSB7XG4gIC8vIGNvbXBhcmUgc3ViamVjdCBhbmQgb2JqZWN0IHR5cGVzIGZpcnN0IGFzIGl0IGlzIHRoZSBxdWlja2VzdCBjaGVja1xuICBpZighKHQxLnN1YmplY3QudGVybVR5cGUgPT09IHQyLnN1YmplY3QudGVybVR5cGUgJiZcbiAgICB0MS5vYmplY3QudGVybVR5cGUgPT09IHQyLm9iamVjdC50ZXJtVHlwZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gY29tcGFyZSB2YWx1ZXNcbiAgaWYoISh0MS5zdWJqZWN0LnZhbHVlID09PSB0Mi5zdWJqZWN0LnZhbHVlICYmXG4gICAgdDEucHJlZGljYXRlLnZhbHVlID09PSB0Mi5wcmVkaWNhdGUudmFsdWUgJiZcbiAgICB0MS5vYmplY3QudmFsdWUgPT09IHQyLm9iamVjdC52YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYodDEub2JqZWN0LnRlcm1UeXBlICE9PSBUWVBFX0xJVEVSQUwpIHtcbiAgICAvLyBubyBgZGF0YXR5cGVgIG9yIGBsYW5ndWFnZWAgdG8gY2hlY2tcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKFxuICAgICh0MS5vYmplY3QuZGF0YXR5cGUudGVybVR5cGUgPT09IHQyLm9iamVjdC5kYXRhdHlwZS50ZXJtVHlwZSkgJiZcbiAgICAodDEub2JqZWN0Lmxhbmd1YWdlID09PSB0Mi5vYmplY3QubGFuZ3VhZ2UpICYmXG4gICAgKHQxLm9iamVjdC5kYXRhdHlwZS52YWx1ZSA9PT0gdDIub2JqZWN0LmRhdGF0eXBlLnZhbHVlKVxuICApO1xufVxuXG5jb25zdCBfc3RyaW5nTGl0ZXJhbEVzY2FwZVJlZ2V4ID0gL1tcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXCJcXFxcXS9nO1xuY29uc3QgX3N0cmluZ0xpdGVyYWxFc2NhcGVNYXAgPSBbXTtcbmZvcihsZXQgbiA9IDA7IG4gPD0gMHg3ZjsgKytuKSB7XG4gIGlmKF9zdHJpbmdMaXRlcmFsRXNjYXBlUmVnZXgudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKG4pKSkge1xuICAgIC8vIGRlZmF1bHQgVUNIQVIgbWFwcGluZ1xuICAgIF9zdHJpbmdMaXRlcmFsRXNjYXBlTWFwW25dID1cbiAgICAgICdcXFxcdScgKyBuLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDQsICcwJyk7XG4gICAgLy8gcmVzZXQgcmVnZXhcbiAgICBfc3RyaW5nTGl0ZXJhbEVzY2FwZVJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gIH1cbn1cbi8vIHNwZWNpYWwgRUNIQVIgbWFwcGluZ3Ncbl9zdHJpbmdMaXRlcmFsRXNjYXBlTWFwWydcXGInLmNvZGVQb2ludEF0KDApXSA9ICdcXFxcYic7XG5fc3RyaW5nTGl0ZXJhbEVzY2FwZU1hcFsnXFx0Jy5jb2RlUG9pbnRBdCgwKV0gPSAnXFxcXHQnO1xuX3N0cmluZ0xpdGVyYWxFc2NhcGVNYXBbJ1xcbicuY29kZVBvaW50QXQoMCldID0gJ1xcXFxuJztcbl9zdHJpbmdMaXRlcmFsRXNjYXBlTWFwWydcXGYnLmNvZGVQb2ludEF0KDApXSA9ICdcXFxcZic7XG5fc3RyaW5nTGl0ZXJhbEVzY2FwZU1hcFsnXFxyJy5jb2RlUG9pbnRBdCgwKV0gPSAnXFxcXHInO1xuX3N0cmluZ0xpdGVyYWxFc2NhcGVNYXBbJ1wiJyAuY29kZVBvaW50QXQoMCldID0gJ1xcXFxcIic7XG5fc3RyaW5nTGl0ZXJhbEVzY2FwZU1hcFsnXFxcXCcuY29kZVBvaW50QXQoMCldID0gJ1xcXFxcXFxcJztcblxuLyoqXG4gKiBFc2NhcGUgc3RyaW5nIHRvIE4tUXVhZHMgbGl0ZXJhbC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyAtIFN0cmluZyB0byBlc2NhcGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBFc2NhcGVkIE4tUXVhZHMgbGl0ZXJhbC5cbiAqL1xuZnVuY3Rpb24gX3N0cmluZ0xpdGVyYWxFc2NhcGUocykge1xuICBpZighX3N0cmluZ0xpdGVyYWxFc2NhcGVSZWdleC50ZXN0KHMpKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgcmV0dXJuIHMucmVwbGFjZShfc3RyaW5nTGl0ZXJhbEVzY2FwZVJlZ2V4LCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBfc3RyaW5nTGl0ZXJhbEVzY2FwZU1hcFttYXRjaC5jb2RlUG9pbnRBdCgwKV07XG4gIH0pO1xufVxuXG5jb25zdCBfc3RyaW5nTGl0ZXJhbFVuZXNjYXBlUmVnZXggPVxuICAvKD86XFxcXChbYnRuZnJcIidcXFxcXSkpfCg/OlxcXFx1KFswLTlBLUZhLWZdezR9KSl8KD86XFxcXFUoWzAtOUEtRmEtZl17OH0pKS9nO1xuXG4vKipcbiAqIFVuZXNjYXBlIE4tUXVhZHMgbGl0ZXJhbCB0byBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgLSBTdHJpbmcgdG8gdW5lc2NhcGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBVbmVzY2FwZWQgTi1RdWFkcyBsaXRlcmFsLlxuICovXG5mdW5jdGlvbiBfc3RyaW5nTGl0ZXJhbFVuZXNjYXBlKHMpIHtcbiAgaWYoIV9zdHJpbmdMaXRlcmFsVW5lc2NhcGVSZWdleC50ZXN0KHMpKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgcmV0dXJuIHMucmVwbGFjZShfc3RyaW5nTGl0ZXJhbFVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBjb2RlLCB1LCBVKSB7XG4gICAgaWYoY29kZSkge1xuICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAnYic6IHJldHVybiAnXFxiJztcbiAgICAgICAgY2FzZSAndCc6IHJldHVybiAnXFx0JztcbiAgICAgICAgY2FzZSAnbic6IHJldHVybiAnXFxuJztcbiAgICAgICAgY2FzZSAnZic6IHJldHVybiAnXFxmJztcbiAgICAgICAgY2FzZSAncic6IHJldHVybiAnXFxyJztcbiAgICAgICAgY2FzZSAnXCInOiByZXR1cm4gJ1wiJztcbiAgICAgICAgY2FzZSAnXFwnJzogcmV0dXJuICdcXCcnO1xuICAgICAgICBjYXNlICdcXFxcJzogcmV0dXJuICdcXFxcJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYodSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodSwgMTYpKTtcbiAgICB9XG4gICAgaWYoVSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KFUsIDE2KSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgX2lyaUVzY2FwZVJlZ2V4ID0gL1tcXHUwMDAwLVxcdTAwMjA8Plwie318XmBcXFxcXS9nO1xuY29uc3QgX2lyaUVzY2FwZVJlZ2V4TWFwID0gW107XG5mb3IobGV0IG4gPSAwOyBuIDw9IDB4N2Y7ICsrbikge1xuICBpZihfaXJpRXNjYXBlUmVnZXgudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKG4pKSkge1xuICAgIC8vIFVDSEFSIG1hcHBpbmdcbiAgICBfaXJpRXNjYXBlUmVnZXhNYXBbbl0gPVxuICAgICAgJ1xcXFx1JyArIG4udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoNCwgJzAnKTtcbiAgICAvLyByZXNldCByZWdleFxuICAgIF9pcmlFc2NhcGVSZWdleC5sYXN0SW5kZXggPSAwO1xuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIElSSSB0byBOLVF1YWRzIElSSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcyAtIElSSSB0byBlc2NhcGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBFc2NhcGVkIE4tUXVhZHMgSVJJLlxuICovXG5mdW5jdGlvbiBfaXJpRXNjYXBlKHMpIHtcbiAgaWYoIV9pcmlFc2NhcGVSZWdleC50ZXN0KHMpKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgcmV0dXJuIHMucmVwbGFjZShfaXJpRXNjYXBlUmVnZXgsIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIF9pcmlFc2NhcGVSZWdleE1hcFttYXRjaC5jb2RlUG9pbnRBdCgwKV07XG4gIH0pO1xufVxuXG5jb25zdCBfaXJpVW5lc2NhcGVSZWdleCA9XG4gIC8oPzpcXFxcdShbMC05QS1GYS1mXXs0fSkpfCg/OlxcXFxVKFswLTlBLUZhLWZdezh9KSkvZztcblxuLyoqXG4gKiBVbmVzY2FwZSBOLVF1YWRzIElSSSB0byBJUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHMgLSBJUkkgdG8gdW5lc2NhcGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBVbmVzY2FwZWQgTi1RdWFkcyBJUkkuXG4gKi9cbmZ1bmN0aW9uIF9pcmlVbmVzY2FwZShzKSB7XG4gIGlmKCFfaXJpVW5lc2NhcGVSZWdleC50ZXN0KHMpKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgcmV0dXJuIHMucmVwbGFjZShfaXJpVW5lc2NhcGVSZWdleCwgZnVuY3Rpb24obWF0Y2gsIHUsIFUpIHtcbiAgICBpZih1KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh1LCAxNikpO1xuICAgIH1cbiAgICBpZihVKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoVSwgMTYpKTtcbiAgICB9XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nmodule.exports = class Permuter {\n  /**\n   * A Permuter iterates over all possible permutations of the given array\n   * of elements.\n   *\n   * @param {Array} list - The array of elements to iterate over.\n   */\n  constructor(list) {\n    // original array\n    this.current = list.sort();\n    // indicates whether there are more permutations\n    this.done = false;\n    // directional info for permutation algorithm\n    this.dir = new Map();\n    for(let i = 0; i < list.length; ++i) {\n      this.dir.set(list[i], true);\n    }\n  }\n\n  /**\n   * Returns true if there is another permutation.\n   *\n   * @returns {boolean} - True if there is another permutation, false if not.\n   */\n  hasNext() {\n    return !this.done;\n  }\n\n  /**\n   * Gets the next permutation. Call hasNext() to ensure there is another one\n   * first.\n   *\n   * @returns {any} - The next permutation.\n   */\n  next() {\n    // copy current permutation to return it\n    const {current, dir} = this;\n    const rval = current.slice();\n\n    /* Calculate the next permutation using the Steinhaus-Johnson-Trotter\n     permutation algorithm. */\n\n    // get largest mobile element k\n    // (mobile: element is greater than the one it is looking at)\n    let k = null;\n    let pos = 0;\n    const length = current.length;\n    for(let i = 0; i < length; ++i) {\n      const element = current[i];\n      const left = dir.get(element);\n      if((k === null || element > k) &&\n        ((left && i > 0 && element > current[i - 1]) ||\n        (!left && i < (length - 1) && element > current[i + 1]))) {\n        k = element;\n        pos = i;\n      }\n    }\n\n    // no more permutations\n    if(k === null) {\n      this.done = true;\n    } else {\n      // swap k and the element it is looking at\n      const swap = dir.get(k) ? pos - 1 : pos + 1;\n      current[pos] = current[swap];\n      current[swap] = k;\n\n      // reverse the direction of all elements larger than k\n      for(const element of current) {\n        if(element > k) {\n          dir.set(element, !dir.get(element));\n        }\n      }\n    }\n\n    return rval;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvUGVybXV0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9ub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9QZXJtdXRlci5qcz81N2UyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjIgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBlcm11dGVyIHtcbiAgLyoqXG4gICAqIEEgUGVybXV0ZXIgaXRlcmF0ZXMgb3ZlciBhbGwgcG9zc2libGUgcGVybXV0YXRpb25zIG9mIHRoZSBnaXZlbiBhcnJheVxuICAgKiBvZiBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbGlzdCAtIFRoZSBhcnJheSBvZiBlbGVtZW50cyB0byBpdGVyYXRlIG92ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsaXN0KSB7XG4gICAgLy8gb3JpZ2luYWwgYXJyYXlcbiAgICB0aGlzLmN1cnJlbnQgPSBsaXN0LnNvcnQoKTtcbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZSBwZXJtdXRhdGlvbnNcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAvLyBkaXJlY3Rpb25hbCBpbmZvIGZvciBwZXJtdXRhdGlvbiBhbGdvcml0aG1cbiAgICB0aGlzLmRpciA9IG5ldyBNYXAoKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy5kaXIuc2V0KGxpc3RbaV0sIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW5vdGhlciBwZXJtdXRhdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGVyZSBpcyBhbm90aGVyIHBlcm11dGF0aW9uLCBmYWxzZSBpZiBub3QuXG4gICAqL1xuICBoYXNOZXh0KCkge1xuICAgIHJldHVybiAhdGhpcy5kb25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgcGVybXV0YXRpb24uIENhbGwgaGFzTmV4dCgpIHRvIGVuc3VyZSB0aGVyZSBpcyBhbm90aGVyIG9uZVxuICAgKiBmaXJzdC5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gLSBUaGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICovXG4gIG5leHQoKSB7XG4gICAgLy8gY29weSBjdXJyZW50IHBlcm11dGF0aW9uIHRvIHJldHVybiBpdFxuICAgIGNvbnN0IHtjdXJyZW50LCBkaXJ9ID0gdGhpcztcbiAgICBjb25zdCBydmFsID0gY3VycmVudC5zbGljZSgpO1xuXG4gICAgLyogQ2FsY3VsYXRlIHRoZSBuZXh0IHBlcm11dGF0aW9uIHVzaW5nIHRoZSBTdGVpbmhhdXMtSm9obnNvbi1Ucm90dGVyXG4gICAgIHBlcm11dGF0aW9uIGFsZ29yaXRobS4gKi9cblxuICAgIC8vIGdldCBsYXJnZXN0IG1vYmlsZSBlbGVtZW50IGtcbiAgICAvLyAobW9iaWxlOiBlbGVtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgb25lIGl0IGlzIGxvb2tpbmcgYXQpXG4gICAgbGV0IGsgPSBudWxsO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IGN1cnJlbnQubGVuZ3RoO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGN1cnJlbnRbaV07XG4gICAgICBjb25zdCBsZWZ0ID0gZGlyLmdldChlbGVtZW50KTtcbiAgICAgIGlmKChrID09PSBudWxsIHx8IGVsZW1lbnQgPiBrKSAmJlxuICAgICAgICAoKGxlZnQgJiYgaSA+IDAgJiYgZWxlbWVudCA+IGN1cnJlbnRbaSAtIDFdKSB8fFxuICAgICAgICAoIWxlZnQgJiYgaSA8IChsZW5ndGggLSAxKSAmJiBlbGVtZW50ID4gY3VycmVudFtpICsgMV0pKSkge1xuICAgICAgICBrID0gZWxlbWVudDtcbiAgICAgICAgcG9zID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHBlcm11dGF0aW9uc1xuICAgIGlmKGsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN3YXAgayBhbmQgdGhlIGVsZW1lbnQgaXQgaXMgbG9va2luZyBhdFxuICAgICAgY29uc3Qgc3dhcCA9IGRpci5nZXQoaykgPyBwb3MgLSAxIDogcG9zICsgMTtcbiAgICAgIGN1cnJlbnRbcG9zXSA9IGN1cnJlbnRbc3dhcF07XG4gICAgICBjdXJyZW50W3N3YXBdID0gaztcblxuICAgICAgLy8gcmV2ZXJzZSB0aGUgZGlyZWN0aW9uIG9mIGFsbCBlbGVtZW50cyBsYXJnZXIgdGhhbiBrXG4gICAgICBmb3IoY29uc3QgZWxlbWVudCBvZiBjdXJyZW50KSB7XG4gICAgICAgIGlmKGVsZW1lbnQgPiBrKSB7XG4gICAgICAgICAgZGlyLnNldChlbGVtZW50LCAhZGlyLmdldChlbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnZhbDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest.js\");\nconst Permuter = __webpack_require__(/*! ./Permuter */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js\");\nconst {setImmediate} = __webpack_require__(/*! ./platform */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/platform.js\");\n\nmodule.exports = class RDFC10 {\n  constructor({\n    createMessageDigest = null,\n    messageDigestAlgorithm = 'sha256',\n    canonicalIdMap = new Map(),\n    maxWorkFactor = 1,\n    maxDeepIterations = -1,\n    signal = null\n  } = {}) {\n    this.name = 'RDFC-1.0';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('c14n', canonicalIdMap);\n    this.createMessageDigest = createMessageDigest ||\n      (() => new MessageDigest(messageDigestAlgorithm));\n    this.maxWorkFactor = maxWorkFactor;\n    this.maxDeepIterations = maxDeepIterations;\n    this.remainingDeepIterations = 0;\n    this.signal = signal;\n    this.quads = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  async main(dataset) {\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the RDFC-1.0 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    let i = 0;\n    for(const id of nonNormalized) {\n      // Note: batch hashing first degree quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // steps 5.3.1 and 5.3.2:\n      await this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    if(this.maxDeepIterations < 0) {\n      // calculate maxDeepIterations if not explicit\n      if(this.maxWorkFactor === 0) {\n        this.maxDeepIterations = 0;\n      } else if(this.maxWorkFactor === Infinity) {\n        this.maxDeepIterations = Infinity;\n      } else {\n        const nonUniqueCount =\n          nonUnique.reduce((count, v) => count + v.length, 0);\n        this.maxDeepIterations = nonUniqueCount ** this.maxWorkFactor;\n      }\n    }\n    // handle any large inputs as Infinity\n    if(this.maxDeepIterations > Number.MAX_SAFE_INTEGER) {\n      this.maxDeepIterations = Infinity;\n    }\n    this.remainingDeepIterations = this.maxDeepIterations;\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = await this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize away the copy here.\n      const nQuad = NQuads.serializeQuadComponents(\n        this._componentWithCanonicalId(quad.subject),\n        quad.predicate,\n        this._componentWithCanonicalId(quad.object),\n        this._componentWithCanonicalId(quad.graph)\n      );\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(nQuad);\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  async hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      nquads.push(NQuads.serializeQuadComponents(\n        this.modifyFirstDegreeComponent(id, quad.subject, 'subject'),\n        quad.predicate,\n        this.modifyFirstDegreeComponent(id, quad.object, 'object'),\n        this.modifyFirstDegreeComponent(id, quad.graph, 'graph')\n      ));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = this.createMessageDigest();\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = await md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  async hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = this.createMessageDigest();\n    md.update(position);\n\n    // 2) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 3) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = '_:' + this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = '_:' + issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  async hashNDegreeQuads(id, issuer) {\n    if(this.remainingDeepIterations === 0) {\n      throw new Error(\n        `Maximum deep iterations exceeded (${this.maxDeepIterations}).`);\n    }\n    this.remainingDeepIterations--;\n\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = this.createMessageDigest();\n    const hashToRelated = await this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      let i = 0;\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n        // Note: batch permutations 3 at a time\n        if(++i % 3 === 0) {\n          if(this.signal && this.signal.aborted) {\n            throw new Error(`Abort signal received: \"${this.signal.reason}\".`);\n          }\n          await this._yield();\n        }\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += '_:' + this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += '_:' + issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = await this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += '_:' + issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: await md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the RDFC-1.0 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? 'a' : 'z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // Note: batch hashing related blank node quads 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.1) For each component in quad, if component is the subject, object,\n      // or graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      await Promise.all([\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.subject, position: 's',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.object, position: 'o',\n          id, issuer, hashToRelated\n        }),\n        this._addRelatedBlankNodeHash({\n          quad, component: quad.graph, position: 'g',\n          id, issuer, hashToRelated\n        })\n      ]);\n    }\n\n    return hashToRelated;\n  }\n\n  async _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = await this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  async _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = await this.hashRelatedBlankNode(\n      related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  // canonical ids for 7.1\n  _componentWithCanonicalId(component) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      // create new BlankNode\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n\n  async _yield() {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvUkRGQzEwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNhOztBQUViLHlCQUF5QixtQkFBTyxDQUFDLG9IQUFvQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw4R0FBaUI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsb0dBQVk7QUFDckMsZUFBZSxtQkFBTyxDQUFDLGdHQUFVO0FBQ2pDLE9BQU8sY0FBYyxFQUFFLG1CQUFPLENBQUMsb0dBQVk7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFLGtDQUFrQyw2QkFBNkI7QUFDL0Qsa0NBQWtDLDRCQUE0QjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixZQUFZOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLHFEQUFxRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9qc29ubGQtc2lnbmF0dXJlcy9ub2RlX21vZHVsZXMvcmRmLWNhbm9uaXplL2xpYi9SREZDMTAuanM/MjU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgSWRlbnRpZmllcklzc3VlciA9IHJlcXVpcmUoJy4vSWRlbnRpZmllcklzc3VlcicpO1xuY29uc3QgTWVzc2FnZURpZ2VzdCA9IHJlcXVpcmUoJy4vTWVzc2FnZURpZ2VzdCcpO1xuY29uc3QgUGVybXV0ZXIgPSByZXF1aXJlKCcuL1Blcm11dGVyJyk7XG5jb25zdCBOUXVhZHMgPSByZXF1aXJlKCcuL05RdWFkcycpO1xuY29uc3Qge3NldEltbWVkaWF0ZX0gPSByZXF1aXJlKCcuL3BsYXRmb3JtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUkRGQzEwIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNyZWF0ZU1lc3NhZ2VEaWdlc3QgPSBudWxsLFxuICAgIG1lc3NhZ2VEaWdlc3RBbGdvcml0aG0gPSAnc2hhMjU2JyxcbiAgICBjYW5vbmljYWxJZE1hcCA9IG5ldyBNYXAoKSxcbiAgICBtYXhXb3JrRmFjdG9yID0gMSxcbiAgICBtYXhEZWVwSXRlcmF0aW9ucyA9IC0xLFxuICAgIHNpZ25hbCA9IG51bGxcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gJ1JERkMtMS4wJztcbiAgICB0aGlzLmJsYW5rTm9kZUluZm8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYW5vbmljYWxJc3N1ZXIgPSBuZXcgSWRlbnRpZmllcklzc3VlcignYzE0bicsIGNhbm9uaWNhbElkTWFwKTtcbiAgICB0aGlzLmNyZWF0ZU1lc3NhZ2VEaWdlc3QgPSBjcmVhdGVNZXNzYWdlRGlnZXN0IHx8XG4gICAgICAoKCkgPT4gbmV3IE1lc3NhZ2VEaWdlc3QobWVzc2FnZURpZ2VzdEFsZ29yaXRobSkpO1xuICAgIHRoaXMubWF4V29ya0ZhY3RvciA9IG1heFdvcmtGYWN0b3I7XG4gICAgdGhpcy5tYXhEZWVwSXRlcmF0aW9ucyA9IG1heERlZXBJdGVyYXRpb25zO1xuICAgIHRoaXMucmVtYWluaW5nRGVlcEl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsO1xuICAgIHRoaXMucXVhZHMgPSBudWxsO1xuICB9XG5cbiAgLy8gNC40KSBOb3JtYWxpemF0aW9uIEFsZ29yaXRobVxuICBhc3luYyBtYWluKGRhdGFzZXQpIHtcbiAgICB0aGlzLnF1YWRzID0gZGF0YXNldDtcblxuICAgIC8vIDEpIENyZWF0ZSB0aGUgbm9ybWFsaXphdGlvbiBzdGF0ZS5cbiAgICAvLyAyKSBGb3IgZXZlcnkgcXVhZCBpbiBpbnB1dCBkYXRhc2V0OlxuICAgIGZvcihjb25zdCBxdWFkIG9mIGRhdGFzZXQpIHtcbiAgICAgIC8vIDIuMSkgRm9yIGVhY2ggYmxhbmsgbm9kZSB0aGF0IG9jY3VycyBpbiB0aGUgcXVhZCwgYWRkIGEgcmVmZXJlbmNlXG4gICAgICAvLyB0byB0aGUgcXVhZCB1c2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGluIHRoZSBibGFuayBub2RlIHRvXG4gICAgICAvLyBxdWFkcyBtYXAsIGNyZWF0aW5nIGEgbmV3IGVudHJ5IGlmIG5lY2Vzc2FyeS5cbiAgICAgIHRoaXMuX2FkZEJsYW5rTm9kZVF1YWRJbmZvKHtxdWFkLCBjb21wb25lbnQ6IHF1YWQuc3ViamVjdH0pO1xuICAgICAgdGhpcy5fYWRkQmxhbmtOb2RlUXVhZEluZm8oe3F1YWQsIGNvbXBvbmVudDogcXVhZC5vYmplY3R9KTtcbiAgICAgIHRoaXMuX2FkZEJsYW5rTm9kZVF1YWRJbmZvKHtxdWFkLCBjb21wb25lbnQ6IHF1YWQuZ3JhcGh9KTtcbiAgICB9XG5cbiAgICAvLyAzKSBDcmVhdGUgYSBsaXN0IG9mIG5vbi1ub3JtYWxpemVkIGJsYW5rIG5vZGUgaWRlbnRpZmllcnNcbiAgICAvLyBub24tbm9ybWFsaXplZCBpZGVudGlmaWVycyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgdGhlIGtleXMgZnJvbSB0aGVcbiAgICAvLyBibGFuayBub2RlIHRvIHF1YWRzIG1hcC5cbiAgICAvLyBOb3RlOiBXZSB1c2UgYSBtYXAgaGVyZSBhbmQgaXQgd2FzIGdlbmVyYXRlZCBkdXJpbmcgc3RlcCAyLlxuXG4gICAgLy8gNCkgYHNpbXBsZWAgZmxhZyBpcyBza2lwcGVkIC0tIGxvb3AgaXMgb3B0aW1pemVkIGF3YXkuIFRoaXMgb3B0aW1pemF0aW9uXG4gICAgLy8gaXMgcGVybWl0dGVkIGJlY2F1c2UgdGhlcmUgd2FzIGEgdHlwbyBpbiB0aGUgaGFzaCBmaXJzdCBkZWdyZWUgcXVhZHNcbiAgICAvLyBhbGdvcml0aG0gaW4gdGhlIFJERkMtMS4wIHNwZWMgdGhhdCB3YXMgaW1wbGVtZW50ZWQgd2lkZWx5IG1ha2luZyBpdFxuICAgIC8vIHN1Y2ggdGhhdCBpdCBjb3VsZCBub3QgYmUgZml4ZWQ7IHRoZSByZXN1bHQgd2FzIHRoYXQgdGhlIGxvb3Agb25seVxuICAgIC8vIG5lZWRzIHRvIGJlIHJ1biBvbmNlIGFuZCB0aGUgZmlyc3QgZGVncmVlIHF1YWQgaGFzaGVzIHdpbGwgbmV2ZXIgY2hhbmdlLlxuICAgIC8vIDUuMS01LjIgYXJlIHNraXBwZWQ7IGZpcnN0IGRlZ3JlZSBxdWFkIGhhc2hlcyBhcmUgZ2VuZXJhdGVkIGp1c3Qgb25jZVxuICAgIC8vIGZvciBhbGwgbm9uLW5vcm1hbGl6ZWQgYmxhbmsgbm9kZXMuXG5cbiAgICAvLyA1LjMpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpZGVudGlmaWVyIGluIG5vbi1ub3JtYWxpemVkXG4gICAgLy8gaWRlbnRpZmllcnM6XG4gICAgY29uc3QgaGFzaFRvQmxhbmtOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBub25Ob3JtYWxpemVkID0gWy4uLnRoaXMuYmxhbmtOb2RlSW5mby5rZXlzKCldO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IoY29uc3QgaWQgb2Ygbm9uTm9ybWFsaXplZCkge1xuICAgICAgLy8gTm90ZTogYmF0Y2ggaGFzaGluZyBmaXJzdCBkZWdyZWUgcXVhZHMgMTAwIGF0IGEgdGltZVxuICAgICAgaWYoKytpICUgMTAwID09PSAwKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3lpZWxkKCk7XG4gICAgICB9XG4gICAgICAvLyBzdGVwcyA1LjMuMSBhbmQgNS4zLjI6XG4gICAgICBhd2FpdCB0aGlzLl9oYXNoQW5kVHJhY2tCbGFua05vZGUoe2lkLCBoYXNoVG9CbGFua05vZGVzfSk7XG4gICAgfVxuXG4gICAgLy8gNS40KSBGb3IgZWFjaCBoYXNoIHRvIGlkZW50aWZpZXIgbGlzdCBtYXBwaW5nIGluIGhhc2ggdG8gYmxhbmtcbiAgICAvLyBub2RlcyBtYXAsIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSBoYXNoOlxuICAgIGNvbnN0IGhhc2hlcyA9IFsuLi5oYXNoVG9CbGFua05vZGVzLmtleXMoKV0uc29ydCgpO1xuICAgIC8vIG9wdGltaXplIGF3YXkgc2Vjb25kIHNvcnQsIGdhdGhlciBub24tdW5pcXVlIGhhc2hlcyBpbiBvcmRlciBhcyB3ZSBnb1xuICAgIGNvbnN0IG5vblVuaXF1ZSA9IFtdO1xuICAgIGZvcihjb25zdCBoYXNoIG9mIGhhc2hlcykge1xuICAgICAgLy8gNS40LjEpIElmIHRoZSBsZW5ndGggb2YgaWRlbnRpZmllciBsaXN0IGlzIGdyZWF0ZXIgdGhhbiAxLFxuICAgICAgLy8gY29udGludWUgdG8gdGhlIG5leHQgbWFwcGluZy5cbiAgICAgIGNvbnN0IGlkTGlzdCA9IGhhc2hUb0JsYW5rTm9kZXMuZ2V0KGhhc2gpO1xuICAgICAgaWYoaWRMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbm9uVW5pcXVlLnB1c2goaWRMaXN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIDUuNC4yKSBVc2UgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nIGNhbm9uaWNhbFxuICAgICAgLy8gaXNzdWVyIGFuZCB0aGUgc2luZ2xlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpbiBpZGVudGlmaWVyXG4gICAgICAvLyBsaXN0LCBpZGVudGlmaWVyLCB0byBpc3N1ZSBhIGNhbm9uaWNhbCByZXBsYWNlbWVudCBpZGVudGlmaWVyXG4gICAgICAvLyBmb3IgaWRlbnRpZmllci5cbiAgICAgIGNvbnN0IGlkID0gaWRMaXN0WzBdO1xuICAgICAgdGhpcy5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoaWQpO1xuXG4gICAgICAvLyBOb3RlOiBUaGVzZSBzdGVwcyBhcmUgc2tpcHBlZCwgb3B0aW1pemVkIGF3YXkgc2luY2UgdGhlIGxvb3BcbiAgICAgIC8vIG9ubHkgbmVlZHMgdG8gYmUgcnVuIG9uY2UuXG4gICAgICAvLyA1LjQuMykgUmVtb3ZlIGlkZW50aWZpZXIgZnJvbSBub24tbm9ybWFsaXplZCBpZGVudGlmaWVycy5cbiAgICAgIC8vIDUuNC40KSBSZW1vdmUgaGFzaCBmcm9tIHRoZSBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcC5cbiAgICAgIC8vIDUuNC41KSBTZXQgc2ltcGxlIHRvIHRydWUuXG4gICAgfVxuXG4gICAgaWYodGhpcy5tYXhEZWVwSXRlcmF0aW9ucyA8IDApIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBtYXhEZWVwSXRlcmF0aW9ucyBpZiBub3QgZXhwbGljaXRcbiAgICAgIGlmKHRoaXMubWF4V29ya0ZhY3RvciA9PT0gMCkge1xuICAgICAgICB0aGlzLm1heERlZXBJdGVyYXRpb25zID0gMDtcbiAgICAgIH0gZWxzZSBpZih0aGlzLm1heFdvcmtGYWN0b3IgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHRoaXMubWF4RGVlcEl0ZXJhdGlvbnMgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vblVuaXF1ZUNvdW50ID1cbiAgICAgICAgICBub25VbmlxdWUucmVkdWNlKChjb3VudCwgdikgPT4gY291bnQgKyB2Lmxlbmd0aCwgMCk7XG4gICAgICAgIHRoaXMubWF4RGVlcEl0ZXJhdGlvbnMgPSBub25VbmlxdWVDb3VudCAqKiB0aGlzLm1heFdvcmtGYWN0b3I7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGhhbmRsZSBhbnkgbGFyZ2UgaW5wdXRzIGFzIEluZmluaXR5XG4gICAgaWYodGhpcy5tYXhEZWVwSXRlcmF0aW9ucyA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aGlzLm1heERlZXBJdGVyYXRpb25zID0gSW5maW5pdHk7XG4gICAgfVxuICAgIHRoaXMucmVtYWluaW5nRGVlcEl0ZXJhdGlvbnMgPSB0aGlzLm1heERlZXBJdGVyYXRpb25zO1xuXG4gICAgLy8gNikgRm9yIGVhY2ggaGFzaCB0byBpZGVudGlmaWVyIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcCxcbiAgICAvLyBsZXhpY29ncmFwaGljYWxseS1zb3J0ZWQgYnkgaGFzaDpcbiAgICAvLyBOb3RlOiBzb3J0IG9wdGltaXplZCBhd2F5LCB1c2UgYG5vblVuaXF1ZWAuXG4gICAgZm9yKGNvbnN0IGlkTGlzdCBvZiBub25VbmlxdWUpIHtcbiAgICAgIC8vIDYuMSkgQ3JlYXRlIGhhc2ggcGF0aCBsaXN0IHdoZXJlIGVhY2ggaXRlbSB3aWxsIGJlIGEgcmVzdWx0IG9mXG4gICAgICAvLyBydW5uaW5nIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobS5cbiAgICAgIGNvbnN0IGhhc2hQYXRoTGlzdCA9IFtdO1xuXG4gICAgICAvLyA2LjIpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciBpZGVudGlmaWVyIGluIGlkZW50aWZpZXIgbGlzdDpcbiAgICAgIGZvcihjb25zdCBpZCBvZiBpZExpc3QpIHtcbiAgICAgICAgLy8gNi4yLjEpIElmIGEgY2Fub25pY2FsIGlkZW50aWZpZXIgaGFzIGFscmVhZHkgYmVlbiBpc3N1ZWQgZm9yXG4gICAgICAgIC8vIGlkZW50aWZpZXIsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGlkZW50aWZpZXIuXG4gICAgICAgIGlmKHRoaXMuY2Fub25pY2FsSXNzdWVyLmhhc0lkKGlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNi4yLjIpIENyZWF0ZSB0ZW1wb3JhcnkgaXNzdWVyLCBhbiBpZGVudGlmaWVyIGlzc3VlclxuICAgICAgICAvLyBpbml0aWFsaXplZCB3aXRoIHRoZSBwcmVmaXggXzpiLlxuICAgICAgICBjb25zdCBpc3N1ZXIgPSBuZXcgSWRlbnRpZmllcklzc3VlcignYicpO1xuXG4gICAgICAgIC8vIDYuMi4zKSBVc2UgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nIHRlbXBvcmFyeVxuICAgICAgICAvLyBpc3N1ZXIgYW5kIGlkZW50aWZpZXIsIHRvIGlzc3VlIGEgbmV3IHRlbXBvcmFyeSBibGFuayBub2RlXG4gICAgICAgIC8vIGlkZW50aWZpZXIgZm9yIGlkZW50aWZpZXIuXG4gICAgICAgIGlzc3Vlci5nZXRJZChpZCk7XG5cbiAgICAgICAgLy8gNi4yLjQpIFJ1biB0aGUgSGFzaCBOLURlZ3JlZSBRdWFkcyBhbGdvcml0aG0sIHBhc3NpbmdcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGlzc3VlciwgYW5kIGFwcGVuZCB0aGUgcmVzdWx0IHRvIHRoZSBoYXNoIHBhdGggbGlzdC5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5oYXNoTkRlZ3JlZVF1YWRzKGlkLCBpc3N1ZXIpO1xuICAgICAgICBoYXNoUGF0aExpc3QucHVzaChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICAvLyA2LjMpIEZvciBlYWNoIHJlc3VsdCBpbiB0aGUgaGFzaCBwYXRoIGxpc3QsXG4gICAgICAvLyBsZXhpY29ncmFwaGljYWxseS1zb3J0ZWQgYnkgdGhlIGhhc2ggaW4gcmVzdWx0OlxuICAgICAgaGFzaFBhdGhMaXN0LnNvcnQoX3N0cmluZ0hhc2hDb21wYXJlKTtcbiAgICAgIGZvcihjb25zdCByZXN1bHQgb2YgaGFzaFBhdGhMaXN0KSB7XG4gICAgICAgIC8vIDYuMy4xKSBGb3IgZWFjaCBibGFuayBub2RlIGlkZW50aWZpZXIsIGV4aXN0aW5nIGlkZW50aWZpZXIsXG4gICAgICAgIC8vIHRoYXQgd2FzIGlzc3VlZCBhIHRlbXBvcmFyeSBpZGVudGlmaWVyIGJ5IGlkZW50aWZpZXIgaXNzdWVyXG4gICAgICAgIC8vIGluIHJlc3VsdCwgaXNzdWUgYSBjYW5vbmljYWwgaWRlbnRpZmllciwgaW4gdGhlIHNhbWUgb3JkZXIsXG4gICAgICAgIC8vIHVzaW5nIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBjYW5vbmljYWxcbiAgICAgICAgLy8gaXNzdWVyIGFuZCBleGlzdGluZyBpZGVudGlmaWVyLlxuICAgICAgICBjb25zdCBvbGRJZHMgPSByZXN1bHQuaXNzdWVyLmdldE9sZElkcygpO1xuICAgICAgICBmb3IoY29uc3QgaWQgb2Ygb2xkSWRzKSB7XG4gICAgICAgICAgdGhpcy5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogTm90ZTogQXQgdGhpcyBwb2ludCBhbGwgYmxhbmsgbm9kZXMgaW4gdGhlIHNldCBvZiBSREYgcXVhZHMgaGF2ZSBiZWVuXG4gICAgYXNzaWduZWQgY2Fub25pY2FsIGlkZW50aWZpZXJzLCB3aGljaCBoYXZlIGJlZW4gc3RvcmVkIGluIHRoZSBjYW5vbmljYWxcbiAgICBpc3N1ZXIuIEhlcmUgZWFjaCBxdWFkIGlzIHVwZGF0ZWQgYnkgYXNzaWduaW5nIGVhY2ggb2YgaXRzIGJsYW5rIG5vZGVzXG4gICAgaXRzIG5ldyBpZGVudGlmaWVyLiAqL1xuXG4gICAgLy8gNykgRm9yIGVhY2ggcXVhZCwgcXVhZCwgaW4gaW5wdXQgZGF0YXNldDpcbiAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgZm9yKGNvbnN0IHF1YWQgb2YgdGhpcy5xdWFkcykge1xuICAgICAgLy8gNy4xKSBDcmVhdGUgYSBjb3B5LCBxdWFkIGNvcHksIG9mIHF1YWQgYW5kIHJlcGxhY2UgYW55IGV4aXN0aW5nXG4gICAgICAvLyBibGFuayBub2RlIGlkZW50aWZpZXJzIHVzaW5nIHRoZSBjYW5vbmljYWwgaWRlbnRpZmllcnNcbiAgICAgIC8vIHByZXZpb3VzbHkgaXNzdWVkIGJ5IGNhbm9uaWNhbCBpc3N1ZXIuXG4gICAgICAvLyBOb3RlOiBXZSBvcHRpbWl6ZSBhd2F5IHRoZSBjb3B5IGhlcmUuXG4gICAgICBjb25zdCBuUXVhZCA9IE5RdWFkcy5zZXJpYWxpemVRdWFkQ29tcG9uZW50cyhcbiAgICAgICAgdGhpcy5fY29tcG9uZW50V2l0aENhbm9uaWNhbElkKHF1YWQuc3ViamVjdCksXG4gICAgICAgIHF1YWQucHJlZGljYXRlLFxuICAgICAgICB0aGlzLl9jb21wb25lbnRXaXRoQ2Fub25pY2FsSWQocXVhZC5vYmplY3QpLFxuICAgICAgICB0aGlzLl9jb21wb25lbnRXaXRoQ2Fub25pY2FsSWQocXVhZC5ncmFwaClcbiAgICAgICk7XG4gICAgICAvLyA3LjIpIEFkZCBxdWFkIGNvcHkgdG8gdGhlIG5vcm1hbGl6ZWQgZGF0YXNldC5cbiAgICAgIG5vcm1hbGl6ZWQucHVzaChuUXVhZCk7XG4gICAgfVxuXG4gICAgLy8gc29ydCBub3JtYWxpemVkIG91dHB1dFxuICAgIG5vcm1hbGl6ZWQuc29ydCgpO1xuXG4gICAgLy8gOCkgUmV0dXJuIHRoZSBub3JtYWxpemVkIGRhdGFzZXQuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQuam9pbignJyk7XG4gIH1cblxuICAvLyA0LjYpIEhhc2ggRmlyc3QgRGVncmVlIFF1YWRzXG4gIGFzeW5jIGhhc2hGaXJzdERlZ3JlZVF1YWRzKGlkKSB7XG4gICAgLy8gMSkgSW5pdGlhbGl6ZSBucXVhZHMgdG8gYW4gZW1wdHkgbGlzdC4gSXQgd2lsbCBiZSB1c2VkIHRvIHN0b3JlIHF1YWRzIGluXG4gICAgLy8gTi1RdWFkcyBmb3JtYXQuXG4gICAgY29uc3QgbnF1YWRzID0gW107XG5cbiAgICAvLyAyKSBHZXQgdGhlIGxpc3Qgb2YgcXVhZHMgYHF1YWRzYCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZmVyZW5jZSBibGFuayBub2RlXG4gICAgLy8gaWRlbnRpZmllciBpbiB0aGUgYmxhbmsgbm9kZSB0byBxdWFkcyBtYXAuXG4gICAgY29uc3QgaW5mbyA9IHRoaXMuYmxhbmtOb2RlSW5mby5nZXQoaWQpO1xuICAgIGNvbnN0IHF1YWRzID0gaW5mby5xdWFkcztcblxuICAgIC8vIDMpIEZvciBlYWNoIHF1YWQgYHF1YWRgIGluIGBxdWFkc2A6XG4gICAgZm9yKGNvbnN0IHF1YWQgb2YgcXVhZHMpIHtcbiAgICAgIC8vIDMuMSkgU2VyaWFsaXplIHRoZSBxdWFkIGluIE4tUXVhZHMgZm9ybWF0IHdpdGggdGhlIGZvbGxvd2luZyBzcGVjaWFsXG4gICAgICAvLyBydWxlOlxuXG4gICAgICAvLyAzLjEuMSkgSWYgYW55IGNvbXBvbmVudCBpbiBxdWFkIGlzIGFuIGJsYW5rIG5vZGUsIHRoZW4gc2VyaWFsaXplIGl0XG4gICAgICAvLyB1c2luZyBhIHNwZWNpYWwgaWRlbnRpZmllciBhcyBmb2xsb3dzOlxuICAgICAgLy8gMy4xLjIpIElmIHRoZSBibGFuayBub2RlJ3MgZXhpc3RpbmcgYmxhbmsgbm9kZSBpZGVudGlmaWVyIG1hdGNoZXNcbiAgICAgIC8vIHRoZSByZWZlcmVuY2UgYmxhbmsgbm9kZSBpZGVudGlmaWVyIHRoZW4gdXNlIHRoZSBibGFuayBub2RlXG4gICAgICAvLyBpZGVudGlmaWVyIF86YSwgb3RoZXJ3aXNlLCB1c2UgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBfOnouXG4gICAgICBucXVhZHMucHVzaChOUXVhZHMuc2VyaWFsaXplUXVhZENvbXBvbmVudHMoXG4gICAgICAgIHRoaXMubW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIHF1YWQuc3ViamVjdCwgJ3N1YmplY3QnKSxcbiAgICAgICAgcXVhZC5wcmVkaWNhdGUsXG4gICAgICAgIHRoaXMubW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIHF1YWQub2JqZWN0LCAnb2JqZWN0JyksXG4gICAgICAgIHRoaXMubW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIHF1YWQuZ3JhcGgsICdncmFwaCcpXG4gICAgICApKTtcbiAgICB9XG5cbiAgICAvLyA0KSBTb3J0IG5xdWFkcyBpbiBsZXhpY29ncmFwaGljYWwgb3JkZXIuXG4gICAgbnF1YWRzLnNvcnQoKTtcblxuICAgIC8vIDUpIFJldHVybiB0aGUgaGFzaCB0aGF0IHJlc3VsdHMgZnJvbSBwYXNzaW5nIHRoZSBzb3J0ZWQsIGpvaW5lZCBucXVhZHNcbiAgICAvLyB0aHJvdWdoIHRoZSBoYXNoIGFsZ29yaXRobS5cbiAgICBjb25zdCBtZCA9IHRoaXMuY3JlYXRlTWVzc2FnZURpZ2VzdCgpO1xuICAgIGZvcihjb25zdCBucXVhZCBvZiBucXVhZHMpIHtcbiAgICAgIG1kLnVwZGF0ZShucXVhZCk7XG4gICAgfVxuICAgIGluZm8uaGFzaCA9IGF3YWl0IG1kLmRpZ2VzdCgpO1xuICAgIHJldHVybiBpbmZvLmhhc2g7XG4gIH1cblxuICAvLyA0LjcpIEhhc2ggUmVsYXRlZCBCbGFuayBOb2RlXG4gIGFzeW5jIGhhc2hSZWxhdGVkQmxhbmtOb2RlKHJlbGF0ZWQsIHF1YWQsIGlzc3VlciwgcG9zaXRpb24pIHtcbiAgICAvLyAxKSBJbml0aWFsaXplIGEgc3RyaW5nIGlucHV0IHRvIHRoZSB2YWx1ZSBvZiBwb3NpdGlvbi5cbiAgICAvLyBOb3RlOiBXZSB1c2UgYSBoYXNoIG9iamVjdCBpbnN0ZWFkLlxuICAgIGNvbnN0IG1kID0gdGhpcy5jcmVhdGVNZXNzYWdlRGlnZXN0KCk7XG4gICAgbWQudXBkYXRlKHBvc2l0aW9uKTtcblxuICAgIC8vIDIpIElmIHBvc2l0aW9uIGlzIG5vdCBnLCBhcHBlbmQgPCwgdGhlIHZhbHVlIG9mIHRoZSBwcmVkaWNhdGUgaW4gcXVhZCxcbiAgICAvLyBhbmQgPiB0byBpbnB1dC5cbiAgICBpZihwb3NpdGlvbiAhPT0gJ2cnKSB7XG4gICAgICBtZC51cGRhdGUodGhpcy5nZXRSZWxhdGVkUHJlZGljYXRlKHF1YWQpKTtcbiAgICB9XG5cbiAgICAvLyAzKSBTZXQgdGhlIGlkZW50aWZpZXIgdG8gdXNlIGZvciByZWxhdGVkLCBwcmVmZXJyaW5nIGZpcnN0IHRoZSBjYW5vbmljYWxcbiAgICAvLyBpZGVudGlmaWVyIGZvciByZWxhdGVkIGlmIGlzc3VlZCwgc2Vjb25kIHRoZSBpZGVudGlmaWVyIGlzc3VlZCBieSBpc3N1ZXJcbiAgICAvLyBpZiBpc3N1ZWQsIGFuZCBsYXN0LCBpZiBuZWNlc3NhcnksIHRoZSByZXN1bHQgb2YgdGhlIEhhc2ggRmlyc3QgRGVncmVlXG4gICAgLy8gUXVhZHMgYWxnb3JpdGhtLCBwYXNzaW5nIHJlbGF0ZWQuXG4gICAgbGV0IGlkO1xuICAgIGlmKHRoaXMuY2Fub25pY2FsSXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICBpZCA9ICdfOicgKyB0aGlzLmNhbm9uaWNhbElzc3Vlci5nZXRJZChyZWxhdGVkKTtcbiAgICB9IGVsc2UgaWYoaXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICBpZCA9ICdfOicgKyBpc3N1ZXIuZ2V0SWQocmVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gdGhpcy5ibGFua05vZGVJbmZvLmdldChyZWxhdGVkKS5oYXNoO1xuICAgIH1cblxuICAgIC8vIDQpIEFwcGVuZCBpZGVudGlmaWVyIHRvIGlucHV0LlxuICAgIG1kLnVwZGF0ZShpZCk7XG5cbiAgICAvLyA1KSBSZXR1cm4gdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyBpbnB1dCB0aHJvdWdoIHRoZSBoYXNoXG4gICAgLy8gYWxnb3JpdGhtLlxuICAgIHJldHVybiBtZC5kaWdlc3QoKTtcbiAgfVxuXG4gIC8vIDQuOCkgSGFzaCBOLURlZ3JlZSBRdWFkc1xuICBhc3luYyBoYXNoTkRlZ3JlZVF1YWRzKGlkLCBpc3N1ZXIpIHtcbiAgICBpZih0aGlzLnJlbWFpbmluZ0RlZXBJdGVyYXRpb25zID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNYXhpbXVtIGRlZXAgaXRlcmF0aW9ucyBleGNlZWRlZCAoJHt0aGlzLm1heERlZXBJdGVyYXRpb25zfSkuYCk7XG4gICAgfVxuICAgIHRoaXMucmVtYWluaW5nRGVlcEl0ZXJhdGlvbnMtLTtcblxuICAgIC8vIDEpIENyZWF0ZSBhIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAgZm9yIHN0b3JpbmcgaGFzaGVzIHRoYXRcbiAgICAvLyBpZGVudGlmeSByZWxhdGVkIGJsYW5rIG5vZGVzLlxuICAgIC8vIE5vdGU6IDIpIGFuZCAzKSBoYW5kbGVkIHdpdGhpbiBgY3JlYXRlSGFzaFRvUmVsYXRlZGBcbiAgICBjb25zdCBtZCA9IHRoaXMuY3JlYXRlTWVzc2FnZURpZ2VzdCgpO1xuICAgIGNvbnN0IGhhc2hUb1JlbGF0ZWQgPSBhd2FpdCB0aGlzLmNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3Vlcik7XG5cbiAgICAvLyA0KSBDcmVhdGUgYW4gZW1wdHkgc3RyaW5nLCBkYXRhIHRvIGhhc2guXG4gICAgLy8gTm90ZTogV2UgY3JlYXRlZCBhIGhhc2ggb2JqZWN0IGBtZGAgYWJvdmUgaW5zdGVhZC5cblxuICAgIC8vIDUpIEZvciBlYWNoIHJlbGF0ZWQgaGFzaCB0byBibGFuayBub2RlIGxpc3QgbWFwcGluZyBpbiBoYXNoIHRvIHJlbGF0ZWRcbiAgICAvLyBibGFuayBub2RlcyBtYXAsIHNvcnRlZCBsZXhpY29ncmFwaGljYWxseSBieSByZWxhdGVkIGhhc2g6XG4gICAgY29uc3QgaGFzaGVzID0gWy4uLmhhc2hUb1JlbGF0ZWQua2V5cygpXS5zb3J0KCk7XG4gICAgZm9yKGNvbnN0IGhhc2ggb2YgaGFzaGVzKSB7XG4gICAgICAvLyA1LjEpIEFwcGVuZCB0aGUgcmVsYXRlZCBoYXNoIHRvIHRoZSBkYXRhIHRvIGhhc2guXG4gICAgICBtZC51cGRhdGUoaGFzaCk7XG5cbiAgICAgIC8vIDUuMikgQ3JlYXRlIGEgc3RyaW5nIGNob3NlbiBwYXRoLlxuICAgICAgbGV0IGNob3NlblBhdGggPSAnJztcblxuICAgICAgLy8gNS4zKSBDcmVhdGUgYW4gdW5zZXQgY2hvc2VuIGlzc3VlciB2YXJpYWJsZS5cbiAgICAgIGxldCBjaG9zZW5Jc3N1ZXI7XG5cbiAgICAgIC8vIDUuNCkgRm9yIGVhY2ggcGVybXV0YXRpb24gb2YgYmxhbmsgbm9kZSBsaXN0OlxuICAgICAgY29uc3QgcGVybXV0ZXIgPSBuZXcgUGVybXV0ZXIoaGFzaFRvUmVsYXRlZC5nZXQoaGFzaCkpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUocGVybXV0ZXIuaGFzTmV4dCgpKSB7XG4gICAgICAgIGNvbnN0IHBlcm11dGF0aW9uID0gcGVybXV0ZXIubmV4dCgpO1xuICAgICAgICAvLyBOb3RlOiBiYXRjaCBwZXJtdXRhdGlvbnMgMyBhdCBhIHRpbWVcbiAgICAgICAgaWYoKytpICUgMyA9PT0gMCkge1xuICAgICAgICAgIGlmKHRoaXMuc2lnbmFsICYmIHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWJvcnQgc2lnbmFsIHJlY2VpdmVkOiBcIiR7dGhpcy5zaWduYWwucmVhc29ufVwiLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLl95aWVsZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS40LjEpIENyZWF0ZSBhIGNvcHkgb2YgaXNzdWVyLCBpc3N1ZXIgY29weS5cbiAgICAgICAgbGV0IGlzc3VlckNvcHkgPSBpc3N1ZXIuY2xvbmUoKTtcblxuICAgICAgICAvLyA1LjQuMikgQ3JlYXRlIGEgc3RyaW5nIHBhdGguXG4gICAgICAgIGxldCBwYXRoID0gJyc7XG5cbiAgICAgICAgLy8gNS40LjMpIENyZWF0ZSBhIHJlY3Vyc2lvbiBsaXN0LCB0byBzdG9yZSBibGFuayBub2RlIGlkZW50aWZpZXJzXG4gICAgICAgIC8vIHRoYXQgbXVzdCBiZSByZWN1cnNpdmVseSBwcm9jZXNzZWQgYnkgdGhpcyBhbGdvcml0aG0uXG4gICAgICAgIGNvbnN0IHJlY3Vyc2lvbkxpc3QgPSBbXTtcblxuICAgICAgICAvLyA1LjQuNCkgRm9yIGVhY2ggcmVsYXRlZCBpbiBwZXJtdXRhdGlvbjpcbiAgICAgICAgbGV0IG5leHRQZXJtdXRhdGlvbiA9IGZhbHNlO1xuICAgICAgICBmb3IoY29uc3QgcmVsYXRlZCBvZiBwZXJtdXRhdGlvbikge1xuICAgICAgICAgIC8vIDUuNC40LjEpIElmIGEgY2Fub25pY2FsIGlkZW50aWZpZXIgaGFzIGJlZW4gaXNzdWVkIGZvclxuICAgICAgICAgIC8vIHJlbGF0ZWQsIGFwcGVuZCBpdCB0byBwYXRoLlxuICAgICAgICAgIGlmKHRoaXMuY2Fub25pY2FsSXNzdWVyLmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgICBwYXRoICs9ICdfOicgKyB0aGlzLmNhbm9uaWNhbElzc3Vlci5nZXRJZChyZWxhdGVkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gNS40LjQuMikgT3RoZXJ3aXNlOlxuICAgICAgICAgICAgLy8gNS40LjQuMi4xKSBJZiBpc3N1ZXIgY29weSBoYXMgbm90IGlzc3VlZCBhbiBpZGVudGlmaWVyIGZvclxuICAgICAgICAgICAgLy8gcmVsYXRlZCwgYXBwZW5kIHJlbGF0ZWQgdG8gcmVjdXJzaW9uIGxpc3QuXG4gICAgICAgICAgICBpZighaXNzdWVyQ29weS5oYXNJZChyZWxhdGVkKSkge1xuICAgICAgICAgICAgICByZWN1cnNpb25MaXN0LnB1c2gocmVsYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA1LjQuNC4yLjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmdcbiAgICAgICAgICAgIC8vIGlzc3VlciBjb3B5IGFuZCByZWxhdGVkIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byBwYXRoLlxuICAgICAgICAgICAgcGF0aCArPSAnXzonICsgaXNzdWVyQ29weS5nZXRJZChyZWxhdGVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA1LjQuNC4zKSBJZiBjaG9zZW4gcGF0aCBpcyBub3QgZW1wdHkgYW5kIHRoZSBsZW5ndGggb2YgcGF0aFxuICAgICAgICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIGNob3NlbiBwYXRoIGFuZFxuICAgICAgICAgIC8vIHBhdGggaXMgbGV4aWNvZ3JhcGhpY2FsbHkgZ3JlYXRlciB0aGFuIGNob3NlbiBwYXRoLCB0aGVuXG4gICAgICAgICAgLy8gc2tpcCB0byB0aGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICAgICAgICAvLyBOb3RlOiBDb21wYXJpbmcgcGF0aCBsZW5ndGggdG8gY2hvc2VuIHBhdGggbGVuZ3RoIGNhbiBiZSBvcHRpbWl6ZWRcbiAgICAgICAgICAvLyBhd2F5OyBvbmx5IGNvbXBhcmUgbGV4aWNvZ3JhcGhpY2FsbHkuXG4gICAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggIT09IDAgJiYgcGF0aCA+IGNob3NlblBhdGgpIHtcbiAgICAgICAgICAgIG5leHRQZXJtdXRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZXh0UGVybXV0YXRpb24pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuNC41KSBGb3IgZWFjaCByZWxhdGVkIGluIHJlY3Vyc2lvbiBsaXN0OlxuICAgICAgICBmb3IoY29uc3QgcmVsYXRlZCBvZiByZWN1cnNpb25MaXN0KSB7XG4gICAgICAgICAgLy8gNS40LjUuMSkgU2V0IHJlc3VsdCB0byB0aGUgcmVzdWx0IG9mIHJlY3Vyc2l2ZWx5IGV4ZWN1dGluZ1xuICAgICAgICAgIC8vIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobSwgcGFzc2luZyByZWxhdGVkIGZvclxuICAgICAgICAgIC8vIGlkZW50aWZpZXIgYW5kIGlzc3VlciBjb3B5IGZvciBwYXRoIGlkZW50aWZpZXIgaXNzdWVyLlxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFzaE5EZWdyZWVRdWFkcyhyZWxhdGVkLCBpc3N1ZXJDb3B5KTtcblxuICAgICAgICAgIC8vIDUuNC41LjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgaXNzdWVyXG4gICAgICAgICAgLy8gY29weSBhbmQgcmVsYXRlZCBhbmQgYXBwZW5kIHRoZSByZXN1bHQgdG8gcGF0aC5cbiAgICAgICAgICBwYXRoICs9ICdfOicgKyBpc3N1ZXJDb3B5LmdldElkKHJlbGF0ZWQpO1xuXG4gICAgICAgICAgLy8gNS40LjUuMykgQXBwZW5kIDwsIHRoZSBoYXNoIGluIHJlc3VsdCwgYW5kID4gdG8gcGF0aC5cbiAgICAgICAgICBwYXRoICs9IGA8JHtyZXN1bHQuaGFzaH0+YDtcblxuICAgICAgICAgIC8vIDUuNC41LjQpIFNldCBpc3N1ZXIgY29weSB0byB0aGUgaWRlbnRpZmllciBpc3N1ZXIgaW5cbiAgICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgICAgaXNzdWVyQ29weSA9IHJlc3VsdC5pc3N1ZXI7XG5cbiAgICAgICAgICAvLyA1LjQuNS41KSBJZiBjaG9zZW4gcGF0aCBpcyBub3QgZW1wdHkgYW5kIHRoZSBsZW5ndGggb2YgcGF0aFxuICAgICAgICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIGNob3NlbiBwYXRoIGFuZFxuICAgICAgICAgIC8vIHBhdGggaXMgbGV4aWNvZ3JhcGhpY2FsbHkgZ3JlYXRlciB0aGFuIGNob3NlbiBwYXRoLCB0aGVuXG4gICAgICAgICAgLy8gc2tpcCB0byB0aGUgbmV4dCBwZXJtdXRhdGlvbi5cbiAgICAgICAgICAvLyBOb3RlOiBDb21wYXJpbmcgcGF0aCBsZW5ndGggdG8gY2hvc2VuIHBhdGggbGVuZ3RoIGNhbiBiZSBvcHRpbWl6ZWRcbiAgICAgICAgICAvLyBhd2F5OyBvbmx5IGNvbXBhcmUgbGV4aWNvZ3JhcGhpY2FsbHkuXG4gICAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggIT09IDAgJiYgcGF0aCA+IGNob3NlblBhdGgpIHtcbiAgICAgICAgICAgIG5leHRQZXJtdXRhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihuZXh0UGVybXV0YXRpb24pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuNC42KSBJZiBjaG9zZW4gcGF0aCBpcyBlbXB0eSBvciBwYXRoIGlzIGxleGljb2dyYXBoaWNhbGx5XG4gICAgICAgIC8vIGxlc3MgdGhhbiBjaG9zZW4gcGF0aCwgc2V0IGNob3NlbiBwYXRoIHRvIHBhdGggYW5kIGNob3NlblxuICAgICAgICAvLyBpc3N1ZXIgdG8gaXNzdWVyIGNvcHkuXG4gICAgICAgIGlmKGNob3NlblBhdGgubGVuZ3RoID09PSAwIHx8IHBhdGggPCBjaG9zZW5QYXRoKSB7XG4gICAgICAgICAgY2hvc2VuUGF0aCA9IHBhdGg7XG4gICAgICAgICAgY2hvc2VuSXNzdWVyID0gaXNzdWVyQ29weTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA1LjUpIEFwcGVuZCBjaG9zZW4gcGF0aCB0byBkYXRhIHRvIGhhc2guXG4gICAgICBtZC51cGRhdGUoY2hvc2VuUGF0aCk7XG5cbiAgICAgIC8vIDUuNikgUmVwbGFjZSBpc3N1ZXIsIGJ5IHJlZmVyZW5jZSwgd2l0aCBjaG9zZW4gaXNzdWVyLlxuICAgICAgaXNzdWVyID0gY2hvc2VuSXNzdWVyO1xuICAgIH1cblxuICAgIC8vIDYpIFJldHVybiBpc3N1ZXIgYW5kIHRoZSBoYXNoIHRoYXQgcmVzdWx0cyBmcm9tIHBhc3NpbmcgZGF0YSB0byBoYXNoXG4gICAgLy8gdGhyb3VnaCB0aGUgaGFzaCBhbGdvcml0aG0uXG4gICAgcmV0dXJuIHtoYXNoOiBhd2FpdCBtZC5kaWdlc3QoKSwgaXNzdWVyfTtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgbW9kaWZ5aW5nIGNvbXBvbmVudCBkdXJpbmcgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgbW9kaWZ5Rmlyc3REZWdyZWVDb21wb25lbnQoaWQsIGNvbXBvbmVudCkge1xuICAgIGlmKGNvbXBvbmVudC50ZXJtVHlwZSAhPT0gJ0JsYW5rTm9kZScpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIC8qIE5vdGU6IEEgbWlzdGFrZSBpbiB0aGUgUkRGQy0xLjAgc3BlYyB0aGF0IG1hZGUgaXRzIHdheSBpbnRvXG4gICAgaW1wbGVtZW50YXRpb25zIChhbmQgdGhlcmVmb3JlIG11c3Qgc3RheSB0byBhdm9pZCBpbnRlcm9wIGJyZWFrYWdlKVxuICAgIHJlc3VsdGVkIGluIGFuIGFzc2lnbmVkIGNhbm9uaWNhbCBJRCwgaWYgYXZhaWxhYmxlIGZvclxuICAgIGBjb21wb25lbnQudmFsdWVgLCBub3QgYmVpbmcgdXNlZCBpbiBwbGFjZSBvZiBgXzphYC9gXzp6YCwgc29cbiAgICB3ZSBkb24ndCB1c2UgaXQgaGVyZS4gKi9cbiAgICByZXR1cm4ge1xuICAgICAgdGVybVR5cGU6ICdCbGFua05vZGUnLFxuICAgICAgdmFsdWU6IGNvbXBvbmVudC52YWx1ZSA9PT0gaWQgPyAnYScgOiAneidcbiAgICB9O1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBnZXR0aW5nIGEgcmVsYXRlZCBwcmVkaWNhdGVcbiAgZ2V0UmVsYXRlZFByZWRpY2F0ZShxdWFkKSB7XG4gICAgcmV0dXJuIGA8JHtxdWFkLnByZWRpY2F0ZS52YWx1ZX0+YDtcbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY3JlYXRpbmcgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcFxuICBhc3luYyBjcmVhdGVIYXNoVG9SZWxhdGVkKGlkLCBpc3N1ZXIpIHtcbiAgICAvLyAxKSBDcmVhdGUgYSBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwIGZvciBzdG9yaW5nIGhhc2hlcyB0aGF0XG4gICAgLy8gaWRlbnRpZnkgcmVsYXRlZCBibGFuayBub2Rlcy5cbiAgICBjb25zdCBoYXNoVG9SZWxhdGVkID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gMikgR2V0IGEgcmVmZXJlbmNlLCBxdWFkcywgdG8gdGhlIGxpc3Qgb2YgcXVhZHMgaW4gdGhlIGJsYW5rIG5vZGUgdG9cbiAgICAvLyBxdWFkcyBtYXAgZm9yIHRoZSBrZXkgaWRlbnRpZmllci5cbiAgICBjb25zdCBxdWFkcyA9IHRoaXMuYmxhbmtOb2RlSW5mby5nZXQoaWQpLnF1YWRzO1xuXG4gICAgLy8gMykgRm9yIGVhY2ggcXVhZCBpbiBxdWFkczpcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yKGNvbnN0IHF1YWQgb2YgcXVhZHMpIHtcbiAgICAgIC8vIE5vdGU6IGJhdGNoIGhhc2hpbmcgcmVsYXRlZCBibGFuayBub2RlIHF1YWRzIDEwMCBhdCBhIHRpbWVcbiAgICAgIGlmKCsraSAlIDEwMCA9PT0gMCkge1xuICAgICAgICBhd2FpdCB0aGlzLl95aWVsZCgpO1xuICAgICAgfVxuICAgICAgLy8gMy4xKSBGb3IgZWFjaCBjb21wb25lbnQgaW4gcXVhZCwgaWYgY29tcG9uZW50IGlzIHRoZSBzdWJqZWN0LCBvYmplY3QsXG4gICAgICAvLyBvciBncmFwaCBuYW1lIGFuZCBpdCBpcyBhIGJsYW5rIG5vZGUgdGhhdCBpcyBub3QgaWRlbnRpZmllZCBieVxuICAgICAgLy8gaWRlbnRpZmllcjpcbiAgICAgIC8vIHN0ZXBzIDMuMS4xIGFuZCAzLjEuMiBvY2N1ciBpbiBoZWxwZXJzOlxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLl9hZGRSZWxhdGVkQmxhbmtOb2RlSGFzaCh7XG4gICAgICAgICAgcXVhZCwgY29tcG9uZW50OiBxdWFkLnN1YmplY3QsIHBvc2l0aW9uOiAncycsXG4gICAgICAgICAgaWQsIGlzc3VlciwgaGFzaFRvUmVsYXRlZFxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5fYWRkUmVsYXRlZEJsYW5rTm9kZUhhc2goe1xuICAgICAgICAgIHF1YWQsIGNvbXBvbmVudDogcXVhZC5vYmplY3QsIHBvc2l0aW9uOiAnbycsXG4gICAgICAgICAgaWQsIGlzc3VlciwgaGFzaFRvUmVsYXRlZFxuICAgICAgICB9KSxcbiAgICAgICAgdGhpcy5fYWRkUmVsYXRlZEJsYW5rTm9kZUhhc2goe1xuICAgICAgICAgIHF1YWQsIGNvbXBvbmVudDogcXVhZC5ncmFwaCwgcG9zaXRpb246ICdnJyxcbiAgICAgICAgICBpZCwgaXNzdWVyLCBoYXNoVG9SZWxhdGVkXG4gICAgICAgIH0pXG4gICAgICBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaFRvUmVsYXRlZDtcbiAgfVxuXG4gIGFzeW5jIF9oYXNoQW5kVHJhY2tCbGFua05vZGUoe2lkLCBoYXNoVG9CbGFua05vZGVzfSkge1xuICAgIC8vIDUuMy4xKSBDcmVhdGUgYSBoYXNoLCBoYXNoLCBhY2NvcmRpbmcgdG8gdGhlIEhhc2ggRmlyc3QgRGVncmVlXG4gICAgLy8gUXVhZHMgYWxnb3JpdGhtLlxuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLmhhc2hGaXJzdERlZ3JlZVF1YWRzKGlkKTtcblxuICAgIC8vIDUuMy4yKSBBZGQgaGFzaCBhbmQgaWRlbnRpZmllciB0byBoYXNoIHRvIGJsYW5rIG5vZGVzIG1hcCxcbiAgICAvLyBjcmVhdGluZyBhIG5ldyBlbnRyeSBpZiBuZWNlc3NhcnkuXG4gICAgY29uc3QgaWRMaXN0ID0gaGFzaFRvQmxhbmtOb2Rlcy5nZXQoaGFzaCk7XG4gICAgaWYoIWlkTGlzdCkge1xuICAgICAgaGFzaFRvQmxhbmtOb2Rlcy5zZXQoaGFzaCwgW2lkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkTGlzdC5wdXNoKGlkKTtcbiAgICB9XG4gIH1cblxuICBfYWRkQmxhbmtOb2RlUXVhZEluZm8oe3F1YWQsIGNvbXBvbmVudH0pIHtcbiAgICBpZihjb21wb25lbnQudGVybVR5cGUgIT09ICdCbGFua05vZGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkID0gY29tcG9uZW50LnZhbHVlO1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmJsYW5rTm9kZUluZm8uZ2V0KGlkKTtcbiAgICBpZihpbmZvKSB7XG4gICAgICBpbmZvLnF1YWRzLmFkZChxdWFkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ibGFua05vZGVJbmZvLnNldChpZCwge3F1YWRzOiBuZXcgU2V0KFtxdWFkXSksIGhhc2g6IG51bGx9KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfYWRkUmVsYXRlZEJsYW5rTm9kZUhhc2goXG4gICAge3F1YWQsIGNvbXBvbmVudCwgcG9zaXRpb24sIGlkLCBpc3N1ZXIsIGhhc2hUb1JlbGF0ZWR9KSB7XG4gICAgaWYoIShjb21wb25lbnQudGVybVR5cGUgPT09ICdCbGFua05vZGUnICYmIGNvbXBvbmVudC52YWx1ZSAhPT0gaWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIDMuMS4xKSBTZXQgaGFzaCB0byB0aGUgcmVzdWx0IG9mIHRoZSBIYXNoIFJlbGF0ZWQgQmxhbmsgTm9kZVxuICAgIC8vIGFsZ29yaXRobSwgcGFzc2luZyB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGZvciBjb21wb25lbnQgYXNcbiAgICAvLyByZWxhdGVkLCBxdWFkLCBwYXRoIGlkZW50aWZpZXIgaXNzdWVyIGFzIGlzc3VlciwgYW5kIHBvc2l0aW9uIGFzXG4gICAgLy8gZWl0aGVyIHMsIG8sIG9yIGcgYmFzZWQgb24gd2hldGhlciBjb21wb25lbnQgaXMgYSBzdWJqZWN0LCBvYmplY3QsXG4gICAgLy8gZ3JhcGggbmFtZSwgcmVzcGVjdGl2ZWx5LlxuICAgIGNvbnN0IHJlbGF0ZWQgPSBjb21wb25lbnQudmFsdWU7XG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuaGFzaFJlbGF0ZWRCbGFua05vZGUoXG4gICAgICByZWxhdGVkLCBxdWFkLCBpc3N1ZXIsIHBvc2l0aW9uKTtcblxuICAgIC8vIDMuMS4yKSBBZGQgYSBtYXBwaW5nIG9mIGhhc2ggdG8gdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3JcbiAgICAvLyBjb21wb25lbnQgdG8gaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCwgYWRkaW5nIGFuIGVudHJ5IGFzXG4gICAgLy8gbmVjZXNzYXJ5LlxuICAgIGNvbnN0IGVudHJpZXMgPSBoYXNoVG9SZWxhdGVkLmdldChoYXNoKTtcbiAgICBpZihlbnRyaWVzKSB7XG4gICAgICBlbnRyaWVzLnB1c2gocmVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2hUb1JlbGF0ZWQuc2V0KGhhc2gsIFtyZWxhdGVkXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gY2Fub25pY2FsIGlkcyBmb3IgNy4xXG4gIF9jb21wb25lbnRXaXRoQ2Fub25pY2FsSWQoY29tcG9uZW50KSB7XG4gICAgaWYoY29tcG9uZW50LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJlxuICAgICAgIWNvbXBvbmVudC52YWx1ZS5zdGFydHNXaXRoKHRoaXMuY2Fub25pY2FsSXNzdWVyLnByZWZpeCkpIHtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgQmxhbmtOb2RlXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXJtVHlwZTogJ0JsYW5rTm9kZScsXG4gICAgICAgIHZhbHVlOiB0aGlzLmNhbm9uaWNhbElzc3Vlci5nZXRJZChjb21wb25lbnQudmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgYXN5bmMgX3lpZWxkKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldEltbWVkaWF0ZShyZXNvbHZlKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9zdHJpbmdIYXNoQ29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhLmhhc2ggPCBiLmhhc2ggPyAtMSA6IGEuaGFzaCA+IGIuaGFzaCA/IDEgOiAwO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10Sync.js":
/*!************************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10Sync.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2016-2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nconst IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\n// FIXME: do not import; convert to requiring a\n// hash factory\nconst MessageDigest = __webpack_require__(/*! ./MessageDigest */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest.js\");\nconst Permuter = __webpack_require__(/*! ./Permuter */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js\");\nconst NQuads = __webpack_require__(/*! ./NQuads */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js\");\n\nmodule.exports = class RDFC10Sync {\n  constructor({\n    createMessageDigest = null,\n    messageDigestAlgorithm = 'sha256',\n    canonicalIdMap = new Map(),\n    maxWorkFactor = 1,\n    maxDeepIterations = -1,\n    timeout = 0\n  } = {}) {\n    this.name = 'RDFC-1.0';\n    this.blankNodeInfo = new Map();\n    this.canonicalIssuer = new IdentifierIssuer('c14n', canonicalIdMap);\n    this.createMessageDigest = createMessageDigest ||\n      (() => new MessageDigest(messageDigestAlgorithm));\n    this.maxWorkFactor = maxWorkFactor;\n    this.maxDeepIterations = maxDeepIterations;\n    this.remainingDeepIterations = 0;\n    this.timeout = timeout;\n    if(timeout > 0) {\n      this.startTime = Date.now();\n    }\n    this.quads = null;\n  }\n\n  // 4.4) Normalization Algorithm\n  main(dataset) {\n    this.quads = dataset;\n\n    // 1) Create the normalization state.\n    // 2) For every quad in input dataset:\n    for(const quad of dataset) {\n      // 2.1) For each blank node that occurs in the quad, add a reference\n      // to the quad using the blank node identifier in the blank node to\n      // quads map, creating a new entry if necessary.\n      this._addBlankNodeQuadInfo({quad, component: quad.subject});\n      this._addBlankNodeQuadInfo({quad, component: quad.object});\n      this._addBlankNodeQuadInfo({quad, component: quad.graph});\n    }\n\n    // 3) Create a list of non-normalized blank node identifiers\n    // non-normalized identifiers and populate it using the keys from the\n    // blank node to quads map.\n    // Note: We use a map here and it was generated during step 2.\n\n    // 4) `simple` flag is skipped -- loop is optimized away. This optimization\n    // is permitted because there was a typo in the hash first degree quads\n    // algorithm in the RDFC-1.0 spec that was implemented widely making it\n    // such that it could not be fixed; the result was that the loop only\n    // needs to be run once and the first degree quad hashes will never change.\n    // 5.1-5.2 are skipped; first degree quad hashes are generated just once\n    // for all non-normalized blank nodes.\n\n    // 5.3) For each blank node identifier identifier in non-normalized\n    // identifiers:\n    const hashToBlankNodes = new Map();\n    const nonNormalized = [...this.blankNodeInfo.keys()];\n    for(const id of nonNormalized) {\n      // steps 5.3.1 and 5.3.2:\n      this._hashAndTrackBlankNode({id, hashToBlankNodes});\n    }\n\n    // 5.4) For each hash to identifier list mapping in hash to blank\n    // nodes map, lexicographically-sorted by hash:\n    const hashes = [...hashToBlankNodes.keys()].sort();\n    // optimize away second sort, gather non-unique hashes in order as we go\n    const nonUnique = [];\n    for(const hash of hashes) {\n      // 5.4.1) If the length of identifier list is greater than 1,\n      // continue to the next mapping.\n      const idList = hashToBlankNodes.get(hash);\n      if(idList.length > 1) {\n        nonUnique.push(idList);\n        continue;\n      }\n\n      // 5.4.2) Use the Issue Identifier algorithm, passing canonical\n      // issuer and the single blank node identifier in identifier\n      // list, identifier, to issue a canonical replacement identifier\n      // for identifier.\n      const id = idList[0];\n      this.canonicalIssuer.getId(id);\n\n      // Note: These steps are skipped, optimized away since the loop\n      // only needs to be run once.\n      // 5.4.3) Remove identifier from non-normalized identifiers.\n      // 5.4.4) Remove hash from the hash to blank nodes map.\n      // 5.4.5) Set simple to true.\n    }\n\n    if(this.maxDeepIterations < 0) {\n      // calculate maxDeepIterations if not explicit\n      if(this.maxWorkFactor === 0) {\n        this.maxDeepIterations = 0;\n      } else if(this.maxWorkFactor === Infinity) {\n        this.maxDeepIterations = Infinity;\n      } else {\n        const nonUniqueCount =\n          nonUnique.reduce((count, v) => count + v.length, 0);\n        this.maxDeepIterations = nonUniqueCount ** this.maxWorkFactor;\n      }\n    }\n    // handle any large inputs as Infinity\n    if(this.maxDeepIterations > Number.MAX_SAFE_INTEGER) {\n      this.maxDeepIterations = Infinity;\n    }\n    this.remainingDeepIterations = this.maxDeepIterations;\n\n    // 6) For each hash to identifier list mapping in hash to blank nodes map,\n    // lexicographically-sorted by hash:\n    // Note: sort optimized away, use `nonUnique`.\n    for(const idList of nonUnique) {\n      // 6.1) Create hash path list where each item will be a result of\n      // running the Hash N-Degree Quads algorithm.\n      const hashPathList = [];\n\n      // 6.2) For each blank node identifier identifier in identifier list:\n      for(const id of idList) {\n        // 6.2.1) If a canonical identifier has already been issued for\n        // identifier, continue to the next identifier.\n        if(this.canonicalIssuer.hasId(id)) {\n          continue;\n        }\n\n        // 6.2.2) Create temporary issuer, an identifier issuer\n        // initialized with the prefix _:b.\n        const issuer = new IdentifierIssuer('b');\n\n        // 6.2.3) Use the Issue Identifier algorithm, passing temporary\n        // issuer and identifier, to issue a new temporary blank node\n        // identifier for identifier.\n        issuer.getId(id);\n\n        // 6.2.4) Run the Hash N-Degree Quads algorithm, passing\n        // temporary issuer, and append the result to the hash path list.\n        const result = this.hashNDegreeQuads(id, issuer);\n        hashPathList.push(result);\n      }\n\n      // 6.3) For each result in the hash path list,\n      // lexicographically-sorted by the hash in result:\n      hashPathList.sort(_stringHashCompare);\n      for(const result of hashPathList) {\n        // 6.3.1) For each blank node identifier, existing identifier,\n        // that was issued a temporary identifier by identifier issuer\n        // in result, issue a canonical identifier, in the same order,\n        // using the Issue Identifier algorithm, passing canonical\n        // issuer and existing identifier.\n        const oldIds = result.issuer.getOldIds();\n        for(const id of oldIds) {\n          this.canonicalIssuer.getId(id);\n        }\n      }\n    }\n\n    /* Note: At this point all blank nodes in the set of RDF quads have been\n    assigned canonical identifiers, which have been stored in the canonical\n    issuer. Here each quad is updated by assigning each of its blank nodes\n    its new identifier. */\n\n    // 7) For each quad, quad, in input dataset:\n    const normalized = [];\n    for(const quad of this.quads) {\n      // 7.1) Create a copy, quad copy, of quad and replace any existing\n      // blank node identifiers using the canonical identifiers\n      // previously issued by canonical issuer.\n      // Note: We optimize away the copy here.\n      const nQuad = NQuads.serializeQuadComponents(\n        this._componentWithCanonicalId(quad.subject),\n        quad.predicate,\n        this._componentWithCanonicalId(quad.object),\n        this._componentWithCanonicalId(quad.graph)\n      );\n      // 7.2) Add quad copy to the normalized dataset.\n      normalized.push(nQuad);\n    }\n\n    // sort normalized output\n    normalized.sort();\n\n    // 8) Return the normalized dataset.\n    return normalized.join('');\n  }\n\n  // 4.6) Hash First Degree Quads\n  hashFirstDegreeQuads(id) {\n    // 1) Initialize nquads to an empty list. It will be used to store quads in\n    // N-Quads format.\n    const nquads = [];\n\n    // 2) Get the list of quads `quads` associated with the reference blank node\n    // identifier in the blank node to quads map.\n    const info = this.blankNodeInfo.get(id);\n    const quads = info.quads;\n\n    // 3) For each quad `quad` in `quads`:\n    for(const quad of quads) {\n      // 3.1) Serialize the quad in N-Quads format with the following special\n      // rule:\n\n      // 3.1.1) If any component in quad is an blank node, then serialize it\n      // using a special identifier as follows:\n      // 3.1.2) If the blank node's existing blank node identifier matches\n      // the reference blank node identifier then use the blank node\n      // identifier _:a, otherwise, use the blank node identifier _:z.\n      nquads.push(NQuads.serializeQuadComponents(\n        this.modifyFirstDegreeComponent(id, quad.subject, 'subject'),\n        quad.predicate,\n        this.modifyFirstDegreeComponent(id, quad.object, 'object'),\n        this.modifyFirstDegreeComponent(id, quad.graph, 'graph')\n      ));\n    }\n\n    // 4) Sort nquads in lexicographical order.\n    nquads.sort();\n\n    // 5) Return the hash that results from passing the sorted, joined nquads\n    // through the hash algorithm.\n    const md = this.createMessageDigest();\n    for(const nquad of nquads) {\n      md.update(nquad);\n    }\n    info.hash = md.digest();\n    return info.hash;\n  }\n\n  // 4.7) Hash Related Blank Node\n  hashRelatedBlankNode(related, quad, issuer, position) {\n    // 1) Initialize a string input to the value of position.\n    // Note: We use a hash object instead.\n    const md = this.createMessageDigest();\n    md.update(position);\n\n    // 2) If position is not g, append <, the value of the predicate in quad,\n    // and > to input.\n    if(position !== 'g') {\n      md.update(this.getRelatedPredicate(quad));\n    }\n\n    // 3) Set the identifier to use for related, preferring first the canonical\n    // identifier for related if issued, second the identifier issued by issuer\n    // if issued, and last, if necessary, the result of the Hash First Degree\n    // Quads algorithm, passing related.\n    let id;\n    if(this.canonicalIssuer.hasId(related)) {\n      id = '_:' + this.canonicalIssuer.getId(related);\n    } else if(issuer.hasId(related)) {\n      id = '_:' + issuer.getId(related);\n    } else {\n      id = this.blankNodeInfo.get(related).hash;\n    }\n\n    // 4) Append identifier to input.\n    md.update(id);\n\n    // 5) Return the hash that results from passing input through the hash\n    // algorithm.\n    return md.digest();\n  }\n\n  // 4.8) Hash N-Degree Quads\n  hashNDegreeQuads(id, issuer) {\n    if(this.remainingDeepIterations === 0) {\n      throw new Error(\n        `Maximum deep iterations exceeded (${this.maxDeepIterations}).`);\n    }\n    this.remainingDeepIterations--;\n\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    // Note: 2) and 3) handled within `createHashToRelated`\n    const md = this.createMessageDigest();\n    const hashToRelated = this.createHashToRelated(id, issuer);\n\n    // 4) Create an empty string, data to hash.\n    // Note: We created a hash object `md` above instead.\n\n    // 5) For each related hash to blank node list mapping in hash to related\n    // blank nodes map, sorted lexicographically by related hash:\n    const hashes = [...hashToRelated.keys()].sort();\n    for(const hash of hashes) {\n      // 5.1) Append the related hash to the data to hash.\n      md.update(hash);\n\n      // 5.2) Create a string chosen path.\n      let chosenPath = '';\n\n      // 5.3) Create an unset chosen issuer variable.\n      let chosenIssuer;\n\n      // 5.4) For each permutation of blank node list:\n      const permuter = new Permuter(hashToRelated.get(hash));\n      let i = 0;\n      while(permuter.hasNext()) {\n        const permutation = permuter.next();\n        // Note: batch permutations 3 at a time\n        if(++i % 3 === 0) {\n          if(this.timeout > 0 && Date.now() - this.startTime > this.timeout) {\n            throw new Error('Canonize timeout.');\n          }\n        }\n\n        // 5.4.1) Create a copy of issuer, issuer copy.\n        let issuerCopy = issuer.clone();\n\n        // 5.4.2) Create a string path.\n        let path = '';\n\n        // 5.4.3) Create a recursion list, to store blank node identifiers\n        // that must be recursively processed by this algorithm.\n        const recursionList = [];\n\n        // 5.4.4) For each related in permutation:\n        let nextPermutation = false;\n        for(const related of permutation) {\n          // 5.4.4.1) If a canonical identifier has been issued for\n          // related, append it to path.\n          if(this.canonicalIssuer.hasId(related)) {\n            path += '_:' + this.canonicalIssuer.getId(related);\n          } else {\n            // 5.4.4.2) Otherwise:\n            // 5.4.4.2.1) If issuer copy has not issued an identifier for\n            // related, append related to recursion list.\n            if(!issuerCopy.hasId(related)) {\n              recursionList.push(related);\n            }\n            // 5.4.4.2.2) Use the Issue Identifier algorithm, passing\n            // issuer copy and related and append the result to path.\n            path += '_:' + issuerCopy.getId(related);\n          }\n\n          // 5.4.4.3) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.5) For each related in recursion list:\n        for(const related of recursionList) {\n          // 5.4.5.1) Set result to the result of recursively executing\n          // the Hash N-Degree Quads algorithm, passing related for\n          // identifier and issuer copy for path identifier issuer.\n          const result = this.hashNDegreeQuads(related, issuerCopy);\n\n          // 5.4.5.2) Use the Issue Identifier algorithm, passing issuer\n          // copy and related and append the result to path.\n          path += '_:' + issuerCopy.getId(related);\n\n          // 5.4.5.3) Append <, the hash in result, and > to path.\n          path += `<${result.hash}>`;\n\n          // 5.4.5.4) Set issuer copy to the identifier issuer in\n          // result.\n          issuerCopy = result.issuer;\n\n          // 5.4.5.5) If chosen path is not empty and the length of path\n          // is greater than or equal to the length of chosen path and\n          // path is lexicographically greater than chosen path, then\n          // skip to the next permutation.\n          // Note: Comparing path length to chosen path length can be optimized\n          // away; only compare lexicographically.\n          if(chosenPath.length !== 0 && path > chosenPath) {\n            nextPermutation = true;\n            break;\n          }\n        }\n\n        if(nextPermutation) {\n          continue;\n        }\n\n        // 5.4.6) If chosen path is empty or path is lexicographically\n        // less than chosen path, set chosen path to path and chosen\n        // issuer to issuer copy.\n        if(chosenPath.length === 0 || path < chosenPath) {\n          chosenPath = path;\n          chosenIssuer = issuerCopy;\n        }\n      }\n\n      // 5.5) Append chosen path to data to hash.\n      md.update(chosenPath);\n\n      // 5.6) Replace issuer, by reference, with chosen issuer.\n      issuer = chosenIssuer;\n    }\n\n    // 6) Return issuer and the hash that results from passing data to hash\n    // through the hash algorithm.\n    return {hash: md.digest(), issuer};\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    /* Note: A mistake in the RDFC-1.0 spec that made its way into\n    implementations (and therefore must stay to avoid interop breakage)\n    resulted in an assigned canonical ID, if available for\n    `component.value`, not being used in place of `_:a`/`_:z`, so\n    we don't use it here. */\n    return {\n      termType: 'BlankNode',\n      value: component.value === id ? 'a' : 'z'\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return `<${quad.predicate.value}>`;\n  }\n\n  // helper for creating hash to related blank nodes map\n  createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    for(const quad of quads) {\n      // 3.1) For each component in quad, if component is the subject, object,\n      // or graph name and it is a blank node that is not identified by\n      // identifier:\n      // steps 3.1.1 and 3.1.2 occur in helpers:\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.subject, position: 's',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.object, position: 'o',\n        id, issuer, hashToRelated\n      });\n      this._addRelatedBlankNodeHash({\n        quad, component: quad.graph, position: 'g',\n        id, issuer, hashToRelated\n      });\n    }\n\n    return hashToRelated;\n  }\n\n  _hashAndTrackBlankNode({id, hashToBlankNodes}) {\n    // 5.3.1) Create a hash, hash, according to the Hash First Degree\n    // Quads algorithm.\n    const hash = this.hashFirstDegreeQuads(id);\n\n    // 5.3.2) Add hash and identifier to hash to blank nodes map,\n    // creating a new entry if necessary.\n    const idList = hashToBlankNodes.get(hash);\n    if(!idList) {\n      hashToBlankNodes.set(hash, [id]);\n    } else {\n      idList.push(id);\n    }\n  }\n\n  _addBlankNodeQuadInfo({quad, component}) {\n    if(component.termType !== 'BlankNode') {\n      return;\n    }\n    const id = component.value;\n    const info = this.blankNodeInfo.get(id);\n    if(info) {\n      info.quads.add(quad);\n    } else {\n      this.blankNodeInfo.set(id, {quads: new Set([quad]), hash: null});\n    }\n  }\n\n  _addRelatedBlankNodeHash(\n    {quad, component, position, id, issuer, hashToRelated}) {\n    if(!(component.termType === 'BlankNode' && component.value !== id)) {\n      return;\n    }\n    // 3.1.1) Set hash to the result of the Hash Related Blank Node\n    // algorithm, passing the blank node identifier for component as\n    // related, quad, path identifier issuer as issuer, and position as\n    // either s, o, or g based on whether component is a subject, object,\n    // graph name, respectively.\n    const related = component.value;\n    const hash = this.hashRelatedBlankNode(\n      related, quad, issuer, position);\n\n    // 3.1.2) Add a mapping of hash to the blank node identifier for\n    // component to hash to related blank nodes map, adding an entry as\n    // necessary.\n    const entries = hashToRelated.get(hash);\n    if(entries) {\n      entries.push(related);\n    } else {\n      hashToRelated.set(hash, [related]);\n    }\n  }\n\n  // canonical ids for 7.1\n  _componentWithCanonicalId(component) {\n    if(component.termType === 'BlankNode' &&\n      !component.value.startsWith(this.canonicalIssuer.prefix)) {\n      // create new BlankNode\n      return {\n        termType: 'BlankNode',\n        value: this.canonicalIssuer.getId(component.value)\n      };\n    }\n    return component;\n  }\n};\n\nfunction _stringHashCompare(a, b) {\n  return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvUkRGQzEwU3luYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYix5QkFBeUIsbUJBQU8sQ0FBQyxvSEFBb0I7QUFDckQseUJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOEdBQWlCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLG9HQUFZO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxnR0FBVTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEUsa0NBQWtDLDZCQUE2QjtBQUMvRCxrQ0FBa0MsNEJBQTRCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFlBQVk7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixrQ0FBa0MsbUNBQW1DO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLHFEQUFxRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL25vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL1JERkMxMFN5bmMuanM/ZGI5NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzIERpZ2l0YWwgQmF6YWFyLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgSWRlbnRpZmllcklzc3VlciA9IHJlcXVpcmUoJy4vSWRlbnRpZmllcklzc3VlcicpO1xuLy8gRklYTUU6IGRvIG5vdCBpbXBvcnQ7IGNvbnZlcnQgdG8gcmVxdWlyaW5nIGFcbi8vIGhhc2ggZmFjdG9yeVxuY29uc3QgTWVzc2FnZURpZ2VzdCA9IHJlcXVpcmUoJy4vTWVzc2FnZURpZ2VzdCcpO1xuY29uc3QgUGVybXV0ZXIgPSByZXF1aXJlKCcuL1Blcm11dGVyJyk7XG5jb25zdCBOUXVhZHMgPSByZXF1aXJlKCcuL05RdWFkcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJERkMxMFN5bmMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY3JlYXRlTWVzc2FnZURpZ2VzdCA9IG51bGwsXG4gICAgbWVzc2FnZURpZ2VzdEFsZ29yaXRobSA9ICdzaGEyNTYnLFxuICAgIGNhbm9uaWNhbElkTWFwID0gbmV3IE1hcCgpLFxuICAgIG1heFdvcmtGYWN0b3IgPSAxLFxuICAgIG1heERlZXBJdGVyYXRpb25zID0gLTEsXG4gICAgdGltZW91dCA9IDBcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gJ1JERkMtMS4wJztcbiAgICB0aGlzLmJsYW5rTm9kZUluZm8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYW5vbmljYWxJc3N1ZXIgPSBuZXcgSWRlbnRpZmllcklzc3VlcignYzE0bicsIGNhbm9uaWNhbElkTWFwKTtcbiAgICB0aGlzLmNyZWF0ZU1lc3NhZ2VEaWdlc3QgPSBjcmVhdGVNZXNzYWdlRGlnZXN0IHx8XG4gICAgICAoKCkgPT4gbmV3IE1lc3NhZ2VEaWdlc3QobWVzc2FnZURpZ2VzdEFsZ29yaXRobSkpO1xuICAgIHRoaXMubWF4V29ya0ZhY3RvciA9IG1heFdvcmtGYWN0b3I7XG4gICAgdGhpcy5tYXhEZWVwSXRlcmF0aW9ucyA9IG1heERlZXBJdGVyYXRpb25zO1xuICAgIHRoaXMucmVtYWluaW5nRGVlcEl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgaWYodGltZW91dCA+IDApIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gICAgdGhpcy5xdWFkcyA9IG51bGw7XG4gIH1cblxuICAvLyA0LjQpIE5vcm1hbGl6YXRpb24gQWxnb3JpdGhtXG4gIG1haW4oZGF0YXNldCkge1xuICAgIHRoaXMucXVhZHMgPSBkYXRhc2V0O1xuXG4gICAgLy8gMSkgQ3JlYXRlIHRoZSBub3JtYWxpemF0aW9uIHN0YXRlLlxuICAgIC8vIDIpIEZvciBldmVyeSBxdWFkIGluIGlucHV0IGRhdGFzZXQ6XG4gICAgZm9yKGNvbnN0IHF1YWQgb2YgZGF0YXNldCkge1xuICAgICAgLy8gMi4xKSBGb3IgZWFjaCBibGFuayBub2RlIHRoYXQgb2NjdXJzIGluIHRoZSBxdWFkLCBhZGQgYSByZWZlcmVuY2VcbiAgICAgIC8vIHRvIHRoZSBxdWFkIHVzaW5nIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgaW4gdGhlIGJsYW5rIG5vZGUgdG9cbiAgICAgIC8vIHF1YWRzIG1hcCwgY3JlYXRpbmcgYSBuZXcgZW50cnkgaWYgbmVjZXNzYXJ5LlxuICAgICAgdGhpcy5fYWRkQmxhbmtOb2RlUXVhZEluZm8oe3F1YWQsIGNvbXBvbmVudDogcXVhZC5zdWJqZWN0fSk7XG4gICAgICB0aGlzLl9hZGRCbGFua05vZGVRdWFkSW5mbyh7cXVhZCwgY29tcG9uZW50OiBxdWFkLm9iamVjdH0pO1xuICAgICAgdGhpcy5fYWRkQmxhbmtOb2RlUXVhZEluZm8oe3F1YWQsIGNvbXBvbmVudDogcXVhZC5ncmFwaH0pO1xuICAgIH1cblxuICAgIC8vIDMpIENyZWF0ZSBhIGxpc3Qgb2Ygbm9uLW5vcm1hbGl6ZWQgYmxhbmsgbm9kZSBpZGVudGlmaWVyc1xuICAgIC8vIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzIGFuZCBwb3B1bGF0ZSBpdCB1c2luZyB0aGUga2V5cyBmcm9tIHRoZVxuICAgIC8vIGJsYW5rIG5vZGUgdG8gcXVhZHMgbWFwLlxuICAgIC8vIE5vdGU6IFdlIHVzZSBhIG1hcCBoZXJlIGFuZCBpdCB3YXMgZ2VuZXJhdGVkIGR1cmluZyBzdGVwIDIuXG5cbiAgICAvLyA0KSBgc2ltcGxlYCBmbGFnIGlzIHNraXBwZWQgLS0gbG9vcCBpcyBvcHRpbWl6ZWQgYXdheS4gVGhpcyBvcHRpbWl6YXRpb25cbiAgICAvLyBpcyBwZXJtaXR0ZWQgYmVjYXVzZSB0aGVyZSB3YXMgYSB0eXBvIGluIHRoZSBoYXNoIGZpcnN0IGRlZ3JlZSBxdWFkc1xuICAgIC8vIGFsZ29yaXRobSBpbiB0aGUgUkRGQy0xLjAgc3BlYyB0aGF0IHdhcyBpbXBsZW1lbnRlZCB3aWRlbHkgbWFraW5nIGl0XG4gICAgLy8gc3VjaCB0aGF0IGl0IGNvdWxkIG5vdCBiZSBmaXhlZDsgdGhlIHJlc3VsdCB3YXMgdGhhdCB0aGUgbG9vcCBvbmx5XG4gICAgLy8gbmVlZHMgdG8gYmUgcnVuIG9uY2UgYW5kIHRoZSBmaXJzdCBkZWdyZWUgcXVhZCBoYXNoZXMgd2lsbCBuZXZlciBjaGFuZ2UuXG4gICAgLy8gNS4xLTUuMiBhcmUgc2tpcHBlZDsgZmlyc3QgZGVncmVlIHF1YWQgaGFzaGVzIGFyZSBnZW5lcmF0ZWQganVzdCBvbmNlXG4gICAgLy8gZm9yIGFsbCBub24tbm9ybWFsaXplZCBibGFuayBub2Rlcy5cblxuICAgIC8vIDUuMykgRm9yIGVhY2ggYmxhbmsgbm9kZSBpZGVudGlmaWVyIGlkZW50aWZpZXIgaW4gbm9uLW5vcm1hbGl6ZWRcbiAgICAvLyBpZGVudGlmaWVyczpcbiAgICBjb25zdCBoYXNoVG9CbGFua05vZGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG5vbk5vcm1hbGl6ZWQgPSBbLi4udGhpcy5ibGFua05vZGVJbmZvLmtleXMoKV07XG4gICAgZm9yKGNvbnN0IGlkIG9mIG5vbk5vcm1hbGl6ZWQpIHtcbiAgICAgIC8vIHN0ZXBzIDUuMy4xIGFuZCA1LjMuMjpcbiAgICAgIHRoaXMuX2hhc2hBbmRUcmFja0JsYW5rTm9kZSh7aWQsIGhhc2hUb0JsYW5rTm9kZXN9KTtcbiAgICB9XG5cbiAgICAvLyA1LjQpIEZvciBlYWNoIGhhc2ggdG8gaWRlbnRpZmllciBsaXN0IG1hcHBpbmcgaW4gaGFzaCB0byBibGFua1xuICAgIC8vIG5vZGVzIG1hcCwgbGV4aWNvZ3JhcGhpY2FsbHktc29ydGVkIGJ5IGhhc2g6XG4gICAgY29uc3QgaGFzaGVzID0gWy4uLmhhc2hUb0JsYW5rTm9kZXMua2V5cygpXS5zb3J0KCk7XG4gICAgLy8gb3B0aW1pemUgYXdheSBzZWNvbmQgc29ydCwgZ2F0aGVyIG5vbi11bmlxdWUgaGFzaGVzIGluIG9yZGVyIGFzIHdlIGdvXG4gICAgY29uc3Qgbm9uVW5pcXVlID0gW107XG4gICAgZm9yKGNvbnN0IGhhc2ggb2YgaGFzaGVzKSB7XG4gICAgICAvLyA1LjQuMSkgSWYgdGhlIGxlbmd0aCBvZiBpZGVudGlmaWVyIGxpc3QgaXMgZ3JlYXRlciB0aGFuIDEsXG4gICAgICAvLyBjb250aW51ZSB0byB0aGUgbmV4dCBtYXBwaW5nLlxuICAgICAgY29uc3QgaWRMaXN0ID0gaGFzaFRvQmxhbmtOb2Rlcy5nZXQoaGFzaCk7XG4gICAgICBpZihpZExpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICBub25VbmlxdWUucHVzaChpZExpc3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gNS40LjIpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgY2Fub25pY2FsXG4gICAgICAvLyBpc3N1ZXIgYW5kIHRoZSBzaW5nbGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIGluIGlkZW50aWZpZXJcbiAgICAgIC8vIGxpc3QsIGlkZW50aWZpZXIsIHRvIGlzc3VlIGEgY2Fub25pY2FsIHJlcGxhY2VtZW50IGlkZW50aWZpZXJcbiAgICAgIC8vIGZvciBpZGVudGlmaWVyLlxuICAgICAgY29uc3QgaWQgPSBpZExpc3RbMF07XG4gICAgICB0aGlzLmNhbm9uaWNhbElzc3Vlci5nZXRJZChpZCk7XG5cbiAgICAgIC8vIE5vdGU6IFRoZXNlIHN0ZXBzIGFyZSBza2lwcGVkLCBvcHRpbWl6ZWQgYXdheSBzaW5jZSB0aGUgbG9vcFxuICAgICAgLy8gb25seSBuZWVkcyB0byBiZSBydW4gb25jZS5cbiAgICAgIC8vIDUuNC4zKSBSZW1vdmUgaWRlbnRpZmllciBmcm9tIG5vbi1ub3JtYWxpemVkIGlkZW50aWZpZXJzLlxuICAgICAgLy8gNS40LjQpIFJlbW92ZSBoYXNoIGZyb20gdGhlIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLlxuICAgICAgLy8gNS40LjUpIFNldCBzaW1wbGUgdG8gdHJ1ZS5cbiAgICB9XG5cbiAgICBpZih0aGlzLm1heERlZXBJdGVyYXRpb25zIDwgMCkge1xuICAgICAgLy8gY2FsY3VsYXRlIG1heERlZXBJdGVyYXRpb25zIGlmIG5vdCBleHBsaWNpdFxuICAgICAgaWYodGhpcy5tYXhXb3JrRmFjdG9yID09PSAwKSB7XG4gICAgICAgIHRoaXMubWF4RGVlcEl0ZXJhdGlvbnMgPSAwO1xuICAgICAgfSBlbHNlIGlmKHRoaXMubWF4V29ya0ZhY3RvciA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5tYXhEZWVwSXRlcmF0aW9ucyA9IEluZmluaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9uVW5pcXVlQ291bnQgPVxuICAgICAgICAgIG5vblVuaXF1ZS5yZWR1Y2UoKGNvdW50LCB2KSA9PiBjb3VudCArIHYubGVuZ3RoLCAwKTtcbiAgICAgICAgdGhpcy5tYXhEZWVwSXRlcmF0aW9ucyA9IG5vblVuaXF1ZUNvdW50ICoqIHRoaXMubWF4V29ya0ZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaGFuZGxlIGFueSBsYXJnZSBpbnB1dHMgYXMgSW5maW5pdHlcbiAgICBpZih0aGlzLm1heERlZXBJdGVyYXRpb25zID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRoaXMubWF4RGVlcEl0ZXJhdGlvbnMgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgdGhpcy5yZW1haW5pbmdEZWVwSXRlcmF0aW9ucyA9IHRoaXMubWF4RGVlcEl0ZXJhdGlvbnM7XG5cbiAgICAvLyA2KSBGb3IgZWFjaCBoYXNoIHRvIGlkZW50aWZpZXIgbGlzdCBtYXBwaW5nIGluIGhhc2ggdG8gYmxhbmsgbm9kZXMgbWFwLFxuICAgIC8vIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSBoYXNoOlxuICAgIC8vIE5vdGU6IHNvcnQgb3B0aW1pemVkIGF3YXksIHVzZSBgbm9uVW5pcXVlYC5cbiAgICBmb3IoY29uc3QgaWRMaXN0IG9mIG5vblVuaXF1ZSkge1xuICAgICAgLy8gNi4xKSBDcmVhdGUgaGFzaCBwYXRoIGxpc3Qgd2hlcmUgZWFjaCBpdGVtIHdpbGwgYmUgYSByZXN1bHQgb2ZcbiAgICAgIC8vIHJ1bm5pbmcgdGhlIEhhc2ggTi1EZWdyZWUgUXVhZHMgYWxnb3JpdGhtLlxuICAgICAgY29uc3QgaGFzaFBhdGhMaXN0ID0gW107XG5cbiAgICAgIC8vIDYuMikgRm9yIGVhY2ggYmxhbmsgbm9kZSBpZGVudGlmaWVyIGlkZW50aWZpZXIgaW4gaWRlbnRpZmllciBsaXN0OlxuICAgICAgZm9yKGNvbnN0IGlkIG9mIGlkTGlzdCkge1xuICAgICAgICAvLyA2LjIuMSkgSWYgYSBjYW5vbmljYWwgaWRlbnRpZmllciBoYXMgYWxyZWFkeSBiZWVuIGlzc3VlZCBmb3JcbiAgICAgICAgLy8gaWRlbnRpZmllciwgY29udGludWUgdG8gdGhlIG5leHQgaWRlbnRpZmllci5cbiAgICAgICAgaWYodGhpcy5jYW5vbmljYWxJc3N1ZXIuaGFzSWQoaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LjIuMikgQ3JlYXRlIHRlbXBvcmFyeSBpc3N1ZXIsIGFuIGlkZW50aWZpZXIgaXNzdWVyXG4gICAgICAgIC8vIGluaXRpYWxpemVkIHdpdGggdGhlIHByZWZpeCBfOmIuXG4gICAgICAgIGNvbnN0IGlzc3VlciA9IG5ldyBJZGVudGlmaWVySXNzdWVyKCdiJyk7XG5cbiAgICAgICAgLy8gNi4yLjMpIFVzZSB0aGUgSXNzdWUgSWRlbnRpZmllciBhbGdvcml0aG0sIHBhc3NpbmcgdGVtcG9yYXJ5XG4gICAgICAgIC8vIGlzc3VlciBhbmQgaWRlbnRpZmllciwgdG8gaXNzdWUgYSBuZXcgdGVtcG9yYXJ5IGJsYW5rIG5vZGVcbiAgICAgICAgLy8gaWRlbnRpZmllciBmb3IgaWRlbnRpZmllci5cbiAgICAgICAgaXNzdWVyLmdldElkKGlkKTtcblxuICAgICAgICAvLyA2LjIuNCkgUnVuIHRoZSBIYXNoIE4tRGVncmVlIFF1YWRzIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAvLyB0ZW1wb3JhcnkgaXNzdWVyLCBhbmQgYXBwZW5kIHRoZSByZXN1bHQgdG8gdGhlIGhhc2ggcGF0aCBsaXN0LlxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhhc2hORGVncmVlUXVhZHMoaWQsIGlzc3Vlcik7XG4gICAgICAgIGhhc2hQYXRoTGlzdC5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIDYuMykgRm9yIGVhY2ggcmVzdWx0IGluIHRoZSBoYXNoIHBhdGggbGlzdCxcbiAgICAgIC8vIGxleGljb2dyYXBoaWNhbGx5LXNvcnRlZCBieSB0aGUgaGFzaCBpbiByZXN1bHQ6XG4gICAgICBoYXNoUGF0aExpc3Quc29ydChfc3RyaW5nSGFzaENvbXBhcmUpO1xuICAgICAgZm9yKGNvbnN0IHJlc3VsdCBvZiBoYXNoUGF0aExpc3QpIHtcbiAgICAgICAgLy8gNi4zLjEpIEZvciBlYWNoIGJsYW5rIG5vZGUgaWRlbnRpZmllciwgZXhpc3RpbmcgaWRlbnRpZmllcixcbiAgICAgICAgLy8gdGhhdCB3YXMgaXNzdWVkIGEgdGVtcG9yYXJ5IGlkZW50aWZpZXIgYnkgaWRlbnRpZmllciBpc3N1ZXJcbiAgICAgICAgLy8gaW4gcmVzdWx0LCBpc3N1ZSBhIGNhbm9uaWNhbCBpZGVudGlmaWVyLCBpbiB0aGUgc2FtZSBvcmRlcixcbiAgICAgICAgLy8gdXNpbmcgdGhlIElzc3VlIElkZW50aWZpZXIgYWxnb3JpdGhtLCBwYXNzaW5nIGNhbm9uaWNhbFxuICAgICAgICAvLyBpc3N1ZXIgYW5kIGV4aXN0aW5nIGlkZW50aWZpZXIuXG4gICAgICAgIGNvbnN0IG9sZElkcyA9IHJlc3VsdC5pc3N1ZXIuZ2V0T2xkSWRzKCk7XG4gICAgICAgIGZvcihjb25zdCBpZCBvZiBvbGRJZHMpIHtcbiAgICAgICAgICB0aGlzLmNhbm9uaWNhbElzc3Vlci5nZXRJZChpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBOb3RlOiBBdCB0aGlzIHBvaW50IGFsbCBibGFuayBub2RlcyBpbiB0aGUgc2V0IG9mIFJERiBxdWFkcyBoYXZlIGJlZW5cbiAgICBhc3NpZ25lZCBjYW5vbmljYWwgaWRlbnRpZmllcnMsIHdoaWNoIGhhdmUgYmVlbiBzdG9yZWQgaW4gdGhlIGNhbm9uaWNhbFxuICAgIGlzc3Vlci4gSGVyZSBlYWNoIHF1YWQgaXMgdXBkYXRlZCBieSBhc3NpZ25pbmcgZWFjaCBvZiBpdHMgYmxhbmsgbm9kZXNcbiAgICBpdHMgbmV3IGlkZW50aWZpZXIuICovXG5cbiAgICAvLyA3KSBGb3IgZWFjaCBxdWFkLCBxdWFkLCBpbiBpbnB1dCBkYXRhc2V0OlxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICBmb3IoY29uc3QgcXVhZCBvZiB0aGlzLnF1YWRzKSB7XG4gICAgICAvLyA3LjEpIENyZWF0ZSBhIGNvcHksIHF1YWQgY29weSwgb2YgcXVhZCBhbmQgcmVwbGFjZSBhbnkgZXhpc3RpbmdcbiAgICAgIC8vIGJsYW5rIG5vZGUgaWRlbnRpZmllcnMgdXNpbmcgdGhlIGNhbm9uaWNhbCBpZGVudGlmaWVyc1xuICAgICAgLy8gcHJldmlvdXNseSBpc3N1ZWQgYnkgY2Fub25pY2FsIGlzc3Vlci5cbiAgICAgIC8vIE5vdGU6IFdlIG9wdGltaXplIGF3YXkgdGhlIGNvcHkgaGVyZS5cbiAgICAgIGNvbnN0IG5RdWFkID0gTlF1YWRzLnNlcmlhbGl6ZVF1YWRDb21wb25lbnRzKFxuICAgICAgICB0aGlzLl9jb21wb25lbnRXaXRoQ2Fub25pY2FsSWQocXVhZC5zdWJqZWN0KSxcbiAgICAgICAgcXVhZC5wcmVkaWNhdGUsXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFdpdGhDYW5vbmljYWxJZChxdWFkLm9iamVjdCksXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFdpdGhDYW5vbmljYWxJZChxdWFkLmdyYXBoKVxuICAgICAgKTtcbiAgICAgIC8vIDcuMikgQWRkIHF1YWQgY29weSB0byB0aGUgbm9ybWFsaXplZCBkYXRhc2V0LlxuICAgICAgbm9ybWFsaXplZC5wdXNoKG5RdWFkKTtcbiAgICB9XG5cbiAgICAvLyBzb3J0IG5vcm1hbGl6ZWQgb3V0cHV0XG4gICAgbm9ybWFsaXplZC5zb3J0KCk7XG5cbiAgICAvLyA4KSBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgZGF0YXNldC5cbiAgICByZXR1cm4gbm9ybWFsaXplZC5qb2luKCcnKTtcbiAgfVxuXG4gIC8vIDQuNikgSGFzaCBGaXJzdCBEZWdyZWUgUXVhZHNcbiAgaGFzaEZpcnN0RGVncmVlUXVhZHMoaWQpIHtcbiAgICAvLyAxKSBJbml0aWFsaXplIG5xdWFkcyB0byBhbiBlbXB0eSBsaXN0LiBJdCB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgcXVhZHMgaW5cbiAgICAvLyBOLVF1YWRzIGZvcm1hdC5cbiAgICBjb25zdCBucXVhZHMgPSBbXTtcblxuICAgIC8vIDIpIEdldCB0aGUgbGlzdCBvZiBxdWFkcyBgcXVhZHNgIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVmZXJlbmNlIGJsYW5rIG5vZGVcbiAgICAvLyBpZGVudGlmaWVyIGluIHRoZSBibGFuayBub2RlIHRvIHF1YWRzIG1hcC5cbiAgICBjb25zdCBpbmZvID0gdGhpcy5ibGFua05vZGVJbmZvLmdldChpZCk7XG4gICAgY29uc3QgcXVhZHMgPSBpbmZvLnF1YWRzO1xuXG4gICAgLy8gMykgRm9yIGVhY2ggcXVhZCBgcXVhZGAgaW4gYHF1YWRzYDpcbiAgICBmb3IoY29uc3QgcXVhZCBvZiBxdWFkcykge1xuICAgICAgLy8gMy4xKSBTZXJpYWxpemUgdGhlIHF1YWQgaW4gTi1RdWFkcyBmb3JtYXQgd2l0aCB0aGUgZm9sbG93aW5nIHNwZWNpYWxcbiAgICAgIC8vIHJ1bGU6XG5cbiAgICAgIC8vIDMuMS4xKSBJZiBhbnkgY29tcG9uZW50IGluIHF1YWQgaXMgYW4gYmxhbmsgbm9kZSwgdGhlbiBzZXJpYWxpemUgaXRcbiAgICAgIC8vIHVzaW5nIGEgc3BlY2lhbCBpZGVudGlmaWVyIGFzIGZvbGxvd3M6XG4gICAgICAvLyAzLjEuMikgSWYgdGhlIGJsYW5rIG5vZGUncyBleGlzdGluZyBibGFuayBub2RlIGlkZW50aWZpZXIgbWF0Y2hlc1xuICAgICAgLy8gdGhlIHJlZmVyZW5jZSBibGFuayBub2RlIGlkZW50aWZpZXIgdGhlbiB1c2UgdGhlIGJsYW5rIG5vZGVcbiAgICAgIC8vIGlkZW50aWZpZXIgXzphLCBvdGhlcndpc2UsIHVzZSB0aGUgYmxhbmsgbm9kZSBpZGVudGlmaWVyIF86ei5cbiAgICAgIG5xdWFkcy5wdXNoKE5RdWFkcy5zZXJpYWxpemVRdWFkQ29tcG9uZW50cyhcbiAgICAgICAgdGhpcy5tb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgcXVhZC5zdWJqZWN0LCAnc3ViamVjdCcpLFxuICAgICAgICBxdWFkLnByZWRpY2F0ZSxcbiAgICAgICAgdGhpcy5tb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgcXVhZC5vYmplY3QsICdvYmplY3QnKSxcbiAgICAgICAgdGhpcy5tb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgcXVhZC5ncmFwaCwgJ2dyYXBoJylcbiAgICAgICkpO1xuICAgIH1cblxuICAgIC8vIDQpIFNvcnQgbnF1YWRzIGluIGxleGljb2dyYXBoaWNhbCBvcmRlci5cbiAgICBucXVhZHMuc29ydCgpO1xuXG4gICAgLy8gNSkgUmV0dXJuIHRoZSBoYXNoIHRoYXQgcmVzdWx0cyBmcm9tIHBhc3NpbmcgdGhlIHNvcnRlZCwgam9pbmVkIG5xdWFkc1xuICAgIC8vIHRocm91Z2ggdGhlIGhhc2ggYWxnb3JpdGhtLlxuICAgIGNvbnN0IG1kID0gdGhpcy5jcmVhdGVNZXNzYWdlRGlnZXN0KCk7XG4gICAgZm9yKGNvbnN0IG5xdWFkIG9mIG5xdWFkcykge1xuICAgICAgbWQudXBkYXRlKG5xdWFkKTtcbiAgICB9XG4gICAgaW5mby5oYXNoID0gbWQuZGlnZXN0KCk7XG4gICAgcmV0dXJuIGluZm8uaGFzaDtcbiAgfVxuXG4gIC8vIDQuNykgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGVcbiAgaGFzaFJlbGF0ZWRCbGFua05vZGUocmVsYXRlZCwgcXVhZCwgaXNzdWVyLCBwb3NpdGlvbikge1xuICAgIC8vIDEpIEluaXRpYWxpemUgYSBzdHJpbmcgaW5wdXQgdG8gdGhlIHZhbHVlIG9mIHBvc2l0aW9uLlxuICAgIC8vIE5vdGU6IFdlIHVzZSBhIGhhc2ggb2JqZWN0IGluc3RlYWQuXG4gICAgY29uc3QgbWQgPSB0aGlzLmNyZWF0ZU1lc3NhZ2VEaWdlc3QoKTtcbiAgICBtZC51cGRhdGUocG9zaXRpb24pO1xuXG4gICAgLy8gMikgSWYgcG9zaXRpb24gaXMgbm90IGcsIGFwcGVuZCA8LCB0aGUgdmFsdWUgb2YgdGhlIHByZWRpY2F0ZSBpbiBxdWFkLFxuICAgIC8vIGFuZCA+IHRvIGlucHV0LlxuICAgIGlmKHBvc2l0aW9uICE9PSAnZycpIHtcbiAgICAgIG1kLnVwZGF0ZSh0aGlzLmdldFJlbGF0ZWRQcmVkaWNhdGUocXVhZCkpO1xuICAgIH1cblxuICAgIC8vIDMpIFNldCB0aGUgaWRlbnRpZmllciB0byB1c2UgZm9yIHJlbGF0ZWQsIHByZWZlcnJpbmcgZmlyc3QgdGhlIGNhbm9uaWNhbFxuICAgIC8vIGlkZW50aWZpZXIgZm9yIHJlbGF0ZWQgaWYgaXNzdWVkLCBzZWNvbmQgdGhlIGlkZW50aWZpZXIgaXNzdWVkIGJ5IGlzc3VlclxuICAgIC8vIGlmIGlzc3VlZCwgYW5kIGxhc3QsIGlmIG5lY2Vzc2FyeSwgdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBGaXJzdCBEZWdyZWVcbiAgICAvLyBRdWFkcyBhbGdvcml0aG0sIHBhc3NpbmcgcmVsYXRlZC5cbiAgICBsZXQgaWQ7XG4gICAgaWYodGhpcy5jYW5vbmljYWxJc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgIGlkID0gJ186JyArIHRoaXMuY2Fub25pY2FsSXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgIH0gZWxzZSBpZihpc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgIGlkID0gJ186JyArIGlzc3Vlci5nZXRJZChyZWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSB0aGlzLmJsYW5rTm9kZUluZm8uZ2V0KHJlbGF0ZWQpLmhhc2g7XG4gICAgfVxuXG4gICAgLy8gNCkgQXBwZW5kIGlkZW50aWZpZXIgdG8gaW5wdXQuXG4gICAgbWQudXBkYXRlKGlkKTtcblxuICAgIC8vIDUpIFJldHVybiB0aGUgaGFzaCB0aGF0IHJlc3VsdHMgZnJvbSBwYXNzaW5nIGlucHV0IHRocm91Z2ggdGhlIGhhc2hcbiAgICAvLyBhbGdvcml0aG0uXG4gICAgcmV0dXJuIG1kLmRpZ2VzdCgpO1xuICB9XG5cbiAgLy8gNC44KSBIYXNoIE4tRGVncmVlIFF1YWRzXG4gIGhhc2hORGVncmVlUXVhZHMoaWQsIGlzc3Vlcikge1xuICAgIGlmKHRoaXMucmVtYWluaW5nRGVlcEl0ZXJhdGlvbnMgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE1heGltdW0gZGVlcCBpdGVyYXRpb25zIGV4Y2VlZGVkICgke3RoaXMubWF4RGVlcEl0ZXJhdGlvbnN9KS5gKTtcbiAgICB9XG4gICAgdGhpcy5yZW1haW5pbmdEZWVwSXRlcmF0aW9ucy0tO1xuXG4gICAgLy8gMSkgQ3JlYXRlIGEgaGFzaCB0byByZWxhdGVkIGJsYW5rIG5vZGVzIG1hcCBmb3Igc3RvcmluZyBoYXNoZXMgdGhhdFxuICAgIC8vIGlkZW50aWZ5IHJlbGF0ZWQgYmxhbmsgbm9kZXMuXG4gICAgLy8gTm90ZTogMikgYW5kIDMpIGhhbmRsZWQgd2l0aGluIGBjcmVhdGVIYXNoVG9SZWxhdGVkYFxuICAgIGNvbnN0IG1kID0gdGhpcy5jcmVhdGVNZXNzYWdlRGlnZXN0KCk7XG4gICAgY29uc3QgaGFzaFRvUmVsYXRlZCA9IHRoaXMuY3JlYXRlSGFzaFRvUmVsYXRlZChpZCwgaXNzdWVyKTtcblxuICAgIC8vIDQpIENyZWF0ZSBhbiBlbXB0eSBzdHJpbmcsIGRhdGEgdG8gaGFzaC5cbiAgICAvLyBOb3RlOiBXZSBjcmVhdGVkIGEgaGFzaCBvYmplY3QgYG1kYCBhYm92ZSBpbnN0ZWFkLlxuXG4gICAgLy8gNSkgRm9yIGVhY2ggcmVsYXRlZCBoYXNoIHRvIGJsYW5rIG5vZGUgbGlzdCBtYXBwaW5nIGluIGhhc2ggdG8gcmVsYXRlZFxuICAgIC8vIGJsYW5rIG5vZGVzIG1hcCwgc29ydGVkIGxleGljb2dyYXBoaWNhbGx5IGJ5IHJlbGF0ZWQgaGFzaDpcbiAgICBjb25zdCBoYXNoZXMgPSBbLi4uaGFzaFRvUmVsYXRlZC5rZXlzKCldLnNvcnQoKTtcbiAgICBmb3IoY29uc3QgaGFzaCBvZiBoYXNoZXMpIHtcbiAgICAgIC8vIDUuMSkgQXBwZW5kIHRoZSByZWxhdGVkIGhhc2ggdG8gdGhlIGRhdGEgdG8gaGFzaC5cbiAgICAgIG1kLnVwZGF0ZShoYXNoKTtcblxuICAgICAgLy8gNS4yKSBDcmVhdGUgYSBzdHJpbmcgY2hvc2VuIHBhdGguXG4gICAgICBsZXQgY2hvc2VuUGF0aCA9ICcnO1xuXG4gICAgICAvLyA1LjMpIENyZWF0ZSBhbiB1bnNldCBjaG9zZW4gaXNzdWVyIHZhcmlhYmxlLlxuICAgICAgbGV0IGNob3Nlbklzc3VlcjtcblxuICAgICAgLy8gNS40KSBGb3IgZWFjaCBwZXJtdXRhdGlvbiBvZiBibGFuayBub2RlIGxpc3Q6XG4gICAgICBjb25zdCBwZXJtdXRlciA9IG5ldyBQZXJtdXRlcihoYXNoVG9SZWxhdGVkLmdldChoYXNoKSk7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZShwZXJtdXRlci5oYXNOZXh0KCkpIHtcbiAgICAgICAgY29uc3QgcGVybXV0YXRpb24gPSBwZXJtdXRlci5uZXh0KCk7XG4gICAgICAgIC8vIE5vdGU6IGJhdGNoIHBlcm11dGF0aW9ucyAzIGF0IGEgdGltZVxuICAgICAgICBpZigrK2kgJSAzID09PSAwKSB7XG4gICAgICAgICAgaWYodGhpcy50aW1lb3V0ID4gMCAmJiBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUgPiB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fub25pemUgdGltZW91dC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LjQuMSkgQ3JlYXRlIGEgY29weSBvZiBpc3N1ZXIsIGlzc3VlciBjb3B5LlxuICAgICAgICBsZXQgaXNzdWVyQ29weSA9IGlzc3Vlci5jbG9uZSgpO1xuXG4gICAgICAgIC8vIDUuNC4yKSBDcmVhdGUgYSBzdHJpbmcgcGF0aC5cbiAgICAgICAgbGV0IHBhdGggPSAnJztcblxuICAgICAgICAvLyA1LjQuMykgQ3JlYXRlIGEgcmVjdXJzaW9uIGxpc3QsIHRvIHN0b3JlIGJsYW5rIG5vZGUgaWRlbnRpZmllcnNcbiAgICAgICAgLy8gdGhhdCBtdXN0IGJlIHJlY3Vyc2l2ZWx5IHByb2Nlc3NlZCBieSB0aGlzIGFsZ29yaXRobS5cbiAgICAgICAgY29uc3QgcmVjdXJzaW9uTGlzdCA9IFtdO1xuXG4gICAgICAgIC8vIDUuNC40KSBGb3IgZWFjaCByZWxhdGVkIGluIHBlcm11dGF0aW9uOlxuICAgICAgICBsZXQgbmV4dFBlcm11dGF0aW9uID0gZmFsc2U7XG4gICAgICAgIGZvcihjb25zdCByZWxhdGVkIG9mIHBlcm11dGF0aW9uKSB7XG4gICAgICAgICAgLy8gNS40LjQuMSkgSWYgYSBjYW5vbmljYWwgaWRlbnRpZmllciBoYXMgYmVlbiBpc3N1ZWQgZm9yXG4gICAgICAgICAgLy8gcmVsYXRlZCwgYXBwZW5kIGl0IHRvIHBhdGguXG4gICAgICAgICAgaWYodGhpcy5jYW5vbmljYWxJc3N1ZXIuaGFzSWQocmVsYXRlZCkpIHtcbiAgICAgICAgICAgIHBhdGggKz0gJ186JyArIHRoaXMuY2Fub25pY2FsSXNzdWVyLmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyA1LjQuNC4yKSBPdGhlcndpc2U6XG4gICAgICAgICAgICAvLyA1LjQuNC4yLjEpIElmIGlzc3VlciBjb3B5IGhhcyBub3QgaXNzdWVkIGFuIGlkZW50aWZpZXIgZm9yXG4gICAgICAgICAgICAvLyByZWxhdGVkLCBhcHBlbmQgcmVsYXRlZCB0byByZWN1cnNpb24gbGlzdC5cbiAgICAgICAgICAgIGlmKCFpc3N1ZXJDb3B5Lmhhc0lkKHJlbGF0ZWQpKSB7XG4gICAgICAgICAgICAgIHJlY3Vyc2lvbkxpc3QucHVzaChyZWxhdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDUuNC40LjIuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZ1xuICAgICAgICAgICAgLy8gaXNzdWVyIGNvcHkgYW5kIHJlbGF0ZWQgYW5kIGFwcGVuZCB0aGUgcmVzdWx0IHRvIHBhdGguXG4gICAgICAgICAgICBwYXRoICs9ICdfOicgKyBpc3N1ZXJDb3B5LmdldElkKHJlbGF0ZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDUuNC40LjMpIElmIGNob3NlbiBwYXRoIGlzIG5vdCBlbXB0eSBhbmQgdGhlIGxlbmd0aCBvZiBwYXRoXG4gICAgICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgY2hvc2VuIHBhdGggYW5kXG4gICAgICAgICAgLy8gcGF0aCBpcyBsZXhpY29ncmFwaGljYWxseSBncmVhdGVyIHRoYW4gY2hvc2VuIHBhdGgsIHRoZW5cbiAgICAgICAgICAvLyBza2lwIHRvIHRoZSBuZXh0IHBlcm11dGF0aW9uLlxuICAgICAgICAgIC8vIE5vdGU6IENvbXBhcmluZyBwYXRoIGxlbmd0aCB0byBjaG9zZW4gcGF0aCBsZW5ndGggY2FuIGJlIG9wdGltaXplZFxuICAgICAgICAgIC8vIGF3YXk7IG9ubHkgY29tcGFyZSBsZXhpY29ncmFwaGljYWxseS5cbiAgICAgICAgICBpZihjaG9zZW5QYXRoLmxlbmd0aCAhPT0gMCAmJiBwYXRoID4gY2hvc2VuUGF0aCkge1xuICAgICAgICAgICAgbmV4dFBlcm11dGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5leHRQZXJtdXRhdGlvbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS40LjUpIEZvciBlYWNoIHJlbGF0ZWQgaW4gcmVjdXJzaW9uIGxpc3Q6XG4gICAgICAgIGZvcihjb25zdCByZWxhdGVkIG9mIHJlY3Vyc2lvbkxpc3QpIHtcbiAgICAgICAgICAvLyA1LjQuNS4xKSBTZXQgcmVzdWx0IHRvIHRoZSByZXN1bHQgb2YgcmVjdXJzaXZlbHkgZXhlY3V0aW5nXG4gICAgICAgICAgLy8gdGhlIEhhc2ggTi1EZWdyZWUgUXVhZHMgYWxnb3JpdGhtLCBwYXNzaW5nIHJlbGF0ZWQgZm9yXG4gICAgICAgICAgLy8gaWRlbnRpZmllciBhbmQgaXNzdWVyIGNvcHkgZm9yIHBhdGggaWRlbnRpZmllciBpc3N1ZXIuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oYXNoTkRlZ3JlZVF1YWRzKHJlbGF0ZWQsIGlzc3VlckNvcHkpO1xuXG4gICAgICAgICAgLy8gNS40LjUuMikgVXNlIHRoZSBJc3N1ZSBJZGVudGlmaWVyIGFsZ29yaXRobSwgcGFzc2luZyBpc3N1ZXJcbiAgICAgICAgICAvLyBjb3B5IGFuZCByZWxhdGVkIGFuZCBhcHBlbmQgdGhlIHJlc3VsdCB0byBwYXRoLlxuICAgICAgICAgIHBhdGggKz0gJ186JyArIGlzc3VlckNvcHkuZ2V0SWQocmVsYXRlZCk7XG5cbiAgICAgICAgICAvLyA1LjQuNS4zKSBBcHBlbmQgPCwgdGhlIGhhc2ggaW4gcmVzdWx0LCBhbmQgPiB0byBwYXRoLlxuICAgICAgICAgIHBhdGggKz0gYDwke3Jlc3VsdC5oYXNofT5gO1xuXG4gICAgICAgICAgLy8gNS40LjUuNCkgU2V0IGlzc3VlciBjb3B5IHRvIHRoZSBpZGVudGlmaWVyIGlzc3VlciBpblxuICAgICAgICAgIC8vIHJlc3VsdC5cbiAgICAgICAgICBpc3N1ZXJDb3B5ID0gcmVzdWx0Lmlzc3VlcjtcblxuICAgICAgICAgIC8vIDUuNC41LjUpIElmIGNob3NlbiBwYXRoIGlzIG5vdCBlbXB0eSBhbmQgdGhlIGxlbmd0aCBvZiBwYXRoXG4gICAgICAgICAgLy8gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgY2hvc2VuIHBhdGggYW5kXG4gICAgICAgICAgLy8gcGF0aCBpcyBsZXhpY29ncmFwaGljYWxseSBncmVhdGVyIHRoYW4gY2hvc2VuIHBhdGgsIHRoZW5cbiAgICAgICAgICAvLyBza2lwIHRvIHRoZSBuZXh0IHBlcm11dGF0aW9uLlxuICAgICAgICAgIC8vIE5vdGU6IENvbXBhcmluZyBwYXRoIGxlbmd0aCB0byBjaG9zZW4gcGF0aCBsZW5ndGggY2FuIGJlIG9wdGltaXplZFxuICAgICAgICAgIC8vIGF3YXk7IG9ubHkgY29tcGFyZSBsZXhpY29ncmFwaGljYWxseS5cbiAgICAgICAgICBpZihjaG9zZW5QYXRoLmxlbmd0aCAhPT0gMCAmJiBwYXRoID4gY2hvc2VuUGF0aCkge1xuICAgICAgICAgICAgbmV4dFBlcm11dGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5leHRQZXJtdXRhdGlvbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS40LjYpIElmIGNob3NlbiBwYXRoIGlzIGVtcHR5IG9yIHBhdGggaXMgbGV4aWNvZ3JhcGhpY2FsbHlcbiAgICAgICAgLy8gbGVzcyB0aGFuIGNob3NlbiBwYXRoLCBzZXQgY2hvc2VuIHBhdGggdG8gcGF0aCBhbmQgY2hvc2VuXG4gICAgICAgIC8vIGlzc3VlciB0byBpc3N1ZXIgY29weS5cbiAgICAgICAgaWYoY2hvc2VuUGF0aC5sZW5ndGggPT09IDAgfHwgcGF0aCA8IGNob3NlblBhdGgpIHtcbiAgICAgICAgICBjaG9zZW5QYXRoID0gcGF0aDtcbiAgICAgICAgICBjaG9zZW5Jc3N1ZXIgPSBpc3N1ZXJDb3B5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDUuNSkgQXBwZW5kIGNob3NlbiBwYXRoIHRvIGRhdGEgdG8gaGFzaC5cbiAgICAgIG1kLnVwZGF0ZShjaG9zZW5QYXRoKTtcblxuICAgICAgLy8gNS42KSBSZXBsYWNlIGlzc3VlciwgYnkgcmVmZXJlbmNlLCB3aXRoIGNob3NlbiBpc3N1ZXIuXG4gICAgICBpc3N1ZXIgPSBjaG9zZW5Jc3N1ZXI7XG4gICAgfVxuXG4gICAgLy8gNikgUmV0dXJuIGlzc3VlciBhbmQgdGhlIGhhc2ggdGhhdCByZXN1bHRzIGZyb20gcGFzc2luZyBkYXRhIHRvIGhhc2hcbiAgICAvLyB0aHJvdWdoIHRoZSBoYXNoIGFsZ29yaXRobS5cbiAgICByZXR1cm4ge2hhc2g6IG1kLmRpZ2VzdCgpLCBpc3N1ZXJ9O1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBtb2RpZnlpbmcgY29tcG9uZW50IGR1cmluZyBIYXNoIEZpcnN0IERlZ3JlZSBRdWFkc1xuICBtb2RpZnlGaXJzdERlZ3JlZUNvbXBvbmVudChpZCwgY29tcG9uZW50KSB7XG4gICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICB9XG4gICAgLyogTm90ZTogQSBtaXN0YWtlIGluIHRoZSBSREZDLTEuMCBzcGVjIHRoYXQgbWFkZSBpdHMgd2F5IGludG9cbiAgICBpbXBsZW1lbnRhdGlvbnMgKGFuZCB0aGVyZWZvcmUgbXVzdCBzdGF5IHRvIGF2b2lkIGludGVyb3AgYnJlYWthZ2UpXG4gICAgcmVzdWx0ZWQgaW4gYW4gYXNzaWduZWQgY2Fub25pY2FsIElELCBpZiBhdmFpbGFibGUgZm9yXG4gICAgYGNvbXBvbmVudC52YWx1ZWAsIG5vdCBiZWluZyB1c2VkIGluIHBsYWNlIG9mIGBfOmFgL2BfOnpgLCBzb1xuICAgIHdlIGRvbid0IHVzZSBpdCBoZXJlLiAqL1xuICAgIHJldHVybiB7XG4gICAgICB0ZXJtVHlwZTogJ0JsYW5rTm9kZScsXG4gICAgICB2YWx1ZTogY29tcG9uZW50LnZhbHVlID09PSBpZCA/ICdhJyA6ICd6J1xuICAgIH07XG4gIH1cblxuICAvLyBoZWxwZXIgZm9yIGdldHRpbmcgYSByZWxhdGVkIHByZWRpY2F0ZVxuICBnZXRSZWxhdGVkUHJlZGljYXRlKHF1YWQpIHtcbiAgICByZXR1cm4gYDwke3F1YWQucHJlZGljYXRlLnZhbHVlfT5gO1xuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjcmVhdGluZyBoYXNoIHRvIHJlbGF0ZWQgYmxhbmsgbm9kZXMgbWFwXG4gIGNyZWF0ZUhhc2hUb1JlbGF0ZWQoaWQsIGlzc3Vlcikge1xuICAgIC8vIDEpIENyZWF0ZSBhIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAgZm9yIHN0b3JpbmcgaGFzaGVzIHRoYXRcbiAgICAvLyBpZGVudGlmeSByZWxhdGVkIGJsYW5rIG5vZGVzLlxuICAgIGNvbnN0IGhhc2hUb1JlbGF0ZWQgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyAyKSBHZXQgYSByZWZlcmVuY2UsIHF1YWRzLCB0byB0aGUgbGlzdCBvZiBxdWFkcyBpbiB0aGUgYmxhbmsgbm9kZSB0b1xuICAgIC8vIHF1YWRzIG1hcCBmb3IgdGhlIGtleSBpZGVudGlmaWVyLlxuICAgIGNvbnN0IHF1YWRzID0gdGhpcy5ibGFua05vZGVJbmZvLmdldChpZCkucXVhZHM7XG5cbiAgICAvLyAzKSBGb3IgZWFjaCBxdWFkIGluIHF1YWRzOlxuICAgIGZvcihjb25zdCBxdWFkIG9mIHF1YWRzKSB7XG4gICAgICAvLyAzLjEpIEZvciBlYWNoIGNvbXBvbmVudCBpbiBxdWFkLCBpZiBjb21wb25lbnQgaXMgdGhlIHN1YmplY3QsIG9iamVjdCxcbiAgICAgIC8vIG9yIGdyYXBoIG5hbWUgYW5kIGl0IGlzIGEgYmxhbmsgbm9kZSB0aGF0IGlzIG5vdCBpZGVudGlmaWVkIGJ5XG4gICAgICAvLyBpZGVudGlmaWVyOlxuICAgICAgLy8gc3RlcHMgMy4xLjEgYW5kIDMuMS4yIG9jY3VyIGluIGhlbHBlcnM6XG4gICAgICB0aGlzLl9hZGRSZWxhdGVkQmxhbmtOb2RlSGFzaCh7XG4gICAgICAgIHF1YWQsIGNvbXBvbmVudDogcXVhZC5zdWJqZWN0LCBwb3NpdGlvbjogJ3MnLFxuICAgICAgICBpZCwgaXNzdWVyLCBoYXNoVG9SZWxhdGVkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2FkZFJlbGF0ZWRCbGFua05vZGVIYXNoKHtcbiAgICAgICAgcXVhZCwgY29tcG9uZW50OiBxdWFkLm9iamVjdCwgcG9zaXRpb246ICdvJyxcbiAgICAgICAgaWQsIGlzc3VlciwgaGFzaFRvUmVsYXRlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9hZGRSZWxhdGVkQmxhbmtOb2RlSGFzaCh7XG4gICAgICAgIHF1YWQsIGNvbXBvbmVudDogcXVhZC5ncmFwaCwgcG9zaXRpb246ICdnJyxcbiAgICAgICAgaWQsIGlzc3VlciwgaGFzaFRvUmVsYXRlZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hUb1JlbGF0ZWQ7XG4gIH1cblxuICBfaGFzaEFuZFRyYWNrQmxhbmtOb2RlKHtpZCwgaGFzaFRvQmxhbmtOb2Rlc30pIHtcbiAgICAvLyA1LjMuMSkgQ3JlYXRlIGEgaGFzaCwgaGFzaCwgYWNjb3JkaW5nIHRvIHRoZSBIYXNoIEZpcnN0IERlZ3JlZVxuICAgIC8vIFF1YWRzIGFsZ29yaXRobS5cbiAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoRmlyc3REZWdyZWVRdWFkcyhpZCk7XG5cbiAgICAvLyA1LjMuMikgQWRkIGhhc2ggYW5kIGlkZW50aWZpZXIgdG8gaGFzaCB0byBibGFuayBub2RlcyBtYXAsXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgZW50cnkgaWYgbmVjZXNzYXJ5LlxuICAgIGNvbnN0IGlkTGlzdCA9IGhhc2hUb0JsYW5rTm9kZXMuZ2V0KGhhc2gpO1xuICAgIGlmKCFpZExpc3QpIHtcbiAgICAgIGhhc2hUb0JsYW5rTm9kZXMuc2V0KGhhc2gsIFtpZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZExpc3QucHVzaChpZCk7XG4gICAgfVxuICB9XG5cbiAgX2FkZEJsYW5rTm9kZVF1YWRJbmZvKHtxdWFkLCBjb21wb25lbnR9KSB7XG4gICAgaWYoY29tcG9uZW50LnRlcm1UeXBlICE9PSAnQmxhbmtOb2RlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGNvbXBvbmVudC52YWx1ZTtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5ibGFua05vZGVJbmZvLmdldChpZCk7XG4gICAgaWYoaW5mbykge1xuICAgICAgaW5mby5xdWFkcy5hZGQocXVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmxhbmtOb2RlSW5mby5zZXQoaWQsIHtxdWFkczogbmV3IFNldChbcXVhZF0pLCBoYXNoOiBudWxsfSk7XG4gICAgfVxuICB9XG5cbiAgX2FkZFJlbGF0ZWRCbGFua05vZGVIYXNoKFxuICAgIHtxdWFkLCBjb21wb25lbnQsIHBvc2l0aW9uLCBpZCwgaXNzdWVyLCBoYXNoVG9SZWxhdGVkfSkge1xuICAgIGlmKCEoY29tcG9uZW50LnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJyAmJiBjb21wb25lbnQudmFsdWUgIT09IGlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyAzLjEuMSkgU2V0IGhhc2ggdG8gdGhlIHJlc3VsdCBvZiB0aGUgSGFzaCBSZWxhdGVkIEJsYW5rIE5vZGVcbiAgICAvLyBhbGdvcml0aG0sIHBhc3NpbmcgdGhlIGJsYW5rIG5vZGUgaWRlbnRpZmllciBmb3IgY29tcG9uZW50IGFzXG4gICAgLy8gcmVsYXRlZCwgcXVhZCwgcGF0aCBpZGVudGlmaWVyIGlzc3VlciBhcyBpc3N1ZXIsIGFuZCBwb3NpdGlvbiBhc1xuICAgIC8vIGVpdGhlciBzLCBvLCBvciBnIGJhc2VkIG9uIHdoZXRoZXIgY29tcG9uZW50IGlzIGEgc3ViamVjdCwgb2JqZWN0LFxuICAgIC8vIGdyYXBoIG5hbWUsIHJlc3BlY3RpdmVseS5cbiAgICBjb25zdCByZWxhdGVkID0gY29tcG9uZW50LnZhbHVlO1xuICAgIGNvbnN0IGhhc2ggPSB0aGlzLmhhc2hSZWxhdGVkQmxhbmtOb2RlKFxuICAgICAgcmVsYXRlZCwgcXVhZCwgaXNzdWVyLCBwb3NpdGlvbik7XG5cbiAgICAvLyAzLjEuMikgQWRkIGEgbWFwcGluZyBvZiBoYXNoIHRvIHRoZSBibGFuayBub2RlIGlkZW50aWZpZXIgZm9yXG4gICAgLy8gY29tcG9uZW50IHRvIGhhc2ggdG8gcmVsYXRlZCBibGFuayBub2RlcyBtYXAsIGFkZGluZyBhbiBlbnRyeSBhc1xuICAgIC8vIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBlbnRyaWVzID0gaGFzaFRvUmVsYXRlZC5nZXQoaGFzaCk7XG4gICAgaWYoZW50cmllcykge1xuICAgICAgZW50cmllcy5wdXNoKHJlbGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNoVG9SZWxhdGVkLnNldChoYXNoLCBbcmVsYXRlZF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbm9uaWNhbCBpZHMgZm9yIDcuMVxuICBfY29tcG9uZW50V2l0aENhbm9uaWNhbElkKGNvbXBvbmVudCkge1xuICAgIGlmKGNvbXBvbmVudC50ZXJtVHlwZSA9PT0gJ0JsYW5rTm9kZScgJiZcbiAgICAgICFjb21wb25lbnQudmFsdWUuc3RhcnRzV2l0aCh0aGlzLmNhbm9uaWNhbElzc3Vlci5wcmVmaXgpKSB7XG4gICAgICAvLyBjcmVhdGUgbmV3IEJsYW5rTm9kZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGVybVR5cGU6ICdCbGFua05vZGUnLFxuICAgICAgICB2YWx1ZTogdGhpcy5jYW5vbmljYWxJc3N1ZXIuZ2V0SWQoY29tcG9uZW50LnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3N0cmluZ0hhc2hDb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGEuaGFzaCA8IGIuaGFzaCA/IC0xIDogYS5oYXNoID4gYi5oYXNoID8gMSA6IDA7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10Sync.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/**\n * An implementation of the RDF Dataset Normalization specification.\n * This library works in the browser and node.js.\n *\n * BSD 3-Clause License\n * Copyright (c) 2016-2023 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nconst RDFC10 = __webpack_require__(/*! ./RDFC10 */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10.js\");\nconst RDFC10Sync = __webpack_require__(/*! ./RDFC10Sync */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/RDFC10Sync.js\");\n\n// optional native support\nlet rdfCanonizeNative;\ntry {\n  rdfCanonizeNative = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'rdf-canonize-native'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch(e) {}\n\n// return a dataset from input dataset or n-quads\nfunction _inputToDataset(input, options) {\n  if(options.inputFormat) {\n    if(options.inputFormat === 'application/n-quads') {\n      if(typeof input !== 'string') {\n        throw new Error('N-Quads input must be a string.');\n      }\n      return exports.NQuads.parse(input);\n    }\n    throw new Error(\n      `Unknown canonicalization input format: \"${options.inputFormat}\".`);\n  }\n  return input;\n}\n\n// check for valid output format\nfunction _checkOutputFormat(options) {\n  // only N-Quads supported\n  if(options.format) {\n    if(options.format !== 'application/n-quads') {\n      throw new Error(\n        `Unknown canonicalization output format: \"${options.format}\".`);\n    }\n  }\n}\n\n// helper to trace URDNA2015 usage\nfunction _traceURDNA2015() {\n  if(!!globalThis.RDF_CANONIZE_TRACE_URDNA2015) {\n    console.trace('[rdf-canonize] URDNA2015 is deprecated, use RDFC-1.0');\n  }\n}\n\n// expose helpers\nexports.NQuads = __webpack_require__(/*! ./NQuads */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js\");\nexports.IdentifierIssuer = __webpack_require__(/*! ./IdentifierIssuer */ \"(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js\");\n\n/**\n * Get or set native API.\n *\n * @param {object} [api] - The native API.\n *\n * @returns {object} - The currently set native API.\n */\nexports._rdfCanonizeNative = function(api) {\n  if(api) {\n    rdfCanonizeNative = api;\n  }\n  return rdfCanonizeNative;\n};\n\n/**\n * Asynchronously canonizes an RDF dataset.\n *\n * @param {Array|object|string} input - The input to canonize given as a\n *   dataset or format specified by 'inputFormat' option.\n * @param {object} options - The options to use:\n *   {string} algorithm - The canonicalization algorithm to use, `RDFC-1.0`.\n *   {Function} [createMessageDigest] - A factory function for creating a\n *     `MessageDigest` interface that overrides the built-in message digest\n *     implementation used by the canonize algorithm; note that using a hash\n *     algorithm (or HMAC algorithm) that differs from the one specified by\n *     the canonize algorithm will result in different output.\n *   {string} [messageDigestAlgorithm=sha256] - Message digest algorithm used\n *     by the default implementation of `createMessageDigest`. Supported\n *     algorithms are: 'sha256', 'sha384', 'sha512', and the 'SHA###' and\n *     'SHA-###' variations.\n *   {Map} [canonicalIdMap] - An optional Map to be populated by the canonical\n *     identifier issuer with the bnode identifier mapping generated by the\n *     canonicalization algorithm.\n *   {string} [inputFormat] - The format of the input. Use\n *     'application/n-quads' for a N-Quads string that will be parsed. Omit or\n *     falsy for a JSON dataset.\n *   {string} [format] - The format of the output. Omit or use\n *     'application/n-quads' for a N-Quads string.\n *   {boolean} [useNative=false] - Use native implementation.\n *   {number} [maxWorkFactor=1] - Control of the maximum number of times to run\n *     deep comparison algorithms (such as the N-Degree Hash Quads algorithm\n *     used in RDFC-1.0) before bailing out and throwing an error; this is a\n *     useful setting for preventing wasted CPU cycles or DoS when canonizing\n *     meaningless or potentially malicious datasets. This parameter sets the\n *     maximum number of iterations based on the number of non-unique blank\n *     nodes. `0` to disable iterations, `1` for a O(n) limit, `2` for a O(n^2)\n *     limit, `3` and higher may handle \"poison\" graphs but may take\n *     significant computational resources, `Infinity` for no limitation.\n *     Defaults to `1` which can handle many common inputs.\n *   {number} [maxDeepIterations=-1] - The maximum number of times to run\n *     deep comparison algorithms (such as the N-Degree Hash Quads algorithm\n *     used in RDFC-1.0) before bailing out and throwing an error; this is a\n *     useful setting for preventing wasted CPU cycles or DoS when canonizing\n *     meaningless or potentially malicious datasets. If set to a value other\n *     than `-1` it will explicitly set the number of iterations and override\n *     `maxWorkFactor`. It is recommended to use `maxWorkFactor`.\n *   {AbortSignal} [signal] - An AbortSignal used to abort the operation. The\n *     aborted status is only periodically checked for performance reasons.\n *   {boolean} [rejectURDNA2015=false] - Reject the \"URDNA2015\" algorithm name\n *     instead of treating it as an alias for \"RDFC-1.0\".\n *\n * @returns {Promise<object>} - A Promise that resolves to the canonicalized\n *   RDF Dataset.\n */\nexports.canonize = async function(input, options = {}) {\n  const dataset = _inputToDataset(input, options);\n  _checkOutputFormat(options);\n\n  if(options.useNative) {\n    if(!rdfCanonizeNative) {\n      throw new Error('rdf-canonize-native not available');\n    }\n    if(options.createMessageDigest) {\n      throw new Error(\n        '\"createMessageDigest\" cannot be used with \"useNative\".');\n    }\n    return new Promise((resolve, reject) =>\n      rdfCanonizeNative.canonize(dataset, options, (err, canonical) =>\n        err ? reject(err) : resolve(canonical)));\n  }\n\n  if(!('algorithm' in options)) {\n    throw new Error('No RDF Dataset Canonicalization algorithm specified.');\n  }\n  if(options.algorithm === 'RDFC-1.0') {\n    return new RDFC10(options).main(dataset);\n  }\n  // URDNA2015 deprecated, handled as alias for RDFC-1.0 if allowed\n  if(options.algorithm === 'URDNA2015' && !options.rejectURDNA2015) {\n    _traceURDNA2015();\n    return new RDFC10(options).main(dataset);\n  }\n  throw new Error(\n    'Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);\n};\n\n/**\n * This method is no longer available in the public API, it is for testing\n * only. It synchronously canonizes an RDF dataset and does not work in the\n * browser.\n *\n * @param {Array|object|string} input - The input to canonize given as a\n *   dataset or format specified by 'inputFormat' option.\n * @param {object} options - The options to use:\n *   {string} algorithm - The canonicalization algorithm to use, `RDFC-1.0`.\n *   {Function} [createMessageDigest] - A factory function for creating a\n *     `MessageDigest` interface that overrides the built-in message digest\n *     implementation used by the canonize algorithm; note that using a hash\n *     algorithm (or HMAC algorithm) that differs from the one specified by\n *     the canonize algorithm will result in different output.\n *   {string} [messageDigestAlgorithm=sha256] - Message digest algorithm used\n *     by the default implementation of `createMessageDigest`. Supported\n *     algorithms are: 'sha256', 'sha384', 'sha512', and the 'SHA###' and\n *     'SHA-###' variations.\n *   {Map} [canonicalIdMap] - An optional Map to be populated by the canonical\n *     identifier issuer with the bnode identifier mapping generated by the\n *     canonicalization algorithm.\n *   {string} [inputFormat] - The format of the input. Use\n *     'application/n-quads' for a N-Quads string that will be parsed. Omit or\n *     falsy for a JSON dataset.\n *   {string} [format] - The format of the output. Omit or use\n *     'application/n-quads' for a N-Quads string.\n *   {boolean} [useNative=false] - Use native implementation.\n *   {number} [maxWorkFactor=1] - Control of the maximum number of times to run\n *     deep comparison algorithms (such as the N-Degree Hash Quads algorithm\n *     used in RDFC-1.0) before bailing out and throwing an error; this is a\n *     useful setting for preventing wasted CPU cycles or DoS when canonizing\n *     meaningless or potentially malicious datasets. This parameter sets the\n *     maximum number of iterations based on the number of non-unique blank\n *     nodes. `0` to disable iterations, `1` for a O(n) limit, `2` for a O(n^2)\n *     limit, `3` and higher may handle \"poison\" graphs but may take\n *     significant computational resources, `Infinity` for no limitation.\n *     Defaults to `1` which can handle many common inputs.\n *   {number} [maxDeepIterations=-1] - The maximum number of times to run\n *     deep comparison algorithms (such as the N-Degree Hash Quads algorithm\n *     used in RDFC-1.0) before bailing out and throwing an error; this is a\n *     useful setting for preventing wasted CPU cycles or DoS when canonizing\n *     meaningless or potentially malicious datasets. If set to a value other\n *     than `-1` it will explicitly set the number of iterations and override\n *     `maxWorkFactor`. It is recommended to use `maxWorkFactor`.\n *   {number} [timeout=1000] - The maximum number of milliseconds before the\n *     operation will timeout. This is only periodically checked for\n *     performance reasons. Use 0 to disable. Note: This is a replacement for\n *     the async canonize `signal` option common timeout use case. If complex\n *     abort logic is required, use the async function and the `signal`\n *     parameter.\n *   {boolean} [rejectURDNA2015=false] - Reject the \"URDNA2015\" algorithm name\n *     instead of treating it as an alias for \"RDFC-1.0\".\n *\n * @returns {Promise<object>} - A Promise that resolves to the canonicalized\n *   RDF Dataset.\n */\nexports._canonizeSync = function(input, options = {}) {\n  const dataset = _inputToDataset(input, options);\n  _checkOutputFormat(options);\n\n  if(options.useNative) {\n    if(!rdfCanonizeNative) {\n      throw new Error('rdf-canonize-native not available');\n    }\n    if(options.createMessageDigest) {\n      throw new Error(\n        '\"createMessageDigest\" cannot be used with \"useNative\".');\n    }\n    return rdfCanonizeNative.canonizeSync(dataset, options);\n  }\n  if(!('algorithm' in options)) {\n    throw new Error('No RDF Dataset Canonicalization algorithm specified.');\n  }\n  if(options.algorithm === 'RDFC-1.0') {\n    return new RDFC10Sync(options).main(dataset);\n  }\n  // URDNA2015 deprecated, handled as alias for RDFC-1.0 if allowed\n  if(options.algorithm === 'URDNA2015' && !options.rejectURDNA2015) {\n    _traceURDNA2015();\n    return new RDFC10Sync(options).main(dataset);\n  }\n  throw new Error(\n    'Invalid RDF Dataset Canonicalization algorithm: ' + options.algorithm);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLGdHQUFVO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHdHQUFjOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxrSkFBcUI7QUFDbkQsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0I7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzSUFBb0M7QUFDcEMsb0tBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBLFdBQVcsUUFBUTtBQUNuQixNQUFNLFFBQVE7QUFDZCxNQUFNLFVBQVU7QUFDaEI7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBSztBQUNYO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0EsTUFBTSxRQUFRO0FBQ2Q7QUFDQSxNQUFNLFNBQVM7QUFDZixNQUFNLFFBQVE7QUFDZDtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CO0FBQ0EsTUFBTSxTQUFTO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLE1BQU0sUUFBUTtBQUNkLE1BQU0sVUFBVTtBQUNoQjtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsTUFBTSxRQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQ1g7QUFDQTtBQUNBLE1BQU0sUUFBUTtBQUNkO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBLE1BQU0sU0FBUztBQUNmLE1BQU0sUUFBUTtBQUNkO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRO0FBQ2Q7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL25vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL2luZGV4LmpzPzE4Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUkRGIERhdGFzZXQgTm9ybWFsaXphdGlvbiBzcGVjaWZpY2F0aW9uLlxuICogVGhpcyBsaWJyYXJ5IHdvcmtzIGluIHRoZSBicm93c2VyIGFuZCBub2RlLmpzLlxuICpcbiAqIEJTRCAzLUNsYXVzZSBMaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyMyBEaWdpdGFsIEJhemFhciwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgRGlnaXRhbCBCYXphYXIsIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4gKiB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBU1xuICogSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBXG4gKiBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRFxuICogVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgUkRGQzEwID0gcmVxdWlyZSgnLi9SREZDMTAnKTtcbmNvbnN0IFJERkMxMFN5bmMgPSByZXF1aXJlKCcuL1JERkMxMFN5bmMnKTtcblxuLy8gb3B0aW9uYWwgbmF0aXZlIHN1cHBvcnRcbmxldCByZGZDYW5vbml6ZU5hdGl2ZTtcbnRyeSB7XG4gIHJkZkNhbm9uaXplTmF0aXZlID0gcmVxdWlyZSgncmRmLWNhbm9uaXplLW5hdGl2ZScpO1xufSBjYXRjaChlKSB7fVxuXG4vLyByZXR1cm4gYSBkYXRhc2V0IGZyb20gaW5wdXQgZGF0YXNldCBvciBuLXF1YWRzXG5mdW5jdGlvbiBfaW5wdXRUb0RhdGFzZXQoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYob3B0aW9ucy5pbnB1dEZvcm1hdCkge1xuICAgIGlmKG9wdGlvbnMuaW5wdXRGb3JtYXQgPT09ICdhcHBsaWNhdGlvbi9uLXF1YWRzJykge1xuICAgICAgaWYodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ04tUXVhZHMgaW5wdXQgbXVzdCBiZSBhIHN0cmluZy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHBvcnRzLk5RdWFkcy5wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmtub3duIGNhbm9uaWNhbGl6YXRpb24gaW5wdXQgZm9ybWF0OiBcIiR7b3B0aW9ucy5pbnB1dEZvcm1hdH1cIi5gKTtcbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59XG5cbi8vIGNoZWNrIGZvciB2YWxpZCBvdXRwdXQgZm9ybWF0XG5mdW5jdGlvbiBfY2hlY2tPdXRwdXRGb3JtYXQob3B0aW9ucykge1xuICAvLyBvbmx5IE4tUXVhZHMgc3VwcG9ydGVkXG4gIGlmKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgaWYob3B0aW9ucy5mb3JtYXQgIT09ICdhcHBsaWNhdGlvbi9uLXF1YWRzJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5rbm93biBjYW5vbmljYWxpemF0aW9uIG91dHB1dCBmb3JtYXQ6IFwiJHtvcHRpb25zLmZvcm1hdH1cIi5gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGVscGVyIHRvIHRyYWNlIFVSRE5BMjAxNSB1c2FnZVxuZnVuY3Rpb24gX3RyYWNlVVJETkEyMDE1KCkge1xuICBpZighIWdsb2JhbFRoaXMuUkRGX0NBTk9OSVpFX1RSQUNFX1VSRE5BMjAxNSkge1xuICAgIGNvbnNvbGUudHJhY2UoJ1tyZGYtY2Fub25pemVdIFVSRE5BMjAxNSBpcyBkZXByZWNhdGVkLCB1c2UgUkRGQy0xLjAnKTtcbiAgfVxufVxuXG4vLyBleHBvc2UgaGVscGVyc1xuZXhwb3J0cy5OUXVhZHMgPSByZXF1aXJlKCcuL05RdWFkcycpO1xuZXhwb3J0cy5JZGVudGlmaWVySXNzdWVyID0gcmVxdWlyZSgnLi9JZGVudGlmaWVySXNzdWVyJyk7XG5cbi8qKlxuICogR2V0IG9yIHNldCBuYXRpdmUgQVBJLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXBpXSAtIFRoZSBuYXRpdmUgQVBJLlxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gVGhlIGN1cnJlbnRseSBzZXQgbmF0aXZlIEFQSS5cbiAqL1xuZXhwb3J0cy5fcmRmQ2Fub25pemVOYXRpdmUgPSBmdW5jdGlvbihhcGkpIHtcbiAgaWYoYXBpKSB7XG4gICAgcmRmQ2Fub25pemVOYXRpdmUgPSBhcGk7XG4gIH1cbiAgcmV0dXJuIHJkZkNhbm9uaXplTmF0aXZlO1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBjYW5vbml6ZXMgYW4gUkRGIGRhdGFzZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheXxvYmplY3R8c3RyaW5nfSBpbnB1dCAtIFRoZSBpbnB1dCB0byBjYW5vbml6ZSBnaXZlbiBhcyBhXG4gKiAgIGRhdGFzZXQgb3IgZm9ybWF0IHNwZWNpZmllZCBieSAnaW5wdXRGb3JtYXQnIG9wdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlOlxuICogICB7c3RyaW5nfSBhbGdvcml0aG0gLSBUaGUgY2Fub25pY2FsaXphdGlvbiBhbGdvcml0aG0gdG8gdXNlLCBgUkRGQy0xLjBgLlxuICogICB7RnVuY3Rpb259IFtjcmVhdGVNZXNzYWdlRGlnZXN0XSAtIEEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYVxuICogICAgIGBNZXNzYWdlRGlnZXN0YCBpbnRlcmZhY2UgdGhhdCBvdmVycmlkZXMgdGhlIGJ1aWx0LWluIG1lc3NhZ2UgZGlnZXN0XG4gKiAgICAgaW1wbGVtZW50YXRpb24gdXNlZCBieSB0aGUgY2Fub25pemUgYWxnb3JpdGhtOyBub3RlIHRoYXQgdXNpbmcgYSBoYXNoXG4gKiAgICAgYWxnb3JpdGhtIChvciBITUFDIGFsZ29yaXRobSkgdGhhdCBkaWZmZXJzIGZyb20gdGhlIG9uZSBzcGVjaWZpZWQgYnlcbiAqICAgICB0aGUgY2Fub25pemUgYWxnb3JpdGhtIHdpbGwgcmVzdWx0IGluIGRpZmZlcmVudCBvdXRwdXQuXG4gKiAgIHtzdHJpbmd9IFttZXNzYWdlRGlnZXN0QWxnb3JpdGhtPXNoYTI1Nl0gLSBNZXNzYWdlIGRpZ2VzdCBhbGdvcml0aG0gdXNlZFxuICogICAgIGJ5IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBjcmVhdGVNZXNzYWdlRGlnZXN0YC4gU3VwcG9ydGVkXG4gKiAgICAgYWxnb3JpdGhtcyBhcmU6ICdzaGEyNTYnLCAnc2hhMzg0JywgJ3NoYTUxMicsIGFuZCB0aGUgJ1NIQSMjIycgYW5kXG4gKiAgICAgJ1NIQS0jIyMnIHZhcmlhdGlvbnMuXG4gKiAgIHtNYXB9IFtjYW5vbmljYWxJZE1hcF0gLSBBbiBvcHRpb25hbCBNYXAgdG8gYmUgcG9wdWxhdGVkIGJ5IHRoZSBjYW5vbmljYWxcbiAqICAgICBpZGVudGlmaWVyIGlzc3VlciB3aXRoIHRoZSBibm9kZSBpZGVudGlmaWVyIG1hcHBpbmcgZ2VuZXJhdGVkIGJ5IHRoZVxuICogICAgIGNhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtLlxuICogICB7c3RyaW5nfSBbaW5wdXRGb3JtYXRdIC0gVGhlIGZvcm1hdCBvZiB0aGUgaW5wdXQuIFVzZVxuICogICAgICdhcHBsaWNhdGlvbi9uLXF1YWRzJyBmb3IgYSBOLVF1YWRzIHN0cmluZyB0aGF0IHdpbGwgYmUgcGFyc2VkLiBPbWl0IG9yXG4gKiAgICAgZmFsc3kgZm9yIGEgSlNPTiBkYXRhc2V0LlxuICogICB7c3RyaW5nfSBbZm9ybWF0XSAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dC4gT21pdCBvciB1c2VcbiAqICAgICAnYXBwbGljYXRpb24vbi1xdWFkcycgZm9yIGEgTi1RdWFkcyBzdHJpbmcuXG4gKiAgIHtib29sZWFufSBbdXNlTmF0aXZlPWZhbHNlXSAtIFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXG4gKiAgIHtudW1iZXJ9IFttYXhXb3JrRmFjdG9yPTFdIC0gQ29udHJvbCBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdG8gcnVuXG4gKiAgICAgZGVlcCBjb21wYXJpc29uIGFsZ29yaXRobXMgKHN1Y2ggYXMgdGhlIE4tRGVncmVlIEhhc2ggUXVhZHMgYWxnb3JpdGhtXG4gKiAgICAgdXNlZCBpbiBSREZDLTEuMCkgYmVmb3JlIGJhaWxpbmcgb3V0IGFuZCB0aHJvd2luZyBhbiBlcnJvcjsgdGhpcyBpcyBhXG4gKiAgICAgdXNlZnVsIHNldHRpbmcgZm9yIHByZXZlbnRpbmcgd2FzdGVkIENQVSBjeWNsZXMgb3IgRG9TIHdoZW4gY2Fub25pemluZ1xuICogICAgIG1lYW5pbmdsZXNzIG9yIHBvdGVudGlhbGx5IG1hbGljaW91cyBkYXRhc2V0cy4gVGhpcyBwYXJhbWV0ZXIgc2V0cyB0aGVcbiAqICAgICBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIGJhc2VkIG9uIHRoZSBudW1iZXIgb2Ygbm9uLXVuaXF1ZSBibGFua1xuICogICAgIG5vZGVzLiBgMGAgdG8gZGlzYWJsZSBpdGVyYXRpb25zLCBgMWAgZm9yIGEgTyhuKSBsaW1pdCwgYDJgIGZvciBhIE8obl4yKVxuICogICAgIGxpbWl0LCBgM2AgYW5kIGhpZ2hlciBtYXkgaGFuZGxlIFwicG9pc29uXCIgZ3JhcGhzIGJ1dCBtYXkgdGFrZVxuICogICAgIHNpZ25pZmljYW50IGNvbXB1dGF0aW9uYWwgcmVzb3VyY2VzLCBgSW5maW5pdHlgIGZvciBubyBsaW1pdGF0aW9uLlxuICogICAgIERlZmF1bHRzIHRvIGAxYCB3aGljaCBjYW4gaGFuZGxlIG1hbnkgY29tbW9uIGlucHV0cy5cbiAqICAge251bWJlcn0gW21heERlZXBJdGVyYXRpb25zPS0xXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0byBydW5cbiAqICAgICBkZWVwIGNvbXBhcmlzb24gYWxnb3JpdGhtcyAoc3VjaCBhcyB0aGUgTi1EZWdyZWUgSGFzaCBRdWFkcyBhbGdvcml0aG1cbiAqICAgICB1c2VkIGluIFJERkMtMS4wKSBiZWZvcmUgYmFpbGluZyBvdXQgYW5kIHRocm93aW5nIGFuIGVycm9yOyB0aGlzIGlzIGFcbiAqICAgICB1c2VmdWwgc2V0dGluZyBmb3IgcHJldmVudGluZyB3YXN0ZWQgQ1BVIGN5Y2xlcyBvciBEb1Mgd2hlbiBjYW5vbml6aW5nXG4gKiAgICAgbWVhbmluZ2xlc3Mgb3IgcG90ZW50aWFsbHkgbWFsaWNpb3VzIGRhdGFzZXRzLiBJZiBzZXQgdG8gYSB2YWx1ZSBvdGhlclxuICogICAgIHRoYW4gYC0xYCBpdCB3aWxsIGV4cGxpY2l0bHkgc2V0IHRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyBhbmQgb3ZlcnJpZGVcbiAqICAgICBgbWF4V29ya0ZhY3RvcmAuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgbWF4V29ya0ZhY3RvcmAuXG4gKiAgIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gLSBBbiBBYm9ydFNpZ25hbCB1c2VkIHRvIGFib3J0IHRoZSBvcGVyYXRpb24uIFRoZVxuICogICAgIGFib3J0ZWQgc3RhdHVzIGlzIG9ubHkgcGVyaW9kaWNhbGx5IGNoZWNrZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiAgIHtib29sZWFufSBbcmVqZWN0VVJETkEyMDE1PWZhbHNlXSAtIFJlamVjdCB0aGUgXCJVUkROQTIwMTVcIiBhbGdvcml0aG0gbmFtZVxuICogICAgIGluc3RlYWQgb2YgdHJlYXRpbmcgaXQgYXMgYW4gYWxpYXMgZm9yIFwiUkRGQy0xLjBcIi5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjYW5vbmljYWxpemVkXG4gKiAgIFJERiBEYXRhc2V0LlxuICovXG5leHBvcnRzLmNhbm9uaXplID0gYXN5bmMgZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBkYXRhc2V0ID0gX2lucHV0VG9EYXRhc2V0KGlucHV0LCBvcHRpb25zKTtcbiAgX2NoZWNrT3V0cHV0Rm9ybWF0KG9wdGlvbnMpO1xuXG4gIGlmKG9wdGlvbnMudXNlTmF0aXZlKSB7XG4gICAgaWYoIXJkZkNhbm9uaXplTmF0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JkZi1jYW5vbml6ZS1uYXRpdmUgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICBpZihvcHRpb25zLmNyZWF0ZU1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiY3JlYXRlTWVzc2FnZURpZ2VzdFwiIGNhbm5vdCBiZSB1c2VkIHdpdGggXCJ1c2VOYXRpdmVcIi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICByZGZDYW5vbml6ZU5hdGl2ZS5jYW5vbml6ZShkYXRhc2V0LCBvcHRpb25zLCAoZXJyLCBjYW5vbmljYWwpID0+XG4gICAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShjYW5vbmljYWwpKSk7XG4gIH1cblxuICBpZighKCdhbGdvcml0aG0nIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBSREYgRGF0YXNldCBDYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobSBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICdSREZDLTEuMCcpIHtcbiAgICByZXR1cm4gbmV3IFJERkMxMChvcHRpb25zKS5tYWluKGRhdGFzZXQpO1xuICB9XG4gIC8vIFVSRE5BMjAxNSBkZXByZWNhdGVkLCBoYW5kbGVkIGFzIGFsaWFzIGZvciBSREZDLTEuMCBpZiBhbGxvd2VkXG4gIGlmKG9wdGlvbnMuYWxnb3JpdGhtID09PSAnVVJETkEyMDE1JyAmJiAhb3B0aW9ucy5yZWplY3RVUkROQTIwMTUpIHtcbiAgICBfdHJhY2VVUkROQTIwMTUoKTtcbiAgICByZXR1cm4gbmV3IFJERkMxMChvcHRpb25zKS5tYWluKGRhdGFzZXQpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAnSW52YWxpZCBSREYgRGF0YXNldCBDYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobTogJyArIG9wdGlvbnMuYWxnb3JpdGhtKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSBpbiB0aGUgcHVibGljIEFQSSwgaXQgaXMgZm9yIHRlc3RpbmdcbiAqIG9ubHkuIEl0IHN5bmNocm9ub3VzbHkgY2Fub25pemVzIGFuIFJERiBkYXRhc2V0IGFuZCBkb2VzIG5vdCB3b3JrIGluIHRoZVxuICogYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fG9iamVjdHxzdHJpbmd9IGlucHV0IC0gVGhlIGlucHV0IHRvIGNhbm9uaXplIGdpdmVuIGFzIGFcbiAqICAgZGF0YXNldCBvciBmb3JtYXQgc3BlY2lmaWVkIGJ5ICdpbnB1dEZvcm1hdCcgb3B0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byB1c2U6XG4gKiAgIHtzdHJpbmd9IGFsZ29yaXRobSAtIFRoZSBjYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobSB0byB1c2UsIGBSREZDLTEuMGAuXG4gKiAgIHtGdW5jdGlvbn0gW2NyZWF0ZU1lc3NhZ2VEaWdlc3RdIC0gQSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhXG4gKiAgICAgYE1lc3NhZ2VEaWdlc3RgIGludGVyZmFjZSB0aGF0IG92ZXJyaWRlcyB0aGUgYnVpbHQtaW4gbWVzc2FnZSBkaWdlc3RcbiAqICAgICBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHRoZSBjYW5vbml6ZSBhbGdvcml0aG07IG5vdGUgdGhhdCB1c2luZyBhIGhhc2hcbiAqICAgICBhbGdvcml0aG0gKG9yIEhNQUMgYWxnb3JpdGhtKSB0aGF0IGRpZmZlcnMgZnJvbSB0aGUgb25lIHNwZWNpZmllZCBieVxuICogICAgIHRoZSBjYW5vbml6ZSBhbGdvcml0aG0gd2lsbCByZXN1bHQgaW4gZGlmZmVyZW50IG91dHB1dC5cbiAqICAge3N0cmluZ30gW21lc3NhZ2VEaWdlc3RBbGdvcml0aG09c2hhMjU2XSAtIE1lc3NhZ2UgZGlnZXN0IGFsZ29yaXRobSB1c2VkXG4gKiAgICAgYnkgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYGNyZWF0ZU1lc3NhZ2VEaWdlc3RgLiBTdXBwb3J0ZWRcbiAqICAgICBhbGdvcml0aG1zIGFyZTogJ3NoYTI1NicsICdzaGEzODQnLCAnc2hhNTEyJywgYW5kIHRoZSAnU0hBIyMjJyBhbmRcbiAqICAgICAnU0hBLSMjIycgdmFyaWF0aW9ucy5cbiAqICAge01hcH0gW2Nhbm9uaWNhbElkTWFwXSAtIEFuIG9wdGlvbmFsIE1hcCB0byBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbm9uaWNhbFxuICogICAgIGlkZW50aWZpZXIgaXNzdWVyIHdpdGggdGhlIGJub2RlIGlkZW50aWZpZXIgbWFwcGluZyBnZW5lcmF0ZWQgYnkgdGhlXG4gKiAgICAgY2Fub25pY2FsaXphdGlvbiBhbGdvcml0aG0uXG4gKiAgIHtzdHJpbmd9IFtpbnB1dEZvcm1hdF0gLSBUaGUgZm9ybWF0IG9mIHRoZSBpbnB1dC4gVXNlXG4gKiAgICAgJ2FwcGxpY2F0aW9uL24tcXVhZHMnIGZvciBhIE4tUXVhZHMgc3RyaW5nIHRoYXQgd2lsbCBiZSBwYXJzZWQuIE9taXQgb3JcbiAqICAgICBmYWxzeSBmb3IgYSBKU09OIGRhdGFzZXQuXG4gKiAgIHtzdHJpbmd9IFtmb3JtYXRdIC0gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0LiBPbWl0IG9yIHVzZVxuICogICAgICdhcHBsaWNhdGlvbi9uLXF1YWRzJyBmb3IgYSBOLVF1YWRzIHN0cmluZy5cbiAqICAge2Jvb2xlYW59IFt1c2VOYXRpdmU9ZmFsc2VdIC0gVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAqICAge251bWJlcn0gW21heFdvcmtGYWN0b3I9MV0gLSBDb250cm9sIG9mIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0byBydW5cbiAqICAgICBkZWVwIGNvbXBhcmlzb24gYWxnb3JpdGhtcyAoc3VjaCBhcyB0aGUgTi1EZWdyZWUgSGFzaCBRdWFkcyBhbGdvcml0aG1cbiAqICAgICB1c2VkIGluIFJERkMtMS4wKSBiZWZvcmUgYmFpbGluZyBvdXQgYW5kIHRocm93aW5nIGFuIGVycm9yOyB0aGlzIGlzIGFcbiAqICAgICB1c2VmdWwgc2V0dGluZyBmb3IgcHJldmVudGluZyB3YXN0ZWQgQ1BVIGN5Y2xlcyBvciBEb1Mgd2hlbiBjYW5vbml6aW5nXG4gKiAgICAgbWVhbmluZ2xlc3Mgb3IgcG90ZW50aWFsbHkgbWFsaWNpb3VzIGRhdGFzZXRzLiBUaGlzIHBhcmFtZXRlciBzZXRzIHRoZVxuICogICAgIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmFzZWQgb24gdGhlIG51bWJlciBvZiBub24tdW5pcXVlIGJsYW5rXG4gKiAgICAgbm9kZXMuIGAwYCB0byBkaXNhYmxlIGl0ZXJhdGlvbnMsIGAxYCBmb3IgYSBPKG4pIGxpbWl0LCBgMmAgZm9yIGEgTyhuXjIpXG4gKiAgICAgbGltaXQsIGAzYCBhbmQgaGlnaGVyIG1heSBoYW5kbGUgXCJwb2lzb25cIiBncmFwaHMgYnV0IG1heSB0YWtlXG4gKiAgICAgc2lnbmlmaWNhbnQgY29tcHV0YXRpb25hbCByZXNvdXJjZXMsIGBJbmZpbml0eWAgZm9yIG5vIGxpbWl0YXRpb24uXG4gKiAgICAgRGVmYXVsdHMgdG8gYDFgIHdoaWNoIGNhbiBoYW5kbGUgbWFueSBjb21tb24gaW5wdXRzLlxuICogICB7bnVtYmVyfSBbbWF4RGVlcEl0ZXJhdGlvbnM9LTFdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHJ1blxuICogICAgIGRlZXAgY29tcGFyaXNvbiBhbGdvcml0aG1zIChzdWNoIGFzIHRoZSBOLURlZ3JlZSBIYXNoIFF1YWRzIGFsZ29yaXRobVxuICogICAgIHVzZWQgaW4gUkRGQy0xLjApIGJlZm9yZSBiYWlsaW5nIG91dCBhbmQgdGhyb3dpbmcgYW4gZXJyb3I7IHRoaXMgaXMgYVxuICogICAgIHVzZWZ1bCBzZXR0aW5nIGZvciBwcmV2ZW50aW5nIHdhc3RlZCBDUFUgY3ljbGVzIG9yIERvUyB3aGVuIGNhbm9uaXppbmdcbiAqICAgICBtZWFuaW5nbGVzcyBvciBwb3RlbnRpYWxseSBtYWxpY2lvdXMgZGF0YXNldHMuIElmIHNldCB0byBhIHZhbHVlIG90aGVyXG4gKiAgICAgdGhhbiBgLTFgIGl0IHdpbGwgZXhwbGljaXRseSBzZXQgdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGFuZCBvdmVycmlkZVxuICogICAgIGBtYXhXb3JrRmFjdG9yYC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGBtYXhXb3JrRmFjdG9yYC5cbiAqICAge251bWJlcn0gW3RpbWVvdXQ9MTAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGVcbiAqICAgICBvcGVyYXRpb24gd2lsbCB0aW1lb3V0LiBUaGlzIGlzIG9ubHkgcGVyaW9kaWNhbGx5IGNoZWNrZWQgZm9yXG4gKiAgICAgcGVyZm9ybWFuY2UgcmVhc29ucy4gVXNlIDAgdG8gZGlzYWJsZS4gTm90ZTogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvclxuICogICAgIHRoZSBhc3luYyBjYW5vbml6ZSBgc2lnbmFsYCBvcHRpb24gY29tbW9uIHRpbWVvdXQgdXNlIGNhc2UuIElmIGNvbXBsZXhcbiAqICAgICBhYm9ydCBsb2dpYyBpcyByZXF1aXJlZCwgdXNlIHRoZSBhc3luYyBmdW5jdGlvbiBhbmQgdGhlIGBzaWduYWxgXG4gKiAgICAgcGFyYW1ldGVyLlxuICogICB7Ym9vbGVhbn0gW3JlamVjdFVSRE5BMjAxNT1mYWxzZV0gLSBSZWplY3QgdGhlIFwiVVJETkEyMDE1XCIgYWxnb3JpdGhtIG5hbWVcbiAqICAgICBpbnN0ZWFkIG9mIHRyZWF0aW5nIGl0IGFzIGFuIGFsaWFzIGZvciBcIlJERkMtMS4wXCIuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY2Fub25pY2FsaXplZFxuICogICBSREYgRGF0YXNldC5cbiAqL1xuZXhwb3J0cy5fY2Fub25pemVTeW5jID0gZnVuY3Rpb24oaW5wdXQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBkYXRhc2V0ID0gX2lucHV0VG9EYXRhc2V0KGlucHV0LCBvcHRpb25zKTtcbiAgX2NoZWNrT3V0cHV0Rm9ybWF0KG9wdGlvbnMpO1xuXG4gIGlmKG9wdGlvbnMudXNlTmF0aXZlKSB7XG4gICAgaWYoIXJkZkNhbm9uaXplTmF0aXZlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JkZi1jYW5vbml6ZS1uYXRpdmUgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgICBpZihvcHRpb25zLmNyZWF0ZU1lc3NhZ2VEaWdlc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiY3JlYXRlTWVzc2FnZURpZ2VzdFwiIGNhbm5vdCBiZSB1c2VkIHdpdGggXCJ1c2VOYXRpdmVcIi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJkZkNhbm9uaXplTmF0aXZlLmNhbm9uaXplU3luYyhkYXRhc2V0LCBvcHRpb25zKTtcbiAgfVxuICBpZighKCdhbGdvcml0aG0nIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBSREYgRGF0YXNldCBDYW5vbmljYWxpemF0aW9uIGFsZ29yaXRobSBzcGVjaWZpZWQuJyk7XG4gIH1cbiAgaWYob3B0aW9ucy5hbGdvcml0aG0gPT09ICdSREZDLTEuMCcpIHtcbiAgICByZXR1cm4gbmV3IFJERkMxMFN5bmMob3B0aW9ucykubWFpbihkYXRhc2V0KTtcbiAgfVxuICAvLyBVUkROQTIwMTUgZGVwcmVjYXRlZCwgaGFuZGxlZCBhcyBhbGlhcyBmb3IgUkRGQy0xLjAgaWYgYWxsb3dlZFxuICBpZihvcHRpb25zLmFsZ29yaXRobSA9PT0gJ1VSRE5BMjAxNScgJiYgIW9wdGlvbnMucmVqZWN0VVJETkEyMDE1KSB7XG4gICAgX3RyYWNlVVJETkEyMDE1KCk7XG4gICAgcmV0dXJuIG5ldyBSREZDMTBTeW5jKG9wdGlvbnMpLm1haW4oZGF0YXNldCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICdJbnZhbGlkIFJERiBEYXRhc2V0IENhbm9uaWNhbGl6YXRpb24gYWxnb3JpdGhtOiAnICsgb3B0aW9ucy5hbGdvcml0aG0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/platform.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/platform.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Copyright (c) 2023 Digital Bazaar, Inc. All rights reserved.\n */\n\n\nexports.setImmediate = setImmediate;\n\n// WebCrypto\nconst crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = crypto.webcrypto;\n\nexports.bufferToHex = function bufferToHex(buffer) {\n  return Buffer.from(buffer).toString('hex');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNvbmxkLXNpZ25hdHVyZXMvbm9kZV9tb2R1bGVzL3JkZi1jYW5vbml6ZS9saWIvcGxhdGZvcm0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsb0JBQW9COztBQUVwQjtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxjQUFjOztBQUVkLG1CQUFtQjtBQUNuQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2pzb25sZC1zaWduYXR1cmVzL25vZGVfbW9kdWxlcy9yZGYtY2Fub25pemUvbGliL3BsYXRmb3JtLmpzP2YwNjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMgRGlnaXRhbCBCYXphYXIsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcblxuLy8gV2ViQ3J5cHRvXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpO1xuZXhwb3J0cy5jcnlwdG8gPSBjcnlwdG8ud2ViY3J5cHRvO1xuXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gYnVmZmVyVG9IZXgoYnVmZmVyKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/platform.js\n");

/***/ })

};
;